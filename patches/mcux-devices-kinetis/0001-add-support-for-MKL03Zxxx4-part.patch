From 168139e8e4bea55e9383f2f8d4db076653e9bba1 Mon Sep 17 00:00:00 2001
From: Benedek Kupper <kupper.benedek@gmail.com>
Date: Thu, 26 Jun 2025 21:09:10 +0200
Subject: [PATCH] add support for MKL03Zxxx4 part

---
 KL0/MKL03Z4/CMakeLists.txt            |   11 +
 KL0/MKL03Z4/Kconfig                   |   19 +
 KL0/MKL03Z4/Kconfig.chip              |  182 ++
 KL0/MKL03Z4/Kconfig.defconfig         |    4 +
 KL0/MKL03Z4/MKL03Z4.h                 | 3939 +++++++++++++++++++++++++
 KL0/MKL03Z4/MKL03Z4_COMMON.h          |    1 +
 KL0/MKL03Z4/MKL03Z4_features.h        | 1832 ++++++++++++
 KL0/MKL03Z4/drivers/CMakeLists.txt    |   16 +
 KL0/MKL03Z4/drivers/Kconfig           |   16 +
 KL0/MKL03Z4/drivers/fsl_clock.c       |  352 +++
 KL0/MKL03Z4/drivers/fsl_clock.h       |  714 +++++
 KL0/MKL03Z4/drivers/fsl_port.h        |  490 +++
 KL0/MKL03Z4/fsl_device_registers.h    |   63 +
 KL0/MKL03Z4/gcc/MKL03Z32xxx4_flash.ld |  242 ++
 KL0/MKL03Z4/gcc/MKL03Z32xxx4_ram.ld   |  234 ++
 KL0/MKL03Z4/gcc/startup_MKL03Z4.S     |  316 ++
 KL0/MKL03Z4/prj.conf                  |    4 +
 KL0/MKL03Z4/system_MKL03Z4.c          |  146 +
 KL0/MKL03Z4/system_MKL03Z4.h          |  154 +
 KL0/MKL03Z4/variable.cmake            |   14 +
 20 files changed, 8749 insertions(+)
 create mode 100644 KL0/MKL03Z4/CMakeLists.txt
 create mode 100644 KL0/MKL03Z4/Kconfig
 create mode 100644 KL0/MKL03Z4/Kconfig.chip
 create mode 100644 KL0/MKL03Z4/Kconfig.defconfig
 create mode 100644 KL0/MKL03Z4/MKL03Z4.h
 create mode 100644 KL0/MKL03Z4/MKL03Z4_COMMON.h
 create mode 100644 KL0/MKL03Z4/MKL03Z4_features.h
 create mode 100644 KL0/MKL03Z4/drivers/CMakeLists.txt
 create mode 100644 KL0/MKL03Z4/drivers/Kconfig
 create mode 100644 KL0/MKL03Z4/drivers/fsl_clock.c
 create mode 100644 KL0/MKL03Z4/drivers/fsl_clock.h
 create mode 100644 KL0/MKL03Z4/drivers/fsl_port.h
 create mode 100644 KL0/MKL03Z4/fsl_device_registers.h
 create mode 100644 KL0/MKL03Z4/gcc/MKL03Z32xxx4_flash.ld
 create mode 100644 KL0/MKL03Z4/gcc/MKL03Z32xxx4_ram.ld
 create mode 100644 KL0/MKL03Z4/gcc/startup_MKL03Z4.S
 create mode 100644 KL0/MKL03Z4/prj.conf
 create mode 100644 KL0/MKL03Z4/system_MKL03Z4.c
 create mode 100644 KL0/MKL03Z4/system_MKL03Z4.h
 create mode 100644 KL0/MKL03Z4/variable.cmake

diff --git a/KL0/MKL03Z4/CMakeLists.txt b/KL0/MKL03Z4/CMakeLists.txt
new file mode 100644
index 0000000..3fc7f4b
--- /dev/null
+++ b/KL0/MKL03Z4/CMakeLists.txt
@@ -0,0 +1,11 @@
+# Copyright 2024 NXP
+# All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+#### device spepcific drivers
+include(${SdkRootDirPath}/devices/arm/device_header.cmake)
+mcux_add_cmakelists(${SdkRootDirPath}/${device_root}/Kinetis/KL0/MKL03Z4/drivers)
+
+#### Kinetis shared drivers/components/middlewares, project segments
+include(${SdkRootDirPath}/devices/Kinetis/shared.cmake)
diff --git a/KL0/MKL03Z4/Kconfig b/KL0/MKL03Z4/Kconfig
new file mode 100644
index 0000000..68b154e
--- /dev/null
+++ b/KL0/MKL03Z4/Kconfig
@@ -0,0 +1,19 @@
+# Copyright 2024 NXP
+# All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+rsource "Kconfig.chip"
+rsource "drivers/Kconfig"
+rsource "../../../../devices/arm/Kconfig.common"
+rsource "Kconfig.defconfig"
+
+## Project segment and component dependency data
+config MCUX_HW_DEVICE_MKL03Z4
+    # bool "Device MKL03Z4 Configuration"
+    bool
+    default y
+
+    # component dependency
+    select MCUX_COMPONENT_component.uart_adapter if MCUX_COMPONENT_component.serial_manager_uart
+    select MCUX_COMPONENT_component.uart_adapter if MCUX_COMPONENT_utility.debug_console_lite
diff --git a/KL0/MKL03Z4/Kconfig.chip b/KL0/MKL03Z4/Kconfig.chip
new file mode 100644
index 0000000..e30f2b4
--- /dev/null
+++ b/KL0/MKL03Z4/Kconfig.chip
@@ -0,0 +1,182 @@
+# Copyright 2024 NXP
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+# core related
+config MCUX_HW_CORE
+    string
+    default "cm0p"
+
+config MCUX_HW_CORE_CM0P
+    bool
+    default y
+
+config MCUX_HW_CORE_ID
+    string
+    default "core0"
+
+config MCUX_HW_CORE_ID_CORE0
+    bool
+    default y
+
+config MCUX_HW_DEVICE_CORE
+    string
+    default "MKL03Z4"
+
+    config MCUX_HW_FPU
+        string
+        default "NO_FPU"
+
+    config MCUX_HW_FPU_TYPE
+        string
+        default "no_fpu"
+
+    config MCUX_HW_NO_FPU
+        bool
+        default y
+
+    config MCUX_HW_INT_PRIO_BITS
+        int
+        default 2
+
+config MCUX_HW_SOC_SERIES_KINETIS
+    bool
+    default y
+
+config MCUX_HW_SOC_SINGLECORE_DEVICE
+    bool
+    default y
+
+# device related
+
+config MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+    bool
+
+choice MCUX_HW_DEVICE_PART_MKL03Z4
+    prompt "Device MKL03Z4 Part"
+    config MCUX_HW_DEVICE_PART_MKL03Z32VFK4
+    bool "MKL03Z32VFK4"
+    select MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+endchoice
+
+config MCUX_HW_DEVICE_ID
+    string
+    default "MKL03Z32xxx4" if MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_DEVICE_PART
+    string
+    default "MKL03Z32VFK4" if MCUX_HW_DEVICE_PART_MKL03Z32VFK4
+
+# For chipmodel generated files
+config MCUX_TOOLCHAIN_LINKER_DEVICE_PREFIX
+    string
+    default "MKL03Z32xxx4" if MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_TOOLCHAIN_MCUX_STARTUP
+    string
+    default "MKL03Z4"
+
+# Toolchain related
+
+config MCUX_TOOLCHAIN_IAR_CPU_IDENTIFIER
+    string
+    default "MKL03Z32xxx4" if MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_TOOLCHAIN_MDK_CPU_IDENTIFIER
+    string
+    default "MKL03Z32VFK4" if MCUX_HW_DEVICE_PART_MKL03Z32VFK4
+
+config MCUX_TOOLCHAIN_JLINK_CPU_IDENTIFIER
+    string
+    default "MKL03Z32xxx4" if MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+# ip information
+config MCUX_HW_IP_DriverType_ADC16
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_CMP
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_COP
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_GPIO
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_I2C
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_IRQ
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_LLWU
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_LPTMR
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_LPUART
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_PMC
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_PORT_KL0
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_RCM
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_RTC
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_SIM
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_SMC
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_SPI
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_TPM
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
+
+config MCUX_HW_IP_DriverType_VREF
+    bool
+    default y
+    depends on MCUX_HW_DEVICE_ID_MKL03Z32xxx4
diff --git a/KL0/MKL03Z4/Kconfig.defconfig b/KL0/MKL03Z4/Kconfig.defconfig
new file mode 100644
index 0000000..81f98ce
--- /dev/null
+++ b/KL0/MKL03Z4/Kconfig.defconfig
@@ -0,0 +1,4 @@
+# Copyright 2024 NXP
+# All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
diff --git a/KL0/MKL03Z4/MKL03Z4.h b/KL0/MKL03Z4/MKL03Z4.h
new file mode 100644
index 0000000..8631e76
--- /dev/null
+++ b/KL0/MKL03Z4/MKL03Z4.h
@@ -0,0 +1,3939 @@
+/*
+** ###################################################################
+**     Processors:          MKL03Z16VFG4
+**                          MKL03Z16VFK4
+**                          MKL03Z32CAF4
+**                          MKL03Z32VFG4
+**                          MKL03Z32VFK4
+**                          MKL03Z8VFG4
+**                          MKL03Z8VFK4
+**
+**     Compilers:           Keil ARM C/C++ Compiler
+**                          Freescale C/C++ for Embedded ARM
+**                          GNU C Compiler
+**                          IAR ANSI C/C++ Compiler for ARM
+**                          MCUXpresso Compiler
+**
+**     Reference manual:    KL03P24M48SF0RM, Rev 2, Apr 2014
+**     Version:             rev. 1.4, 2014-08-28
+**     Build:               b170811
+**
+**     Abstract:
+**         CMSIS Peripheral Access Layer for MKL03Z4
+**
+**     The Clear BSD License
+**     Copyright 1997-2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2017 NXP
+**     All rights reserved.
+**     
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted (subject to the limitations in the disclaimer below) provided
+**      that the following conditions are met:
+**
+**     1. Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     2. Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     3. Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+**     Revisions:
+**     - rev. 1.0 (2013-12-11)
+**         Initial version.
+**     - rev. 1.1 (2014-04-16)
+**         Update of the I2C module (SMBUS feature).
+**         Update of the MCG_Light module.
+**         Added register file system (RFSYS).
+**     - rev. 1.2 (2014-04-30)
+**         PEx compatibility macros has been added.
+**     - rev. 1.3 (2014-06-27)
+**         I2C_S1 register was renamed.
+**         GPIO - Modules PTA,PTB renamed to GPIOA,GPIOB.
+**     - rev. 1.4 (2014-08-28)
+**         Update of system files - default clock configuration changed.
+**         Update of startup files - possibility to override DefaultISR added.
+**
+** ###################################################################
+*/
+
+/*!
+ * @file MKL03Z4.h
+ * @version 1.4
+ * @date 2014-08-28
+ * @brief CMSIS Peripheral Access Layer for MKL03Z4
+ *
+ * CMSIS Peripheral Access Layer for MKL03Z4
+ */
+
+#ifndef _MKL03Z4_H_
+#define _MKL03Z4_H_                              /**< Symbol preventing repeated inclusion */
+
+/** Memory map major version (memory maps with equal major version number are
+ * compatible) */
+#define MCU_MEM_MAP_VERSION 0x0100U
+/** Memory map minor version */
+#define MCU_MEM_MAP_VERSION_MINOR 0x0004U
+
+
+/* ----------------------------------------------------------------------------
+   -- Interrupt vector numbers
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup Interrupt_vector_numbers Interrupt vector numbers
+ * @{
+ */
+
+/** Interrupt Number Definitions */
+#define NUMBER_OF_INT_VECTORS 48                 /**< Number of interrupts in the Vector table */
+
+typedef enum IRQn {
+  /* Auxiliary constants */
+  NotAvail_IRQn                = -128,             /**< Not available device specific interrupt */
+
+  /* Core interrupts */
+  NonMaskableInt_IRQn          = -14,              /**< Non Maskable Interrupt */
+  HardFault_IRQn               = -13,              /**< Cortex-M0 SV Hard Fault Interrupt */
+  SVCall_IRQn                  = -5,               /**< Cortex-M0 SV Call Interrupt */
+  PendSV_IRQn                  = -2,               /**< Cortex-M0 Pend SV Interrupt */
+  SysTick_IRQn                 = -1,               /**< Cortex-M0 System Tick Interrupt */
+
+  /* Device specific interrupts */
+  Reserved16_IRQn              = 0,                /**< Reserved interrupt */
+  Reserved17_IRQn              = 1,                /**< Reserved interrupt */
+  Reserved18_IRQn              = 2,                /**< Reserved interrupt */
+  Reserved19_IRQn              = 3,                /**< Reserved interrupt */
+  Reserved20_IRQn              = 4,                /**< Reserved interrupt */
+  FTFA_IRQn                    = 5,                /**< Command complete and read collision */
+  PMC_IRQn                     = 6,                /**< Low-voltage detect, low-voltage warning */
+  LLWU_IRQn                    = 7,                /**< Low leakage wakeup */
+  I2C0_IRQn                    = 8,                /**< I2C0 interrupt */
+  Reserved25_IRQn              = 9,                /**< Reserved interrupt */
+  SPI0_IRQn                    = 10,               /**< SPI0 single interrupt vector for all sources */
+  Reserved27_IRQn              = 11,               /**< Reserved interrupt */
+  LPUART0_IRQn                 = 12,               /**< LPUART0 status and error */
+  Reserved29_IRQn              = 13,               /**< Reserved interrupt */
+  Reserved30_IRQn              = 14,               /**< Reserved interrupt */
+  ADC0_IRQn                    = 15,               /**< ADC0 interrupt */
+  CMP0_IRQn                    = 16,               /**< CMP0 interrupt */
+  TPM0_IRQn                    = 17,               /**< TPM0 single interrupt vector for all sources */
+  TPM1_IRQn                    = 18,               /**< TPM1 single interrupt vector for all sources */
+  Reserved35_IRQn              = 19,               /**< Reserved interrupt */
+  RTC_IRQn                     = 20,               /**< RTC alarm */
+  RTC_Seconds_IRQn             = 21,               /**< RTC seconds */
+  Reserved38_IRQn              = 22,               /**< Reserved interrupt */
+  Reserved39_IRQn              = 23,               /**< Reserved interrupt */
+  Reserved40_IRQn              = 24,               /**< Reserved interrupt */
+  Reserved41_IRQn              = 25,               /**< Reserved interrupt */
+  Reserved42_IRQn              = 26,               /**< Reserved interrupt */
+  Reserved43_IRQn              = 27,               /**< Reserved interrupt */
+  LPTMR0_IRQn                  = 28,               /**< LPTMR0 interrupt */
+  Reserved45_IRQn              = 29,               /**< Reserved interrupt */
+  PORTA_IRQn                   = 30,               /**< PORTA Pin detect */
+  PORTB_IRQn                   = 31                /**< PORTB Pin detect */
+} IRQn_Type;
+
+/*!
+ * @}
+ */ /* end of group Interrupt_vector_numbers */
+
+
+/* ----------------------------------------------------------------------------
+   -- Cortex M0 Core Configuration
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup Cortex_Core_Configuration Cortex M0 Core Configuration
+ * @{
+ */
+
+#define __CM0PLUS_REV                  0x0000    /**< Core revision r0p0 */
+#define __MPU_PRESENT                  0         /**< Defines if an MPU is present or not */
+#define __VTOR_PRESENT                 1         /**< Defines if VTOR is present or not */
+#define __NVIC_PRIO_BITS               2         /**< Number of priority bits implemented in the NVIC */
+#define __Vendor_SysTickConfig         0         /**< Vendor specific implementation of SysTickConfig is defined */
+
+#include "core_cm0plus.h"              /* Core Peripheral Access Layer */
+#include "system_MKL03Z4.h"            /* Device specific configuration file */
+
+/*!
+ * @}
+ */ /* end of group Cortex_Core_Configuration */
+
+
+/* ----------------------------------------------------------------------------
+   -- Device Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup Peripheral_access_layer Device Peripheral Access Layer
+ * @{
+ */
+
+
+/*
+** Start of section using anonymous unions
+*/
+
+#if defined(__ARMCC_VERSION)
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+  /* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/* ----------------------------------------------------------------------------
+   -- ADC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ADC_Peripheral_Access_Layer ADC Peripheral Access Layer
+ * @{
+ */
+
+/** ADC - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t SC1[2];                            /**< ADC Status and Control Registers 1, array offset: 0x0, array step: 0x4 */
+  __IO uint32_t CFG1;                              /**< ADC Configuration Register 1, offset: 0x8 */
+  __IO uint32_t CFG2;                              /**< ADC Configuration Register 2, offset: 0xC */
+  __I  uint32_t R[2];                              /**< ADC Data Result Register, array offset: 0x10, array step: 0x4 */
+  __IO uint32_t CV1;                               /**< Compare Value Registers, offset: 0x18 */
+  __IO uint32_t CV2;                               /**< Compare Value Registers, offset: 0x1C */
+  __IO uint32_t SC2;                               /**< Status and Control Register 2, offset: 0x20 */
+  __IO uint32_t SC3;                               /**< Status and Control Register 3, offset: 0x24 */
+  __IO uint32_t OFS;                               /**< ADC Offset Correction Register, offset: 0x28 */
+  __IO uint32_t PG;                                /**< ADC Plus-Side Gain Register, offset: 0x2C */
+       uint8_t RESERVED_0[4];
+  __IO uint32_t CLPD;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x34 */
+  __IO uint32_t CLPS;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x38 */
+  __IO uint32_t CLP4;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x3C */
+  __IO uint32_t CLP3;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x40 */
+  __IO uint32_t CLP2;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x44 */
+  __IO uint32_t CLP1;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x48 */
+  __IO uint32_t CLP0;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x4C */
+} ADC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- ADC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ADC_Register_Masks ADC Register Masks
+ * @{
+ */
+
+/*! @name SC1 - ADC Status and Control Registers 1 */
+#define ADC_SC1_ADCH_MASK                        (0x1FU)
+#define ADC_SC1_ADCH_SHIFT                       (0U)
+#define ADC_SC1_ADCH(x)                          (((uint32_t)(((uint32_t)(x)) << ADC_SC1_ADCH_SHIFT)) & ADC_SC1_ADCH_MASK)
+#define ADC_SC1_AIEN_MASK                        (0x40U)
+#define ADC_SC1_AIEN_SHIFT                       (6U)
+#define ADC_SC1_AIEN(x)                          (((uint32_t)(((uint32_t)(x)) << ADC_SC1_AIEN_SHIFT)) & ADC_SC1_AIEN_MASK)
+#define ADC_SC1_COCO_MASK                        (0x80U)
+#define ADC_SC1_COCO_SHIFT                       (7U)
+#define ADC_SC1_COCO(x)                          (((uint32_t)(((uint32_t)(x)) << ADC_SC1_COCO_SHIFT)) & ADC_SC1_COCO_MASK)
+
+/* The count of ADC_SC1 */
+#define ADC_SC1_COUNT                            (2U)
+
+/*! @name CFG1 - ADC Configuration Register 1 */
+#define ADC_CFG1_ADICLK_MASK                     (0x3U)
+#define ADC_CFG1_ADICLK_SHIFT                    (0U)
+#define ADC_CFG1_ADICLK(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_CFG1_ADICLK_SHIFT)) & ADC_CFG1_ADICLK_MASK)
+#define ADC_CFG1_MODE_MASK                       (0xCU)
+#define ADC_CFG1_MODE_SHIFT                      (2U)
+#define ADC_CFG1_MODE(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CFG1_MODE_SHIFT)) & ADC_CFG1_MODE_MASK)
+#define ADC_CFG1_ADLSMP_MASK                     (0x10U)
+#define ADC_CFG1_ADLSMP_SHIFT                    (4U)
+#define ADC_CFG1_ADLSMP(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_CFG1_ADLSMP_SHIFT)) & ADC_CFG1_ADLSMP_MASK)
+#define ADC_CFG1_ADIV_MASK                       (0x60U)
+#define ADC_CFG1_ADIV_SHIFT                      (5U)
+#define ADC_CFG1_ADIV(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CFG1_ADIV_SHIFT)) & ADC_CFG1_ADIV_MASK)
+#define ADC_CFG1_ADLPC_MASK                      (0x80U)
+#define ADC_CFG1_ADLPC_SHIFT                     (7U)
+#define ADC_CFG1_ADLPC(x)                        (((uint32_t)(((uint32_t)(x)) << ADC_CFG1_ADLPC_SHIFT)) & ADC_CFG1_ADLPC_MASK)
+
+/*! @name CFG2 - ADC Configuration Register 2 */
+#define ADC_CFG2_ADLSTS_MASK                     (0x3U)
+#define ADC_CFG2_ADLSTS_SHIFT                    (0U)
+#define ADC_CFG2_ADLSTS(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_CFG2_ADLSTS_SHIFT)) & ADC_CFG2_ADLSTS_MASK)
+#define ADC_CFG2_ADHSC_MASK                      (0x4U)
+#define ADC_CFG2_ADHSC_SHIFT                     (2U)
+#define ADC_CFG2_ADHSC(x)                        (((uint32_t)(((uint32_t)(x)) << ADC_CFG2_ADHSC_SHIFT)) & ADC_CFG2_ADHSC_MASK)
+#define ADC_CFG2_ADACKEN_MASK                    (0x8U)
+#define ADC_CFG2_ADACKEN_SHIFT                   (3U)
+#define ADC_CFG2_ADACKEN(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_CFG2_ADACKEN_SHIFT)) & ADC_CFG2_ADACKEN_MASK)
+#define ADC_CFG2_MUXSEL_MASK                     (0x10U)
+#define ADC_CFG2_MUXSEL_SHIFT                    (4U)
+#define ADC_CFG2_MUXSEL(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_CFG2_MUXSEL_SHIFT)) & ADC_CFG2_MUXSEL_MASK)
+
+/*! @name R - ADC Data Result Register */
+#define ADC_R_D_MASK                             (0xFFFFU)
+#define ADC_R_D_SHIFT                            (0U)
+#define ADC_R_D(x)                               (((uint32_t)(((uint32_t)(x)) << ADC_R_D_SHIFT)) & ADC_R_D_MASK)
+
+/* The count of ADC_R */
+#define ADC_R_COUNT                              (2U)
+
+/*! @name CV1 - Compare Value Registers */
+#define ADC_CV1_CV_MASK                          (0xFFFFU)
+#define ADC_CV1_CV_SHIFT                         (0U)
+#define ADC_CV1_CV(x)                            (((uint32_t)(((uint32_t)(x)) << ADC_CV1_CV_SHIFT)) & ADC_CV1_CV_MASK)
+
+/*! @name CV2 - Compare Value Registers */
+#define ADC_CV2_CV_MASK                          (0xFFFFU)
+#define ADC_CV2_CV_SHIFT                         (0U)
+#define ADC_CV2_CV(x)                            (((uint32_t)(((uint32_t)(x)) << ADC_CV2_CV_SHIFT)) & ADC_CV2_CV_MASK)
+
+/*! @name SC2 - Status and Control Register 2 */
+#define ADC_SC2_REFSEL_MASK                      (0x3U)
+#define ADC_SC2_REFSEL_SHIFT                     (0U)
+#define ADC_SC2_REFSEL(x)                        (((uint32_t)(((uint32_t)(x)) << ADC_SC2_REFSEL_SHIFT)) & ADC_SC2_REFSEL_MASK)
+#define ADC_SC2_ACREN_MASK                       (0x8U)
+#define ADC_SC2_ACREN_SHIFT                      (3U)
+#define ADC_SC2_ACREN(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_SC2_ACREN_SHIFT)) & ADC_SC2_ACREN_MASK)
+#define ADC_SC2_ACFGT_MASK                       (0x10U)
+#define ADC_SC2_ACFGT_SHIFT                      (4U)
+#define ADC_SC2_ACFGT(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_SC2_ACFGT_SHIFT)) & ADC_SC2_ACFGT_MASK)
+#define ADC_SC2_ACFE_MASK                        (0x20U)
+#define ADC_SC2_ACFE_SHIFT                       (5U)
+#define ADC_SC2_ACFE(x)                          (((uint32_t)(((uint32_t)(x)) << ADC_SC2_ACFE_SHIFT)) & ADC_SC2_ACFE_MASK)
+#define ADC_SC2_ADTRG_MASK                       (0x40U)
+#define ADC_SC2_ADTRG_SHIFT                      (6U)
+#define ADC_SC2_ADTRG(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_SC2_ADTRG_SHIFT)) & ADC_SC2_ADTRG_MASK)
+#define ADC_SC2_ADACT_MASK                       (0x80U)
+#define ADC_SC2_ADACT_SHIFT                      (7U)
+#define ADC_SC2_ADACT(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_SC2_ADACT_SHIFT)) & ADC_SC2_ADACT_MASK)
+
+/*! @name SC3 - Status and Control Register 3 */
+#define ADC_SC3_AVGS_MASK                        (0x3U)
+#define ADC_SC3_AVGS_SHIFT                       (0U)
+#define ADC_SC3_AVGS(x)                          (((uint32_t)(((uint32_t)(x)) << ADC_SC3_AVGS_SHIFT)) & ADC_SC3_AVGS_MASK)
+#define ADC_SC3_AVGE_MASK                        (0x4U)
+#define ADC_SC3_AVGE_SHIFT                       (2U)
+#define ADC_SC3_AVGE(x)                          (((uint32_t)(((uint32_t)(x)) << ADC_SC3_AVGE_SHIFT)) & ADC_SC3_AVGE_MASK)
+#define ADC_SC3_ADCO_MASK                        (0x8U)
+#define ADC_SC3_ADCO_SHIFT                       (3U)
+#define ADC_SC3_ADCO(x)                          (((uint32_t)(((uint32_t)(x)) << ADC_SC3_ADCO_SHIFT)) & ADC_SC3_ADCO_MASK)
+#define ADC_SC3_CALF_MASK                        (0x40U)
+#define ADC_SC3_CALF_SHIFT                       (6U)
+#define ADC_SC3_CALF(x)                          (((uint32_t)(((uint32_t)(x)) << ADC_SC3_CALF_SHIFT)) & ADC_SC3_CALF_MASK)
+#define ADC_SC3_CAL_MASK                         (0x80U)
+#define ADC_SC3_CAL_SHIFT                        (7U)
+#define ADC_SC3_CAL(x)                           (((uint32_t)(((uint32_t)(x)) << ADC_SC3_CAL_SHIFT)) & ADC_SC3_CAL_MASK)
+
+/*! @name OFS - ADC Offset Correction Register */
+#define ADC_OFS_OFS_MASK                         (0xFFFFU)
+#define ADC_OFS_OFS_SHIFT                        (0U)
+#define ADC_OFS_OFS(x)                           (((uint32_t)(((uint32_t)(x)) << ADC_OFS_OFS_SHIFT)) & ADC_OFS_OFS_MASK)
+
+/*! @name PG - ADC Plus-Side Gain Register */
+#define ADC_PG_PG_MASK                           (0xFFFFU)
+#define ADC_PG_PG_SHIFT                          (0U)
+#define ADC_PG_PG(x)                             (((uint32_t)(((uint32_t)(x)) << ADC_PG_PG_SHIFT)) & ADC_PG_PG_MASK)
+
+/*! @name CLPD - ADC Plus-Side General Calibration Value Register */
+#define ADC_CLPD_CLPD_MASK                       (0x3FU)
+#define ADC_CLPD_CLPD_SHIFT                      (0U)
+#define ADC_CLPD_CLPD(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CLPD_CLPD_SHIFT)) & ADC_CLPD_CLPD_MASK)
+
+/*! @name CLPS - ADC Plus-Side General Calibration Value Register */
+#define ADC_CLPS_CLPS_MASK                       (0x3FU)
+#define ADC_CLPS_CLPS_SHIFT                      (0U)
+#define ADC_CLPS_CLPS(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CLPS_CLPS_SHIFT)) & ADC_CLPS_CLPS_MASK)
+
+/*! @name CLP4 - ADC Plus-Side General Calibration Value Register */
+#define ADC_CLP4_CLP4_MASK                       (0x3FFU)
+#define ADC_CLP4_CLP4_SHIFT                      (0U)
+#define ADC_CLP4_CLP4(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CLP4_CLP4_SHIFT)) & ADC_CLP4_CLP4_MASK)
+
+/*! @name CLP3 - ADC Plus-Side General Calibration Value Register */
+#define ADC_CLP3_CLP3_MASK                       (0x1FFU)
+#define ADC_CLP3_CLP3_SHIFT                      (0U)
+#define ADC_CLP3_CLP3(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CLP3_CLP3_SHIFT)) & ADC_CLP3_CLP3_MASK)
+
+/*! @name CLP2 - ADC Plus-Side General Calibration Value Register */
+#define ADC_CLP2_CLP2_MASK                       (0xFFU)
+#define ADC_CLP2_CLP2_SHIFT                      (0U)
+#define ADC_CLP2_CLP2(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CLP2_CLP2_SHIFT)) & ADC_CLP2_CLP2_MASK)
+
+/*! @name CLP1 - ADC Plus-Side General Calibration Value Register */
+#define ADC_CLP1_CLP1_MASK                       (0x7FU)
+#define ADC_CLP1_CLP1_SHIFT                      (0U)
+#define ADC_CLP1_CLP1(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CLP1_CLP1_SHIFT)) & ADC_CLP1_CLP1_MASK)
+
+/*! @name CLP0 - ADC Plus-Side General Calibration Value Register */
+#define ADC_CLP0_CLP0_MASK                       (0x3FU)
+#define ADC_CLP0_CLP0_SHIFT                      (0U)
+#define ADC_CLP0_CLP0(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_CLP0_CLP0_SHIFT)) & ADC_CLP0_CLP0_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group ADC_Register_Masks */
+
+
+/* ADC - Peripheral instance base addresses */
+/** Peripheral ADC0 base address */
+#define ADC0_BASE                                (0x4003B000u)
+/** Peripheral ADC0 base pointer */
+#define ADC0                                     ((ADC_Type *)ADC0_BASE)
+/** Array initializer of ADC peripheral base addresses */
+#define ADC_BASE_ADDRS                           { ADC0_BASE }
+/** Array initializer of ADC peripheral base pointers */
+#define ADC_BASE_PTRS                            { ADC0 }
+/** Interrupt vectors for the ADC peripheral type */
+#define ADC_IRQS                                 { ADC0_IRQn }
+
+/*!
+ * @}
+ */ /* end of group ADC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- CMP Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup CMP_Peripheral_Access_Layer CMP Peripheral Access Layer
+ * @{
+ */
+
+/** CMP - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t CR0;                                /**< CMP Control Register 0, offset: 0x0 */
+  __IO uint8_t CR1;                                /**< CMP Control Register 1, offset: 0x1 */
+  __IO uint8_t FPR;                                /**< CMP Filter Period Register, offset: 0x2 */
+  __IO uint8_t SCR;                                /**< CMP Status and Control Register, offset: 0x3 */
+  __IO uint8_t DACCR;                              /**< DAC Control Register, offset: 0x4 */
+  __IO uint8_t MUXCR;                              /**< MUX Control Register, offset: 0x5 */
+} CMP_Type;
+
+/* ----------------------------------------------------------------------------
+   -- CMP Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup CMP_Register_Masks CMP Register Masks
+ * @{
+ */
+
+/*! @name CR0 - CMP Control Register 0 */
+#define CMP_CR0_HYSTCTR_MASK                     (0x3U)
+#define CMP_CR0_HYSTCTR_SHIFT                    (0U)
+#define CMP_CR0_HYSTCTR(x)                       (((uint8_t)(((uint8_t)(x)) << CMP_CR0_HYSTCTR_SHIFT)) & CMP_CR0_HYSTCTR_MASK)
+#define CMP_CR0_FILTER_CNT_MASK                  (0x70U)
+#define CMP_CR0_FILTER_CNT_SHIFT                 (4U)
+#define CMP_CR0_FILTER_CNT(x)                    (((uint8_t)(((uint8_t)(x)) << CMP_CR0_FILTER_CNT_SHIFT)) & CMP_CR0_FILTER_CNT_MASK)
+
+/*! @name CR1 - CMP Control Register 1 */
+#define CMP_CR1_EN_MASK                          (0x1U)
+#define CMP_CR1_EN_SHIFT                         (0U)
+#define CMP_CR1_EN(x)                            (((uint8_t)(((uint8_t)(x)) << CMP_CR1_EN_SHIFT)) & CMP_CR1_EN_MASK)
+#define CMP_CR1_OPE_MASK                         (0x2U)
+#define CMP_CR1_OPE_SHIFT                        (1U)
+#define CMP_CR1_OPE(x)                           (((uint8_t)(((uint8_t)(x)) << CMP_CR1_OPE_SHIFT)) & CMP_CR1_OPE_MASK)
+#define CMP_CR1_COS_MASK                         (0x4U)
+#define CMP_CR1_COS_SHIFT                        (2U)
+#define CMP_CR1_COS(x)                           (((uint8_t)(((uint8_t)(x)) << CMP_CR1_COS_SHIFT)) & CMP_CR1_COS_MASK)
+#define CMP_CR1_INV_MASK                         (0x8U)
+#define CMP_CR1_INV_SHIFT                        (3U)
+#define CMP_CR1_INV(x)                           (((uint8_t)(((uint8_t)(x)) << CMP_CR1_INV_SHIFT)) & CMP_CR1_INV_MASK)
+#define CMP_CR1_PMODE_MASK                       (0x10U)
+#define CMP_CR1_PMODE_SHIFT                      (4U)
+#define CMP_CR1_PMODE(x)                         (((uint8_t)(((uint8_t)(x)) << CMP_CR1_PMODE_SHIFT)) & CMP_CR1_PMODE_MASK)
+#define CMP_CR1_TRIGM_MASK                       (0x20U)
+#define CMP_CR1_TRIGM_SHIFT                      (5U)
+#define CMP_CR1_TRIGM(x)                         (((uint8_t)(((uint8_t)(x)) << CMP_CR1_TRIGM_SHIFT)) & CMP_CR1_TRIGM_MASK)
+#define CMP_CR1_WE_MASK                          (0x40U)
+#define CMP_CR1_WE_SHIFT                         (6U)
+#define CMP_CR1_WE(x)                            (((uint8_t)(((uint8_t)(x)) << CMP_CR1_WE_SHIFT)) & CMP_CR1_WE_MASK)
+#define CMP_CR1_SE_MASK                          (0x80U)
+#define CMP_CR1_SE_SHIFT                         (7U)
+#define CMP_CR1_SE(x)                            (((uint8_t)(((uint8_t)(x)) << CMP_CR1_SE_SHIFT)) & CMP_CR1_SE_MASK)
+
+/*! @name FPR - CMP Filter Period Register */
+#define CMP_FPR_FILT_PER_MASK                    (0xFFU)
+#define CMP_FPR_FILT_PER_SHIFT                   (0U)
+#define CMP_FPR_FILT_PER(x)                      (((uint8_t)(((uint8_t)(x)) << CMP_FPR_FILT_PER_SHIFT)) & CMP_FPR_FILT_PER_MASK)
+
+/*! @name SCR - CMP Status and Control Register */
+#define CMP_SCR_COUT_MASK                        (0x1U)
+#define CMP_SCR_COUT_SHIFT                       (0U)
+#define CMP_SCR_COUT(x)                          (((uint8_t)(((uint8_t)(x)) << CMP_SCR_COUT_SHIFT)) & CMP_SCR_COUT_MASK)
+#define CMP_SCR_CFF_MASK                         (0x2U)
+#define CMP_SCR_CFF_SHIFT                        (1U)
+#define CMP_SCR_CFF(x)                           (((uint8_t)(((uint8_t)(x)) << CMP_SCR_CFF_SHIFT)) & CMP_SCR_CFF_MASK)
+#define CMP_SCR_CFR_MASK                         (0x4U)
+#define CMP_SCR_CFR_SHIFT                        (2U)
+#define CMP_SCR_CFR(x)                           (((uint8_t)(((uint8_t)(x)) << CMP_SCR_CFR_SHIFT)) & CMP_SCR_CFR_MASK)
+#define CMP_SCR_IEF_MASK                         (0x8U)
+#define CMP_SCR_IEF_SHIFT                        (3U)
+#define CMP_SCR_IEF(x)                           (((uint8_t)(((uint8_t)(x)) << CMP_SCR_IEF_SHIFT)) & CMP_SCR_IEF_MASK)
+#define CMP_SCR_IER_MASK                         (0x10U)
+#define CMP_SCR_IER_SHIFT                        (4U)
+#define CMP_SCR_IER(x)                           (((uint8_t)(((uint8_t)(x)) << CMP_SCR_IER_SHIFT)) & CMP_SCR_IER_MASK)
+
+/*! @name DACCR - DAC Control Register */
+#define CMP_DACCR_VOSEL_MASK                     (0x3FU)
+#define CMP_DACCR_VOSEL_SHIFT                    (0U)
+#define CMP_DACCR_VOSEL(x)                       (((uint8_t)(((uint8_t)(x)) << CMP_DACCR_VOSEL_SHIFT)) & CMP_DACCR_VOSEL_MASK)
+#define CMP_DACCR_VRSEL_MASK                     (0x40U)
+#define CMP_DACCR_VRSEL_SHIFT                    (6U)
+#define CMP_DACCR_VRSEL(x)                       (((uint8_t)(((uint8_t)(x)) << CMP_DACCR_VRSEL_SHIFT)) & CMP_DACCR_VRSEL_MASK)
+#define CMP_DACCR_DACEN_MASK                     (0x80U)
+#define CMP_DACCR_DACEN_SHIFT                    (7U)
+#define CMP_DACCR_DACEN(x)                       (((uint8_t)(((uint8_t)(x)) << CMP_DACCR_DACEN_SHIFT)) & CMP_DACCR_DACEN_MASK)
+
+/*! @name MUXCR - MUX Control Register */
+#define CMP_MUXCR_MSEL_MASK                      (0x7U)
+#define CMP_MUXCR_MSEL_SHIFT                     (0U)
+#define CMP_MUXCR_MSEL(x)                        (((uint8_t)(((uint8_t)(x)) << CMP_MUXCR_MSEL_SHIFT)) & CMP_MUXCR_MSEL_MASK)
+#define CMP_MUXCR_PSEL_MASK                      (0x38U)
+#define CMP_MUXCR_PSEL_SHIFT                     (3U)
+#define CMP_MUXCR_PSEL(x)                        (((uint8_t)(((uint8_t)(x)) << CMP_MUXCR_PSEL_SHIFT)) & CMP_MUXCR_PSEL_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group CMP_Register_Masks */
+
+
+/* CMP - Peripheral instance base addresses */
+/** Peripheral CMP0 base address */
+#define CMP0_BASE                                (0x40073000u)
+/** Peripheral CMP0 base pointer */
+#define CMP0                                     ((CMP_Type *)CMP0_BASE)
+/** Array initializer of CMP peripheral base addresses */
+#define CMP_BASE_ADDRS                           { CMP0_BASE }
+/** Array initializer of CMP peripheral base pointers */
+#define CMP_BASE_PTRS                            { CMP0 }
+/** Interrupt vectors for the CMP peripheral type */
+#define CMP_IRQS                                 { CMP0_IRQn }
+
+/*!
+ * @}
+ */ /* end of group CMP_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- FGPIO Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FGPIO_Peripheral_Access_Layer FGPIO Peripheral Access Layer
+ * @{
+ */
+
+/** FGPIO - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t PDOR;                              /**< Port Data Output Register, offset: 0x0 */
+  __O  uint32_t PSOR;                              /**< Port Set Output Register, offset: 0x4 */
+  __O  uint32_t PCOR;                              /**< Port Clear Output Register, offset: 0x8 */
+  __O  uint32_t PTOR;                              /**< Port Toggle Output Register, offset: 0xC */
+  __I  uint32_t PDIR;                              /**< Port Data Input Register, offset: 0x10 */
+  __IO uint32_t PDDR;                              /**< Port Data Direction Register, offset: 0x14 */
+} FGPIO_Type;
+
+/* ----------------------------------------------------------------------------
+   -- FGPIO Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FGPIO_Register_Masks FGPIO Register Masks
+ * @{
+ */
+
+/*! @name PDOR - Port Data Output Register */
+#define FGPIO_PDOR_PDO_MASK                      (0xFFFFFFFFU)
+#define FGPIO_PDOR_PDO_SHIFT                     (0U)
+#define FGPIO_PDOR_PDO(x)                        (((uint32_t)(((uint32_t)(x)) << FGPIO_PDOR_PDO_SHIFT)) & FGPIO_PDOR_PDO_MASK)
+
+/*! @name PSOR - Port Set Output Register */
+#define FGPIO_PSOR_PTSO_MASK                     (0xFFFFFFFFU)
+#define FGPIO_PSOR_PTSO_SHIFT                    (0U)
+#define FGPIO_PSOR_PTSO(x)                       (((uint32_t)(((uint32_t)(x)) << FGPIO_PSOR_PTSO_SHIFT)) & FGPIO_PSOR_PTSO_MASK)
+
+/*! @name PCOR - Port Clear Output Register */
+#define FGPIO_PCOR_PTCO_MASK                     (0xFFFFFFFFU)
+#define FGPIO_PCOR_PTCO_SHIFT                    (0U)
+#define FGPIO_PCOR_PTCO(x)                       (((uint32_t)(((uint32_t)(x)) << FGPIO_PCOR_PTCO_SHIFT)) & FGPIO_PCOR_PTCO_MASK)
+
+/*! @name PTOR - Port Toggle Output Register */
+#define FGPIO_PTOR_PTTO_MASK                     (0xFFFFFFFFU)
+#define FGPIO_PTOR_PTTO_SHIFT                    (0U)
+#define FGPIO_PTOR_PTTO(x)                       (((uint32_t)(((uint32_t)(x)) << FGPIO_PTOR_PTTO_SHIFT)) & FGPIO_PTOR_PTTO_MASK)
+
+/*! @name PDIR - Port Data Input Register */
+#define FGPIO_PDIR_PDI_MASK                      (0xFFFFFFFFU)
+#define FGPIO_PDIR_PDI_SHIFT                     (0U)
+#define FGPIO_PDIR_PDI(x)                        (((uint32_t)(((uint32_t)(x)) << FGPIO_PDIR_PDI_SHIFT)) & FGPIO_PDIR_PDI_MASK)
+
+/*! @name PDDR - Port Data Direction Register */
+#define FGPIO_PDDR_PDD_MASK                      (0xFFFFFFFFU)
+#define FGPIO_PDDR_PDD_SHIFT                     (0U)
+#define FGPIO_PDDR_PDD(x)                        (((uint32_t)(((uint32_t)(x)) << FGPIO_PDDR_PDD_SHIFT)) & FGPIO_PDDR_PDD_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group FGPIO_Register_Masks */
+
+
+/* FGPIO - Peripheral instance base addresses */
+/** Peripheral FGPIOA base address */
+#define FGPIOA_BASE                              (0xF8000000u)
+/** Peripheral FGPIOA base pointer */
+#define FGPIOA                                   ((FGPIO_Type *)FGPIOA_BASE)
+/** Peripheral FGPIOB base address */
+#define FGPIOB_BASE                              (0xF8000040u)
+/** Peripheral FGPIOB base pointer */
+#define FGPIOB                                   ((FGPIO_Type *)FGPIOB_BASE)
+/** Array initializer of FGPIO peripheral base addresses */
+#define FGPIO_BASE_ADDRS                         { FGPIOA_BASE, FGPIOB_BASE }
+/** Array initializer of FGPIO peripheral base pointers */
+#define FGPIO_BASE_PTRS                          { FGPIOA, FGPIOB }
+
+/*!
+ * @}
+ */ /* end of group FGPIO_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- FTFA Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FTFA_Peripheral_Access_Layer FTFA Peripheral Access Layer
+ * @{
+ */
+
+/** FTFA - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t FSTAT;                              /**< Flash Status Register, offset: 0x0 */
+  __IO uint8_t FCNFG;                              /**< Flash Configuration Register, offset: 0x1 */
+  __I  uint8_t FSEC;                               /**< Flash Security Register, offset: 0x2 */
+  __I  uint8_t FOPT;                               /**< Flash Option Register, offset: 0x3 */
+  __IO uint8_t FCCOB3;                             /**< Flash Common Command Object Registers, offset: 0x4 */
+  __IO uint8_t FCCOB2;                             /**< Flash Common Command Object Registers, offset: 0x5 */
+  __IO uint8_t FCCOB1;                             /**< Flash Common Command Object Registers, offset: 0x6 */
+  __IO uint8_t FCCOB0;                             /**< Flash Common Command Object Registers, offset: 0x7 */
+  __IO uint8_t FCCOB7;                             /**< Flash Common Command Object Registers, offset: 0x8 */
+  __IO uint8_t FCCOB6;                             /**< Flash Common Command Object Registers, offset: 0x9 */
+  __IO uint8_t FCCOB5;                             /**< Flash Common Command Object Registers, offset: 0xA */
+  __IO uint8_t FCCOB4;                             /**< Flash Common Command Object Registers, offset: 0xB */
+  __IO uint8_t FCCOBB;                             /**< Flash Common Command Object Registers, offset: 0xC */
+  __IO uint8_t FCCOBA;                             /**< Flash Common Command Object Registers, offset: 0xD */
+  __IO uint8_t FCCOB9;                             /**< Flash Common Command Object Registers, offset: 0xE */
+  __IO uint8_t FCCOB8;                             /**< Flash Common Command Object Registers, offset: 0xF */
+  __IO uint8_t FPROT3;                             /**< Program Flash Protection Registers, offset: 0x10 */
+  __IO uint8_t FPROT2;                             /**< Program Flash Protection Registers, offset: 0x11 */
+  __IO uint8_t FPROT1;                             /**< Program Flash Protection Registers, offset: 0x12 */
+  __IO uint8_t FPROT0;                             /**< Program Flash Protection Registers, offset: 0x13 */
+} FTFA_Type;
+
+/* ----------------------------------------------------------------------------
+   -- FTFA Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FTFA_Register_Masks FTFA Register Masks
+ * @{
+ */
+
+/*! @name FSTAT - Flash Status Register */
+#define FTFA_FSTAT_MGSTAT0_MASK                  (0x1U)
+#define FTFA_FSTAT_MGSTAT0_SHIFT                 (0U)
+#define FTFA_FSTAT_MGSTAT0(x)                    (((uint8_t)(((uint8_t)(x)) << FTFA_FSTAT_MGSTAT0_SHIFT)) & FTFA_FSTAT_MGSTAT0_MASK)
+#define FTFA_FSTAT_FPVIOL_MASK                   (0x10U)
+#define FTFA_FSTAT_FPVIOL_SHIFT                  (4U)
+#define FTFA_FSTAT_FPVIOL(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FSTAT_FPVIOL_SHIFT)) & FTFA_FSTAT_FPVIOL_MASK)
+#define FTFA_FSTAT_ACCERR_MASK                   (0x20U)
+#define FTFA_FSTAT_ACCERR_SHIFT                  (5U)
+#define FTFA_FSTAT_ACCERR(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FSTAT_ACCERR_SHIFT)) & FTFA_FSTAT_ACCERR_MASK)
+#define FTFA_FSTAT_RDCOLERR_MASK                 (0x40U)
+#define FTFA_FSTAT_RDCOLERR_SHIFT                (6U)
+#define FTFA_FSTAT_RDCOLERR(x)                   (((uint8_t)(((uint8_t)(x)) << FTFA_FSTAT_RDCOLERR_SHIFT)) & FTFA_FSTAT_RDCOLERR_MASK)
+#define FTFA_FSTAT_CCIF_MASK                     (0x80U)
+#define FTFA_FSTAT_CCIF_SHIFT                    (7U)
+#define FTFA_FSTAT_CCIF(x)                       (((uint8_t)(((uint8_t)(x)) << FTFA_FSTAT_CCIF_SHIFT)) & FTFA_FSTAT_CCIF_MASK)
+
+/*! @name FCNFG - Flash Configuration Register */
+#define FTFA_FCNFG_ERSSUSP_MASK                  (0x10U)
+#define FTFA_FCNFG_ERSSUSP_SHIFT                 (4U)
+#define FTFA_FCNFG_ERSSUSP(x)                    (((uint8_t)(((uint8_t)(x)) << FTFA_FCNFG_ERSSUSP_SHIFT)) & FTFA_FCNFG_ERSSUSP_MASK)
+#define FTFA_FCNFG_ERSAREQ_MASK                  (0x20U)
+#define FTFA_FCNFG_ERSAREQ_SHIFT                 (5U)
+#define FTFA_FCNFG_ERSAREQ(x)                    (((uint8_t)(((uint8_t)(x)) << FTFA_FCNFG_ERSAREQ_SHIFT)) & FTFA_FCNFG_ERSAREQ_MASK)
+#define FTFA_FCNFG_RDCOLLIE_MASK                 (0x40U)
+#define FTFA_FCNFG_RDCOLLIE_SHIFT                (6U)
+#define FTFA_FCNFG_RDCOLLIE(x)                   (((uint8_t)(((uint8_t)(x)) << FTFA_FCNFG_RDCOLLIE_SHIFT)) & FTFA_FCNFG_RDCOLLIE_MASK)
+#define FTFA_FCNFG_CCIE_MASK                     (0x80U)
+#define FTFA_FCNFG_CCIE_SHIFT                    (7U)
+#define FTFA_FCNFG_CCIE(x)                       (((uint8_t)(((uint8_t)(x)) << FTFA_FCNFG_CCIE_SHIFT)) & FTFA_FCNFG_CCIE_MASK)
+
+/*! @name FSEC - Flash Security Register */
+#define FTFA_FSEC_SEC_MASK                       (0x3U)
+#define FTFA_FSEC_SEC_SHIFT                      (0U)
+#define FTFA_FSEC_SEC(x)                         (((uint8_t)(((uint8_t)(x)) << FTFA_FSEC_SEC_SHIFT)) & FTFA_FSEC_SEC_MASK)
+#define FTFA_FSEC_FSLACC_MASK                    (0xCU)
+#define FTFA_FSEC_FSLACC_SHIFT                   (2U)
+#define FTFA_FSEC_FSLACC(x)                      (((uint8_t)(((uint8_t)(x)) << FTFA_FSEC_FSLACC_SHIFT)) & FTFA_FSEC_FSLACC_MASK)
+#define FTFA_FSEC_MEEN_MASK                      (0x30U)
+#define FTFA_FSEC_MEEN_SHIFT                     (4U)
+#define FTFA_FSEC_MEEN(x)                        (((uint8_t)(((uint8_t)(x)) << FTFA_FSEC_MEEN_SHIFT)) & FTFA_FSEC_MEEN_MASK)
+#define FTFA_FSEC_KEYEN_MASK                     (0xC0U)
+#define FTFA_FSEC_KEYEN_SHIFT                    (6U)
+#define FTFA_FSEC_KEYEN(x)                       (((uint8_t)(((uint8_t)(x)) << FTFA_FSEC_KEYEN_SHIFT)) & FTFA_FSEC_KEYEN_MASK)
+
+/*! @name FOPT - Flash Option Register */
+#define FTFA_FOPT_OPT_MASK                       (0xFFU)
+#define FTFA_FOPT_OPT_SHIFT                      (0U)
+#define FTFA_FOPT_OPT(x)                         (((uint8_t)(((uint8_t)(x)) << FTFA_FOPT_OPT_SHIFT)) & FTFA_FOPT_OPT_MASK)
+
+/*! @name FCCOB3 - Flash Common Command Object Registers */
+#define FTFA_FCCOB3_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB3_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB3_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB3_CCOBn_SHIFT)) & FTFA_FCCOB3_CCOBn_MASK)
+
+/*! @name FCCOB2 - Flash Common Command Object Registers */
+#define FTFA_FCCOB2_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB2_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB2_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB2_CCOBn_SHIFT)) & FTFA_FCCOB2_CCOBn_MASK)
+
+/*! @name FCCOB1 - Flash Common Command Object Registers */
+#define FTFA_FCCOB1_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB1_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB1_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB1_CCOBn_SHIFT)) & FTFA_FCCOB1_CCOBn_MASK)
+
+/*! @name FCCOB0 - Flash Common Command Object Registers */
+#define FTFA_FCCOB0_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB0_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB0_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB0_CCOBn_SHIFT)) & FTFA_FCCOB0_CCOBn_MASK)
+
+/*! @name FCCOB7 - Flash Common Command Object Registers */
+#define FTFA_FCCOB7_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB7_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB7_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB7_CCOBn_SHIFT)) & FTFA_FCCOB7_CCOBn_MASK)
+
+/*! @name FCCOB6 - Flash Common Command Object Registers */
+#define FTFA_FCCOB6_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB6_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB6_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB6_CCOBn_SHIFT)) & FTFA_FCCOB6_CCOBn_MASK)
+
+/*! @name FCCOB5 - Flash Common Command Object Registers */
+#define FTFA_FCCOB5_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB5_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB5_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB5_CCOBn_SHIFT)) & FTFA_FCCOB5_CCOBn_MASK)
+
+/*! @name FCCOB4 - Flash Common Command Object Registers */
+#define FTFA_FCCOB4_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB4_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB4_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB4_CCOBn_SHIFT)) & FTFA_FCCOB4_CCOBn_MASK)
+
+/*! @name FCCOBB - Flash Common Command Object Registers */
+#define FTFA_FCCOBB_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOBB_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOBB_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOBB_CCOBn_SHIFT)) & FTFA_FCCOBB_CCOBn_MASK)
+
+/*! @name FCCOBA - Flash Common Command Object Registers */
+#define FTFA_FCCOBA_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOBA_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOBA_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOBA_CCOBn_SHIFT)) & FTFA_FCCOBA_CCOBn_MASK)
+
+/*! @name FCCOB9 - Flash Common Command Object Registers */
+#define FTFA_FCCOB9_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB9_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB9_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB9_CCOBn_SHIFT)) & FTFA_FCCOB9_CCOBn_MASK)
+
+/*! @name FCCOB8 - Flash Common Command Object Registers */
+#define FTFA_FCCOB8_CCOBn_MASK                   (0xFFU)
+#define FTFA_FCCOB8_CCOBn_SHIFT                  (0U)
+#define FTFA_FCCOB8_CCOBn(x)                     (((uint8_t)(((uint8_t)(x)) << FTFA_FCCOB8_CCOBn_SHIFT)) & FTFA_FCCOB8_CCOBn_MASK)
+
+/*! @name FPROT3 - Program Flash Protection Registers */
+#define FTFA_FPROT3_PROT_MASK                    (0xFFU)
+#define FTFA_FPROT3_PROT_SHIFT                   (0U)
+#define FTFA_FPROT3_PROT(x)                      (((uint8_t)(((uint8_t)(x)) << FTFA_FPROT3_PROT_SHIFT)) & FTFA_FPROT3_PROT_MASK)
+
+/*! @name FPROT2 - Program Flash Protection Registers */
+#define FTFA_FPROT2_PROT_MASK                    (0xFFU)
+#define FTFA_FPROT2_PROT_SHIFT                   (0U)
+#define FTFA_FPROT2_PROT(x)                      (((uint8_t)(((uint8_t)(x)) << FTFA_FPROT2_PROT_SHIFT)) & FTFA_FPROT2_PROT_MASK)
+
+/*! @name FPROT1 - Program Flash Protection Registers */
+#define FTFA_FPROT1_PROT_MASK                    (0xFFU)
+#define FTFA_FPROT1_PROT_SHIFT                   (0U)
+#define FTFA_FPROT1_PROT(x)                      (((uint8_t)(((uint8_t)(x)) << FTFA_FPROT1_PROT_SHIFT)) & FTFA_FPROT1_PROT_MASK)
+
+/*! @name FPROT0 - Program Flash Protection Registers */
+#define FTFA_FPROT0_PROT_MASK                    (0xFFU)
+#define FTFA_FPROT0_PROT_SHIFT                   (0U)
+#define FTFA_FPROT0_PROT(x)                      (((uint8_t)(((uint8_t)(x)) << FTFA_FPROT0_PROT_SHIFT)) & FTFA_FPROT0_PROT_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group FTFA_Register_Masks */
+
+
+/* FTFA - Peripheral instance base addresses */
+/** Peripheral FTFA base address */
+#define FTFA_BASE                                (0x40020000u)
+/** Peripheral FTFA base pointer */
+#define FTFA                                     ((FTFA_Type *)FTFA_BASE)
+/** Array initializer of FTFA peripheral base addresses */
+#define FTFA_BASE_ADDRS                          { FTFA_BASE }
+/** Array initializer of FTFA peripheral base pointers */
+#define FTFA_BASE_PTRS                           { FTFA }
+/** Interrupt vectors for the FTFA peripheral type */
+#define FTFA_COMMAND_COMPLETE_IRQS               { FTFA_IRQn }
+
+/*!
+ * @}
+ */ /* end of group FTFA_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- GPIO Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup GPIO_Peripheral_Access_Layer GPIO Peripheral Access Layer
+ * @{
+ */
+
+/** GPIO - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t PDOR;                              /**< Port Data Output Register, offset: 0x0 */
+  __O  uint32_t PSOR;                              /**< Port Set Output Register, offset: 0x4 */
+  __O  uint32_t PCOR;                              /**< Port Clear Output Register, offset: 0x8 */
+  __O  uint32_t PTOR;                              /**< Port Toggle Output Register, offset: 0xC */
+  __I  uint32_t PDIR;                              /**< Port Data Input Register, offset: 0x10 */
+  __IO uint32_t PDDR;                              /**< Port Data Direction Register, offset: 0x14 */
+} GPIO_Type;
+
+/* ----------------------------------------------------------------------------
+   -- GPIO Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup GPIO_Register_Masks GPIO Register Masks
+ * @{
+ */
+
+/*! @name PDOR - Port Data Output Register */
+#define GPIO_PDOR_PDO_MASK                       (0xFFFFFFFFU)
+#define GPIO_PDOR_PDO_SHIFT                      (0U)
+#define GPIO_PDOR_PDO(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_PDOR_PDO_SHIFT)) & GPIO_PDOR_PDO_MASK)
+
+/*! @name PSOR - Port Set Output Register */
+#define GPIO_PSOR_PTSO_MASK                      (0xFFFFFFFFU)
+#define GPIO_PSOR_PTSO_SHIFT                     (0U)
+#define GPIO_PSOR_PTSO(x)                        (((uint32_t)(((uint32_t)(x)) << GPIO_PSOR_PTSO_SHIFT)) & GPIO_PSOR_PTSO_MASK)
+
+/*! @name PCOR - Port Clear Output Register */
+#define GPIO_PCOR_PTCO_MASK                      (0xFFFFFFFFU)
+#define GPIO_PCOR_PTCO_SHIFT                     (0U)
+#define GPIO_PCOR_PTCO(x)                        (((uint32_t)(((uint32_t)(x)) << GPIO_PCOR_PTCO_SHIFT)) & GPIO_PCOR_PTCO_MASK)
+
+/*! @name PTOR - Port Toggle Output Register */
+#define GPIO_PTOR_PTTO_MASK                      (0xFFFFFFFFU)
+#define GPIO_PTOR_PTTO_SHIFT                     (0U)
+#define GPIO_PTOR_PTTO(x)                        (((uint32_t)(((uint32_t)(x)) << GPIO_PTOR_PTTO_SHIFT)) & GPIO_PTOR_PTTO_MASK)
+
+/*! @name PDIR - Port Data Input Register */
+#define GPIO_PDIR_PDI_MASK                       (0xFFFFFFFFU)
+#define GPIO_PDIR_PDI_SHIFT                      (0U)
+#define GPIO_PDIR_PDI(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_PDIR_PDI_SHIFT)) & GPIO_PDIR_PDI_MASK)
+
+/*! @name PDDR - Port Data Direction Register */
+#define GPIO_PDDR_PDD_MASK                       (0xFFFFFFFFU)
+#define GPIO_PDDR_PDD_SHIFT                      (0U)
+#define GPIO_PDDR_PDD(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_PDDR_PDD_SHIFT)) & GPIO_PDDR_PDD_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group GPIO_Register_Masks */
+
+
+/* GPIO - Peripheral instance base addresses */
+/** Peripheral GPIOA base address */
+#define GPIOA_BASE                               (0x400FF000u)
+/** Peripheral GPIOA base pointer */
+#define GPIOA                                    ((GPIO_Type *)GPIOA_BASE)
+/** Peripheral GPIOB base address */
+#define GPIOB_BASE                               (0x400FF040u)
+/** Peripheral GPIOB base pointer */
+#define GPIOB                                    ((GPIO_Type *)GPIOB_BASE)
+/** Array initializer of GPIO peripheral base addresses */
+#define GPIO_BASE_ADDRS                          { GPIOA_BASE, GPIOB_BASE }
+/** Array initializer of GPIO peripheral base pointers */
+#define GPIO_BASE_PTRS                           { GPIOA, GPIOB }
+
+/*!
+ * @}
+ */ /* end of group GPIO_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- I2C Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup I2C_Peripheral_Access_Layer I2C Peripheral Access Layer
+ * @{
+ */
+
+/** I2C - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t A1;                                 /**< I2C Address Register 1, offset: 0x0 */
+  __IO uint8_t F;                                  /**< I2C Frequency Divider register, offset: 0x1 */
+  __IO uint8_t C1;                                 /**< I2C Control Register 1, offset: 0x2 */
+  __IO uint8_t S;                                  /**< I2C Status register 1, offset: 0x3 */
+  __IO uint8_t D;                                  /**< I2C Data I/O register, offset: 0x4 */
+  __IO uint8_t C2;                                 /**< I2C Control Register 2, offset: 0x5 */
+  __IO uint8_t FLT;                                /**< I2C Programmable Input Glitch Filter register, offset: 0x6 */
+  __IO uint8_t RA;                                 /**< I2C Range Address register, offset: 0x7 */
+  __IO uint8_t SMB;                                /**< I2C SMBus Control and Status register, offset: 0x8 */
+  __IO uint8_t A2;                                 /**< I2C Address Register 2, offset: 0x9 */
+  __IO uint8_t SLTH;                               /**< I2C SCL Low Timeout Register High, offset: 0xA */
+  __IO uint8_t SLTL;                               /**< I2C SCL Low Timeout Register Low, offset: 0xB */
+  __IO uint8_t S2;                                 /**< I2C Status register 2, offset: 0xC */
+} I2C_Type;
+
+/* ----------------------------------------------------------------------------
+   -- I2C Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup I2C_Register_Masks I2C Register Masks
+ * @{
+ */
+
+/*! @name A1 - I2C Address Register 1 */
+#define I2C_A1_AD_MASK                           (0xFEU)
+#define I2C_A1_AD_SHIFT                          (1U)
+#define I2C_A1_AD(x)                             (((uint8_t)(((uint8_t)(x)) << I2C_A1_AD_SHIFT)) & I2C_A1_AD_MASK)
+
+/*! @name F - I2C Frequency Divider register */
+#define I2C_F_ICR_MASK                           (0x3FU)
+#define I2C_F_ICR_SHIFT                          (0U)
+#define I2C_F_ICR(x)                             (((uint8_t)(((uint8_t)(x)) << I2C_F_ICR_SHIFT)) & I2C_F_ICR_MASK)
+#define I2C_F_MULT_MASK                          (0xC0U)
+#define I2C_F_MULT_SHIFT                         (6U)
+#define I2C_F_MULT(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_F_MULT_SHIFT)) & I2C_F_MULT_MASK)
+
+/*! @name C1 - I2C Control Register 1 */
+#define I2C_C1_WUEN_MASK                         (0x2U)
+#define I2C_C1_WUEN_SHIFT                        (1U)
+#define I2C_C1_WUEN(x)                           (((uint8_t)(((uint8_t)(x)) << I2C_C1_WUEN_SHIFT)) & I2C_C1_WUEN_MASK)
+#define I2C_C1_RSTA_MASK                         (0x4U)
+#define I2C_C1_RSTA_SHIFT                        (2U)
+#define I2C_C1_RSTA(x)                           (((uint8_t)(((uint8_t)(x)) << I2C_C1_RSTA_SHIFT)) & I2C_C1_RSTA_MASK)
+#define I2C_C1_TXAK_MASK                         (0x8U)
+#define I2C_C1_TXAK_SHIFT                        (3U)
+#define I2C_C1_TXAK(x)                           (((uint8_t)(((uint8_t)(x)) << I2C_C1_TXAK_SHIFT)) & I2C_C1_TXAK_MASK)
+#define I2C_C1_TX_MASK                           (0x10U)
+#define I2C_C1_TX_SHIFT                          (4U)
+#define I2C_C1_TX(x)                             (((uint8_t)(((uint8_t)(x)) << I2C_C1_TX_SHIFT)) & I2C_C1_TX_MASK)
+#define I2C_C1_MST_MASK                          (0x20U)
+#define I2C_C1_MST_SHIFT                         (5U)
+#define I2C_C1_MST(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_C1_MST_SHIFT)) & I2C_C1_MST_MASK)
+#define I2C_C1_IICIE_MASK                        (0x40U)
+#define I2C_C1_IICIE_SHIFT                       (6U)
+#define I2C_C1_IICIE(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_C1_IICIE_SHIFT)) & I2C_C1_IICIE_MASK)
+#define I2C_C1_IICEN_MASK                        (0x80U)
+#define I2C_C1_IICEN_SHIFT                       (7U)
+#define I2C_C1_IICEN(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_C1_IICEN_SHIFT)) & I2C_C1_IICEN_MASK)
+
+/*! @name S - I2C Status register 1 */
+#define I2C_S_RXAK_MASK                          (0x1U)
+#define I2C_S_RXAK_SHIFT                         (0U)
+#define I2C_S_RXAK(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_S_RXAK_SHIFT)) & I2C_S_RXAK_MASK)
+#define I2C_S_IICIF_MASK                         (0x2U)
+#define I2C_S_IICIF_SHIFT                        (1U)
+#define I2C_S_IICIF(x)                           (((uint8_t)(((uint8_t)(x)) << I2C_S_IICIF_SHIFT)) & I2C_S_IICIF_MASK)
+#define I2C_S_SRW_MASK                           (0x4U)
+#define I2C_S_SRW_SHIFT                          (2U)
+#define I2C_S_SRW(x)                             (((uint8_t)(((uint8_t)(x)) << I2C_S_SRW_SHIFT)) & I2C_S_SRW_MASK)
+#define I2C_S_RAM_MASK                           (0x8U)
+#define I2C_S_RAM_SHIFT                          (3U)
+#define I2C_S_RAM(x)                             (((uint8_t)(((uint8_t)(x)) << I2C_S_RAM_SHIFT)) & I2C_S_RAM_MASK)
+#define I2C_S_ARBL_MASK                          (0x10U)
+#define I2C_S_ARBL_SHIFT                         (4U)
+#define I2C_S_ARBL(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_S_ARBL_SHIFT)) & I2C_S_ARBL_MASK)
+#define I2C_S_BUSY_MASK                          (0x20U)
+#define I2C_S_BUSY_SHIFT                         (5U)
+#define I2C_S_BUSY(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_S_BUSY_SHIFT)) & I2C_S_BUSY_MASK)
+#define I2C_S_IAAS_MASK                          (0x40U)
+#define I2C_S_IAAS_SHIFT                         (6U)
+#define I2C_S_IAAS(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_S_IAAS_SHIFT)) & I2C_S_IAAS_MASK)
+#define I2C_S_TCF_MASK                           (0x80U)
+#define I2C_S_TCF_SHIFT                          (7U)
+#define I2C_S_TCF(x)                             (((uint8_t)(((uint8_t)(x)) << I2C_S_TCF_SHIFT)) & I2C_S_TCF_MASK)
+
+/*! @name D - I2C Data I/O register */
+#define I2C_D_DATA_MASK                          (0xFFU)
+#define I2C_D_DATA_SHIFT                         (0U)
+#define I2C_D_DATA(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_D_DATA_SHIFT)) & I2C_D_DATA_MASK)
+
+/*! @name C2 - I2C Control Register 2 */
+#define I2C_C2_AD_MASK                           (0x7U)
+#define I2C_C2_AD_SHIFT                          (0U)
+#define I2C_C2_AD(x)                             (((uint8_t)(((uint8_t)(x)) << I2C_C2_AD_SHIFT)) & I2C_C2_AD_MASK)
+#define I2C_C2_RMEN_MASK                         (0x8U)
+#define I2C_C2_RMEN_SHIFT                        (3U)
+#define I2C_C2_RMEN(x)                           (((uint8_t)(((uint8_t)(x)) << I2C_C2_RMEN_SHIFT)) & I2C_C2_RMEN_MASK)
+#define I2C_C2_SBRC_MASK                         (0x10U)
+#define I2C_C2_SBRC_SHIFT                        (4U)
+#define I2C_C2_SBRC(x)                           (((uint8_t)(((uint8_t)(x)) << I2C_C2_SBRC_SHIFT)) & I2C_C2_SBRC_MASK)
+#define I2C_C2_ADEXT_MASK                        (0x40U)
+#define I2C_C2_ADEXT_SHIFT                       (6U)
+#define I2C_C2_ADEXT(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_C2_ADEXT_SHIFT)) & I2C_C2_ADEXT_MASK)
+#define I2C_C2_GCAEN_MASK                        (0x80U)
+#define I2C_C2_GCAEN_SHIFT                       (7U)
+#define I2C_C2_GCAEN(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_C2_GCAEN_SHIFT)) & I2C_C2_GCAEN_MASK)
+
+/*! @name FLT - I2C Programmable Input Glitch Filter register */
+#define I2C_FLT_FLT_MASK                         (0xFU)
+#define I2C_FLT_FLT_SHIFT                        (0U)
+#define I2C_FLT_FLT(x)                           (((uint8_t)(((uint8_t)(x)) << I2C_FLT_FLT_SHIFT)) & I2C_FLT_FLT_MASK)
+#define I2C_FLT_STARTF_MASK                      (0x10U)
+#define I2C_FLT_STARTF_SHIFT                     (4U)
+#define I2C_FLT_STARTF(x)                        (((uint8_t)(((uint8_t)(x)) << I2C_FLT_STARTF_SHIFT)) & I2C_FLT_STARTF_MASK)
+#define I2C_FLT_SSIE_MASK                        (0x20U)
+#define I2C_FLT_SSIE_SHIFT                       (5U)
+#define I2C_FLT_SSIE(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_FLT_SSIE_SHIFT)) & I2C_FLT_SSIE_MASK)
+#define I2C_FLT_STOPF_MASK                       (0x40U)
+#define I2C_FLT_STOPF_SHIFT                      (6U)
+#define I2C_FLT_STOPF(x)                         (((uint8_t)(((uint8_t)(x)) << I2C_FLT_STOPF_SHIFT)) & I2C_FLT_STOPF_MASK)
+#define I2C_FLT_SHEN_MASK                        (0x80U)
+#define I2C_FLT_SHEN_SHIFT                       (7U)
+#define I2C_FLT_SHEN(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_FLT_SHEN_SHIFT)) & I2C_FLT_SHEN_MASK)
+
+/*! @name RA - I2C Range Address register */
+#define I2C_RA_RAD_MASK                          (0xFEU)
+#define I2C_RA_RAD_SHIFT                         (1U)
+#define I2C_RA_RAD(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_RA_RAD_SHIFT)) & I2C_RA_RAD_MASK)
+
+/*! @name SMB - I2C SMBus Control and Status register */
+#define I2C_SMB_SHTF2IE_MASK                     (0x1U)
+#define I2C_SMB_SHTF2IE_SHIFT                    (0U)
+#define I2C_SMB_SHTF2IE(x)                       (((uint8_t)(((uint8_t)(x)) << I2C_SMB_SHTF2IE_SHIFT)) & I2C_SMB_SHTF2IE_MASK)
+#define I2C_SMB_SHTF2_MASK                       (0x2U)
+#define I2C_SMB_SHTF2_SHIFT                      (1U)
+#define I2C_SMB_SHTF2(x)                         (((uint8_t)(((uint8_t)(x)) << I2C_SMB_SHTF2_SHIFT)) & I2C_SMB_SHTF2_MASK)
+#define I2C_SMB_SHTF1_MASK                       (0x4U)
+#define I2C_SMB_SHTF1_SHIFT                      (2U)
+#define I2C_SMB_SHTF1(x)                         (((uint8_t)(((uint8_t)(x)) << I2C_SMB_SHTF1_SHIFT)) & I2C_SMB_SHTF1_MASK)
+#define I2C_SMB_SLTF_MASK                        (0x8U)
+#define I2C_SMB_SLTF_SHIFT                       (3U)
+#define I2C_SMB_SLTF(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_SMB_SLTF_SHIFT)) & I2C_SMB_SLTF_MASK)
+#define I2C_SMB_TCKSEL_MASK                      (0x10U)
+#define I2C_SMB_TCKSEL_SHIFT                     (4U)
+#define I2C_SMB_TCKSEL(x)                        (((uint8_t)(((uint8_t)(x)) << I2C_SMB_TCKSEL_SHIFT)) & I2C_SMB_TCKSEL_MASK)
+#define I2C_SMB_SIICAEN_MASK                     (0x20U)
+#define I2C_SMB_SIICAEN_SHIFT                    (5U)
+#define I2C_SMB_SIICAEN(x)                       (((uint8_t)(((uint8_t)(x)) << I2C_SMB_SIICAEN_SHIFT)) & I2C_SMB_SIICAEN_MASK)
+#define I2C_SMB_ALERTEN_MASK                     (0x40U)
+#define I2C_SMB_ALERTEN_SHIFT                    (6U)
+#define I2C_SMB_ALERTEN(x)                       (((uint8_t)(((uint8_t)(x)) << I2C_SMB_ALERTEN_SHIFT)) & I2C_SMB_ALERTEN_MASK)
+#define I2C_SMB_FACK_MASK                        (0x80U)
+#define I2C_SMB_FACK_SHIFT                       (7U)
+#define I2C_SMB_FACK(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_SMB_FACK_SHIFT)) & I2C_SMB_FACK_MASK)
+
+/*! @name A2 - I2C Address Register 2 */
+#define I2C_A2_SAD_MASK                          (0xFEU)
+#define I2C_A2_SAD_SHIFT                         (1U)
+#define I2C_A2_SAD(x)                            (((uint8_t)(((uint8_t)(x)) << I2C_A2_SAD_SHIFT)) & I2C_A2_SAD_MASK)
+
+/*! @name SLTH - I2C SCL Low Timeout Register High */
+#define I2C_SLTH_SSLT_MASK                       (0xFFU)
+#define I2C_SLTH_SSLT_SHIFT                      (0U)
+#define I2C_SLTH_SSLT(x)                         (((uint8_t)(((uint8_t)(x)) << I2C_SLTH_SSLT_SHIFT)) & I2C_SLTH_SSLT_MASK)
+
+/*! @name SLTL - I2C SCL Low Timeout Register Low */
+#define I2C_SLTL_SSLT_MASK                       (0xFFU)
+#define I2C_SLTL_SSLT_SHIFT                      (0U)
+#define I2C_SLTL_SSLT(x)                         (((uint8_t)(((uint8_t)(x)) << I2C_SLTL_SSLT_SHIFT)) & I2C_SLTL_SSLT_MASK)
+
+/*! @name S2 - I2C Status register 2 */
+#define I2C_S2_EMPTY_MASK                        (0x1U)
+#define I2C_S2_EMPTY_SHIFT                       (0U)
+#define I2C_S2_EMPTY(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_S2_EMPTY_SHIFT)) & I2C_S2_EMPTY_MASK)
+#define I2C_S2_ERROR_MASK                        (0x2U)
+#define I2C_S2_ERROR_SHIFT                       (1U)
+#define I2C_S2_ERROR(x)                          (((uint8_t)(((uint8_t)(x)) << I2C_S2_ERROR_SHIFT)) & I2C_S2_ERROR_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group I2C_Register_Masks */
+
+
+/* I2C - Peripheral instance base addresses */
+/** Peripheral I2C0 base address */
+#define I2C0_BASE                                (0x40066000u)
+/** Peripheral I2C0 base pointer */
+#define I2C0                                     ((I2C_Type *)I2C0_BASE)
+/** Array initializer of I2C peripheral base addresses */
+#define I2C_BASE_ADDRS                           { I2C0_BASE }
+/** Array initializer of I2C peripheral base pointers */
+#define I2C_BASE_PTRS                            { I2C0 }
+/** Interrupt vectors for the I2C peripheral type */
+#define I2C_IRQS                                 { I2C0_IRQn }
+
+/*!
+ * @}
+ */ /* end of group I2C_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- LLWU Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup LLWU_Peripheral_Access_Layer LLWU Peripheral Access Layer
+ * @{
+ */
+
+/** LLWU - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t PE1;                                /**< LLWU Pin Enable 1 register, offset: 0x0 */
+  __IO uint8_t PE2;                                /**< LLWU Pin Enable 2 register, offset: 0x1 */
+  __IO uint8_t ME;                                 /**< LLWU Module Enable register, offset: 0x2 */
+  __IO uint8_t F1;                                 /**< LLWU Flag 1 register, offset: 0x3 */
+  __I  uint8_t F3;                                 /**< LLWU Flag 3 register, offset: 0x4 */
+  __IO uint8_t FILT1;                              /**< LLWU Pin Filter 1 register, offset: 0x5 */
+} LLWU_Type;
+
+/* ----------------------------------------------------------------------------
+   -- LLWU Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup LLWU_Register_Masks LLWU Register Masks
+ * @{
+ */
+
+/*! @name PE1 - LLWU Pin Enable 1 register */
+#define LLWU_PE1_WUPE0_MASK                      (0x3U)
+#define LLWU_PE1_WUPE0_SHIFT                     (0U)
+#define LLWU_PE1_WUPE0(x)                        (((uint8_t)(((uint8_t)(x)) << LLWU_PE1_WUPE0_SHIFT)) & LLWU_PE1_WUPE0_MASK)
+#define LLWU_PE1_WUPE1_MASK                      (0xCU)
+#define LLWU_PE1_WUPE1_SHIFT                     (2U)
+#define LLWU_PE1_WUPE1(x)                        (((uint8_t)(((uint8_t)(x)) << LLWU_PE1_WUPE1_SHIFT)) & LLWU_PE1_WUPE1_MASK)
+#define LLWU_PE1_WUPE2_MASK                      (0x30U)
+#define LLWU_PE1_WUPE2_SHIFT                     (4U)
+#define LLWU_PE1_WUPE2(x)                        (((uint8_t)(((uint8_t)(x)) << LLWU_PE1_WUPE2_SHIFT)) & LLWU_PE1_WUPE2_MASK)
+#define LLWU_PE1_WUPE3_MASK                      (0xC0U)
+#define LLWU_PE1_WUPE3_SHIFT                     (6U)
+#define LLWU_PE1_WUPE3(x)                        (((uint8_t)(((uint8_t)(x)) << LLWU_PE1_WUPE3_SHIFT)) & LLWU_PE1_WUPE3_MASK)
+
+/*! @name PE2 - LLWU Pin Enable 2 register */
+#define LLWU_PE2_WUPE4_MASK                      (0x3U)
+#define LLWU_PE2_WUPE4_SHIFT                     (0U)
+#define LLWU_PE2_WUPE4(x)                        (((uint8_t)(((uint8_t)(x)) << LLWU_PE2_WUPE4_SHIFT)) & LLWU_PE2_WUPE4_MASK)
+#define LLWU_PE2_WUPE5_MASK                      (0xCU)
+#define LLWU_PE2_WUPE5_SHIFT                     (2U)
+#define LLWU_PE2_WUPE5(x)                        (((uint8_t)(((uint8_t)(x)) << LLWU_PE2_WUPE5_SHIFT)) & LLWU_PE2_WUPE5_MASK)
+#define LLWU_PE2_WUPE6_MASK                      (0x30U)
+#define LLWU_PE2_WUPE6_SHIFT                     (4U)
+#define LLWU_PE2_WUPE6(x)                        (((uint8_t)(((uint8_t)(x)) << LLWU_PE2_WUPE6_SHIFT)) & LLWU_PE2_WUPE6_MASK)
+#define LLWU_PE2_WUPE7_MASK                      (0xC0U)
+#define LLWU_PE2_WUPE7_SHIFT                     (6U)
+#define LLWU_PE2_WUPE7(x)                        (((uint8_t)(((uint8_t)(x)) << LLWU_PE2_WUPE7_SHIFT)) & LLWU_PE2_WUPE7_MASK)
+
+/*! @name ME - LLWU Module Enable register */
+#define LLWU_ME_WUME0_MASK                       (0x1U)
+#define LLWU_ME_WUME0_SHIFT                      (0U)
+#define LLWU_ME_WUME0(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_ME_WUME0_SHIFT)) & LLWU_ME_WUME0_MASK)
+#define LLWU_ME_WUME1_MASK                       (0x2U)
+#define LLWU_ME_WUME1_SHIFT                      (1U)
+#define LLWU_ME_WUME1(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_ME_WUME1_SHIFT)) & LLWU_ME_WUME1_MASK)
+#define LLWU_ME_WUME2_MASK                       (0x4U)
+#define LLWU_ME_WUME2_SHIFT                      (2U)
+#define LLWU_ME_WUME2(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_ME_WUME2_SHIFT)) & LLWU_ME_WUME2_MASK)
+#define LLWU_ME_WUME3_MASK                       (0x8U)
+#define LLWU_ME_WUME3_SHIFT                      (3U)
+#define LLWU_ME_WUME3(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_ME_WUME3_SHIFT)) & LLWU_ME_WUME3_MASK)
+#define LLWU_ME_WUME4_MASK                       (0x10U)
+#define LLWU_ME_WUME4_SHIFT                      (4U)
+#define LLWU_ME_WUME4(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_ME_WUME4_SHIFT)) & LLWU_ME_WUME4_MASK)
+#define LLWU_ME_WUME5_MASK                       (0x20U)
+#define LLWU_ME_WUME5_SHIFT                      (5U)
+#define LLWU_ME_WUME5(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_ME_WUME5_SHIFT)) & LLWU_ME_WUME5_MASK)
+#define LLWU_ME_WUME6_MASK                       (0x40U)
+#define LLWU_ME_WUME6_SHIFT                      (6U)
+#define LLWU_ME_WUME6(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_ME_WUME6_SHIFT)) & LLWU_ME_WUME6_MASK)
+#define LLWU_ME_WUME7_MASK                       (0x80U)
+#define LLWU_ME_WUME7_SHIFT                      (7U)
+#define LLWU_ME_WUME7(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_ME_WUME7_SHIFT)) & LLWU_ME_WUME7_MASK)
+
+/*! @name F1 - LLWU Flag 1 register */
+#define LLWU_F1_WUF0_MASK                        (0x1U)
+#define LLWU_F1_WUF0_SHIFT                       (0U)
+#define LLWU_F1_WUF0(x)                          (((uint8_t)(((uint8_t)(x)) << LLWU_F1_WUF0_SHIFT)) & LLWU_F1_WUF0_MASK)
+#define LLWU_F1_WUF1_MASK                        (0x2U)
+#define LLWU_F1_WUF1_SHIFT                       (1U)
+#define LLWU_F1_WUF1(x)                          (((uint8_t)(((uint8_t)(x)) << LLWU_F1_WUF1_SHIFT)) & LLWU_F1_WUF1_MASK)
+#define LLWU_F1_WUF2_MASK                        (0x4U)
+#define LLWU_F1_WUF2_SHIFT                       (2U)
+#define LLWU_F1_WUF2(x)                          (((uint8_t)(((uint8_t)(x)) << LLWU_F1_WUF2_SHIFT)) & LLWU_F1_WUF2_MASK)
+#define LLWU_F1_WUF3_MASK                        (0x8U)
+#define LLWU_F1_WUF3_SHIFT                       (3U)
+#define LLWU_F1_WUF3(x)                          (((uint8_t)(((uint8_t)(x)) << LLWU_F1_WUF3_SHIFT)) & LLWU_F1_WUF3_MASK)
+#define LLWU_F1_WUF4_MASK                        (0x10U)
+#define LLWU_F1_WUF4_SHIFT                       (4U)
+#define LLWU_F1_WUF4(x)                          (((uint8_t)(((uint8_t)(x)) << LLWU_F1_WUF4_SHIFT)) & LLWU_F1_WUF4_MASK)
+#define LLWU_F1_WUF5_MASK                        (0x20U)
+#define LLWU_F1_WUF5_SHIFT                       (5U)
+#define LLWU_F1_WUF5(x)                          (((uint8_t)(((uint8_t)(x)) << LLWU_F1_WUF5_SHIFT)) & LLWU_F1_WUF5_MASK)
+#define LLWU_F1_WUF6_MASK                        (0x40U)
+#define LLWU_F1_WUF6_SHIFT                       (6U)
+#define LLWU_F1_WUF6(x)                          (((uint8_t)(((uint8_t)(x)) << LLWU_F1_WUF6_SHIFT)) & LLWU_F1_WUF6_MASK)
+#define LLWU_F1_WUF7_MASK                        (0x80U)
+#define LLWU_F1_WUF7_SHIFT                       (7U)
+#define LLWU_F1_WUF7(x)                          (((uint8_t)(((uint8_t)(x)) << LLWU_F1_WUF7_SHIFT)) & LLWU_F1_WUF7_MASK)
+
+/*! @name F3 - LLWU Flag 3 register */
+#define LLWU_F3_MWUF0_MASK                       (0x1U)
+#define LLWU_F3_MWUF0_SHIFT                      (0U)
+#define LLWU_F3_MWUF0(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_F3_MWUF0_SHIFT)) & LLWU_F3_MWUF0_MASK)
+#define LLWU_F3_MWUF1_MASK                       (0x2U)
+#define LLWU_F3_MWUF1_SHIFT                      (1U)
+#define LLWU_F3_MWUF1(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_F3_MWUF1_SHIFT)) & LLWU_F3_MWUF1_MASK)
+#define LLWU_F3_MWUF2_MASK                       (0x4U)
+#define LLWU_F3_MWUF2_SHIFT                      (2U)
+#define LLWU_F3_MWUF2(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_F3_MWUF2_SHIFT)) & LLWU_F3_MWUF2_MASK)
+#define LLWU_F3_MWUF3_MASK                       (0x8U)
+#define LLWU_F3_MWUF3_SHIFT                      (3U)
+#define LLWU_F3_MWUF3(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_F3_MWUF3_SHIFT)) & LLWU_F3_MWUF3_MASK)
+#define LLWU_F3_MWUF4_MASK                       (0x10U)
+#define LLWU_F3_MWUF4_SHIFT                      (4U)
+#define LLWU_F3_MWUF4(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_F3_MWUF4_SHIFT)) & LLWU_F3_MWUF4_MASK)
+#define LLWU_F3_MWUF5_MASK                       (0x20U)
+#define LLWU_F3_MWUF5_SHIFT                      (5U)
+#define LLWU_F3_MWUF5(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_F3_MWUF5_SHIFT)) & LLWU_F3_MWUF5_MASK)
+#define LLWU_F3_MWUF6_MASK                       (0x40U)
+#define LLWU_F3_MWUF6_SHIFT                      (6U)
+#define LLWU_F3_MWUF6(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_F3_MWUF6_SHIFT)) & LLWU_F3_MWUF6_MASK)
+#define LLWU_F3_MWUF7_MASK                       (0x80U)
+#define LLWU_F3_MWUF7_SHIFT                      (7U)
+#define LLWU_F3_MWUF7(x)                         (((uint8_t)(((uint8_t)(x)) << LLWU_F3_MWUF7_SHIFT)) & LLWU_F3_MWUF7_MASK)
+
+/*! @name FILT1 - LLWU Pin Filter 1 register */
+#define LLWU_FILT1_FILTSEL_MASK                  (0xFU)
+#define LLWU_FILT1_FILTSEL_SHIFT                 (0U)
+#define LLWU_FILT1_FILTSEL(x)                    (((uint8_t)(((uint8_t)(x)) << LLWU_FILT1_FILTSEL_SHIFT)) & LLWU_FILT1_FILTSEL_MASK)
+#define LLWU_FILT1_FILTE_MASK                    (0x60U)
+#define LLWU_FILT1_FILTE_SHIFT                   (5U)
+#define LLWU_FILT1_FILTE(x)                      (((uint8_t)(((uint8_t)(x)) << LLWU_FILT1_FILTE_SHIFT)) & LLWU_FILT1_FILTE_MASK)
+#define LLWU_FILT1_FILTF_MASK                    (0x80U)
+#define LLWU_FILT1_FILTF_SHIFT                   (7U)
+#define LLWU_FILT1_FILTF(x)                      (((uint8_t)(((uint8_t)(x)) << LLWU_FILT1_FILTF_SHIFT)) & LLWU_FILT1_FILTF_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group LLWU_Register_Masks */
+
+
+/* LLWU - Peripheral instance base addresses */
+/** Peripheral LLWU base address */
+#define LLWU_BASE                                (0x4007C000u)
+/** Peripheral LLWU base pointer */
+#define LLWU                                     ((LLWU_Type *)LLWU_BASE)
+/** Array initializer of LLWU peripheral base addresses */
+#define LLWU_BASE_ADDRS                          { LLWU_BASE }
+/** Array initializer of LLWU peripheral base pointers */
+#define LLWU_BASE_PTRS                           { LLWU }
+/** Interrupt vectors for the LLWU peripheral type */
+#define LLWU_IRQS                                { LLWU_IRQn }
+
+/*!
+ * @}
+ */ /* end of group LLWU_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- LPTMR Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup LPTMR_Peripheral_Access_Layer LPTMR Peripheral Access Layer
+ * @{
+ */
+
+/** LPTMR - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t CSR;                               /**< Low Power Timer Control Status Register, offset: 0x0 */
+  __IO uint32_t PSR;                               /**< Low Power Timer Prescale Register, offset: 0x4 */
+  __IO uint32_t CMR;                               /**< Low Power Timer Compare Register, offset: 0x8 */
+  __IO uint32_t CNR;                               /**< Low Power Timer Counter Register, offset: 0xC */
+} LPTMR_Type;
+
+/* ----------------------------------------------------------------------------
+   -- LPTMR Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup LPTMR_Register_Masks LPTMR Register Masks
+ * @{
+ */
+
+/*! @name CSR - Low Power Timer Control Status Register */
+#define LPTMR_CSR_TEN_MASK                       (0x1U)
+#define LPTMR_CSR_TEN_SHIFT                      (0U)
+#define LPTMR_CSR_TEN(x)                         (((uint32_t)(((uint32_t)(x)) << LPTMR_CSR_TEN_SHIFT)) & LPTMR_CSR_TEN_MASK)
+#define LPTMR_CSR_TMS_MASK                       (0x2U)
+#define LPTMR_CSR_TMS_SHIFT                      (1U)
+#define LPTMR_CSR_TMS(x)                         (((uint32_t)(((uint32_t)(x)) << LPTMR_CSR_TMS_SHIFT)) & LPTMR_CSR_TMS_MASK)
+#define LPTMR_CSR_TFC_MASK                       (0x4U)
+#define LPTMR_CSR_TFC_SHIFT                      (2U)
+#define LPTMR_CSR_TFC(x)                         (((uint32_t)(((uint32_t)(x)) << LPTMR_CSR_TFC_SHIFT)) & LPTMR_CSR_TFC_MASK)
+#define LPTMR_CSR_TPP_MASK                       (0x8U)
+#define LPTMR_CSR_TPP_SHIFT                      (3U)
+#define LPTMR_CSR_TPP(x)                         (((uint32_t)(((uint32_t)(x)) << LPTMR_CSR_TPP_SHIFT)) & LPTMR_CSR_TPP_MASK)
+#define LPTMR_CSR_TPS_MASK                       (0x30U)
+#define LPTMR_CSR_TPS_SHIFT                      (4U)
+#define LPTMR_CSR_TPS(x)                         (((uint32_t)(((uint32_t)(x)) << LPTMR_CSR_TPS_SHIFT)) & LPTMR_CSR_TPS_MASK)
+#define LPTMR_CSR_TIE_MASK                       (0x40U)
+#define LPTMR_CSR_TIE_SHIFT                      (6U)
+#define LPTMR_CSR_TIE(x)                         (((uint32_t)(((uint32_t)(x)) << LPTMR_CSR_TIE_SHIFT)) & LPTMR_CSR_TIE_MASK)
+#define LPTMR_CSR_TCF_MASK                       (0x80U)
+#define LPTMR_CSR_TCF_SHIFT                      (7U)
+#define LPTMR_CSR_TCF(x)                         (((uint32_t)(((uint32_t)(x)) << LPTMR_CSR_TCF_SHIFT)) & LPTMR_CSR_TCF_MASK)
+
+/*! @name PSR - Low Power Timer Prescale Register */
+#define LPTMR_PSR_PCS_MASK                       (0x3U)
+#define LPTMR_PSR_PCS_SHIFT                      (0U)
+#define LPTMR_PSR_PCS(x)                         (((uint32_t)(((uint32_t)(x)) << LPTMR_PSR_PCS_SHIFT)) & LPTMR_PSR_PCS_MASK)
+#define LPTMR_PSR_PBYP_MASK                      (0x4U)
+#define LPTMR_PSR_PBYP_SHIFT                     (2U)
+#define LPTMR_PSR_PBYP(x)                        (((uint32_t)(((uint32_t)(x)) << LPTMR_PSR_PBYP_SHIFT)) & LPTMR_PSR_PBYP_MASK)
+#define LPTMR_PSR_PRESCALE_MASK                  (0x78U)
+#define LPTMR_PSR_PRESCALE_SHIFT                 (3U)
+#define LPTMR_PSR_PRESCALE(x)                    (((uint32_t)(((uint32_t)(x)) << LPTMR_PSR_PRESCALE_SHIFT)) & LPTMR_PSR_PRESCALE_MASK)
+
+/*! @name CMR - Low Power Timer Compare Register */
+#define LPTMR_CMR_COMPARE_MASK                   (0xFFFFU)
+#define LPTMR_CMR_COMPARE_SHIFT                  (0U)
+#define LPTMR_CMR_COMPARE(x)                     (((uint32_t)(((uint32_t)(x)) << LPTMR_CMR_COMPARE_SHIFT)) & LPTMR_CMR_COMPARE_MASK)
+
+/*! @name CNR - Low Power Timer Counter Register */
+#define LPTMR_CNR_COUNTER_MASK                   (0xFFFFU)
+#define LPTMR_CNR_COUNTER_SHIFT                  (0U)
+#define LPTMR_CNR_COUNTER(x)                     (((uint32_t)(((uint32_t)(x)) << LPTMR_CNR_COUNTER_SHIFT)) & LPTMR_CNR_COUNTER_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group LPTMR_Register_Masks */
+
+
+/* LPTMR - Peripheral instance base addresses */
+/** Peripheral LPTMR0 base address */
+#define LPTMR0_BASE                              (0x40040000u)
+/** Peripheral LPTMR0 base pointer */
+#define LPTMR0                                   ((LPTMR_Type *)LPTMR0_BASE)
+/** Array initializer of LPTMR peripheral base addresses */
+#define LPTMR_BASE_ADDRS                         { LPTMR0_BASE }
+/** Array initializer of LPTMR peripheral base pointers */
+#define LPTMR_BASE_PTRS                          { LPTMR0 }
+/** Interrupt vectors for the LPTMR peripheral type */
+#define LPTMR_IRQS                               { LPTMR0_IRQn }
+
+/*!
+ * @}
+ */ /* end of group LPTMR_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- LPUART Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup LPUART_Peripheral_Access_Layer LPUART Peripheral Access Layer
+ * @{
+ */
+
+/** LPUART - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t BAUD;                              /**< LPUART Baud Rate Register, offset: 0x0 */
+  __IO uint32_t STAT;                              /**< LPUART Status Register, offset: 0x4 */
+  __IO uint32_t CTRL;                              /**< LPUART Control Register, offset: 0x8 */
+  __IO uint32_t DATA;                              /**< LPUART Data Register, offset: 0xC */
+  __IO uint32_t MATCH;                             /**< LPUART Match Address Register, offset: 0x10 */
+} LPUART_Type;
+
+/* ----------------------------------------------------------------------------
+   -- LPUART Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup LPUART_Register_Masks LPUART Register Masks
+ * @{
+ */
+
+/*! @name BAUD - LPUART Baud Rate Register */
+#define LPUART_BAUD_SBR_MASK                     (0x1FFFU)
+#define LPUART_BAUD_SBR_SHIFT                    (0U)
+#define LPUART_BAUD_SBR(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_SBR_SHIFT)) & LPUART_BAUD_SBR_MASK)
+#define LPUART_BAUD_SBNS_MASK                    (0x2000U)
+#define LPUART_BAUD_SBNS_SHIFT                   (13U)
+#define LPUART_BAUD_SBNS(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_SBNS_SHIFT)) & LPUART_BAUD_SBNS_MASK)
+#define LPUART_BAUD_RXEDGIE_MASK                 (0x4000U)
+#define LPUART_BAUD_RXEDGIE_SHIFT                (14U)
+#define LPUART_BAUD_RXEDGIE(x)                   (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_RXEDGIE_SHIFT)) & LPUART_BAUD_RXEDGIE_MASK)
+#define LPUART_BAUD_LBKDIE_MASK                  (0x8000U)
+#define LPUART_BAUD_LBKDIE_SHIFT                 (15U)
+#define LPUART_BAUD_LBKDIE(x)                    (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_LBKDIE_SHIFT)) & LPUART_BAUD_LBKDIE_MASK)
+#define LPUART_BAUD_RESYNCDIS_MASK               (0x10000U)
+#define LPUART_BAUD_RESYNCDIS_SHIFT              (16U)
+#define LPUART_BAUD_RESYNCDIS(x)                 (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_RESYNCDIS_SHIFT)) & LPUART_BAUD_RESYNCDIS_MASK)
+#define LPUART_BAUD_BOTHEDGE_MASK                (0x20000U)
+#define LPUART_BAUD_BOTHEDGE_SHIFT               (17U)
+#define LPUART_BAUD_BOTHEDGE(x)                  (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_BOTHEDGE_SHIFT)) & LPUART_BAUD_BOTHEDGE_MASK)
+#define LPUART_BAUD_MATCFG_MASK                  (0xC0000U)
+#define LPUART_BAUD_MATCFG_SHIFT                 (18U)
+#define LPUART_BAUD_MATCFG(x)                    (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_MATCFG_SHIFT)) & LPUART_BAUD_MATCFG_MASK)
+#define LPUART_BAUD_OSR_MASK                     (0x1F000000U)
+#define LPUART_BAUD_OSR_SHIFT                    (24U)
+#define LPUART_BAUD_OSR(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_OSR_SHIFT)) & LPUART_BAUD_OSR_MASK)
+#define LPUART_BAUD_M10_MASK                     (0x20000000U)
+#define LPUART_BAUD_M10_SHIFT                    (29U)
+#define LPUART_BAUD_M10(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_M10_SHIFT)) & LPUART_BAUD_M10_MASK)
+#define LPUART_BAUD_MAEN2_MASK                   (0x40000000U)
+#define LPUART_BAUD_MAEN2_SHIFT                  (30U)
+#define LPUART_BAUD_MAEN2(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_MAEN2_SHIFT)) & LPUART_BAUD_MAEN2_MASK)
+#define LPUART_BAUD_MAEN1_MASK                   (0x80000000U)
+#define LPUART_BAUD_MAEN1_SHIFT                  (31U)
+#define LPUART_BAUD_MAEN1(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_BAUD_MAEN1_SHIFT)) & LPUART_BAUD_MAEN1_MASK)
+
+/*! @name STAT - LPUART Status Register */
+#define LPUART_STAT_MA2F_MASK                    (0x4000U)
+#define LPUART_STAT_MA2F_SHIFT                   (14U)
+#define LPUART_STAT_MA2F(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_MA2F_SHIFT)) & LPUART_STAT_MA2F_MASK)
+#define LPUART_STAT_MA1F_MASK                    (0x8000U)
+#define LPUART_STAT_MA1F_SHIFT                   (15U)
+#define LPUART_STAT_MA1F(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_MA1F_SHIFT)) & LPUART_STAT_MA1F_MASK)
+#define LPUART_STAT_PF_MASK                      (0x10000U)
+#define LPUART_STAT_PF_SHIFT                     (16U)
+#define LPUART_STAT_PF(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_PF_SHIFT)) & LPUART_STAT_PF_MASK)
+#define LPUART_STAT_FE_MASK                      (0x20000U)
+#define LPUART_STAT_FE_SHIFT                     (17U)
+#define LPUART_STAT_FE(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_FE_SHIFT)) & LPUART_STAT_FE_MASK)
+#define LPUART_STAT_NF_MASK                      (0x40000U)
+#define LPUART_STAT_NF_SHIFT                     (18U)
+#define LPUART_STAT_NF(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_NF_SHIFT)) & LPUART_STAT_NF_MASK)
+#define LPUART_STAT_OR_MASK                      (0x80000U)
+#define LPUART_STAT_OR_SHIFT                     (19U)
+#define LPUART_STAT_OR(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_OR_SHIFT)) & LPUART_STAT_OR_MASK)
+#define LPUART_STAT_IDLE_MASK                    (0x100000U)
+#define LPUART_STAT_IDLE_SHIFT                   (20U)
+#define LPUART_STAT_IDLE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_IDLE_SHIFT)) & LPUART_STAT_IDLE_MASK)
+#define LPUART_STAT_RDRF_MASK                    (0x200000U)
+#define LPUART_STAT_RDRF_SHIFT                   (21U)
+#define LPUART_STAT_RDRF(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_RDRF_SHIFT)) & LPUART_STAT_RDRF_MASK)
+#define LPUART_STAT_TC_MASK                      (0x400000U)
+#define LPUART_STAT_TC_SHIFT                     (22U)
+#define LPUART_STAT_TC(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_TC_SHIFT)) & LPUART_STAT_TC_MASK)
+#define LPUART_STAT_TDRE_MASK                    (0x800000U)
+#define LPUART_STAT_TDRE_SHIFT                   (23U)
+#define LPUART_STAT_TDRE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_TDRE_SHIFT)) & LPUART_STAT_TDRE_MASK)
+#define LPUART_STAT_RAF_MASK                     (0x1000000U)
+#define LPUART_STAT_RAF_SHIFT                    (24U)
+#define LPUART_STAT_RAF(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_RAF_SHIFT)) & LPUART_STAT_RAF_MASK)
+#define LPUART_STAT_LBKDE_MASK                   (0x2000000U)
+#define LPUART_STAT_LBKDE_SHIFT                  (25U)
+#define LPUART_STAT_LBKDE(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_LBKDE_SHIFT)) & LPUART_STAT_LBKDE_MASK)
+#define LPUART_STAT_BRK13_MASK                   (0x4000000U)
+#define LPUART_STAT_BRK13_SHIFT                  (26U)
+#define LPUART_STAT_BRK13(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_BRK13_SHIFT)) & LPUART_STAT_BRK13_MASK)
+#define LPUART_STAT_RWUID_MASK                   (0x8000000U)
+#define LPUART_STAT_RWUID_SHIFT                  (27U)
+#define LPUART_STAT_RWUID(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_RWUID_SHIFT)) & LPUART_STAT_RWUID_MASK)
+#define LPUART_STAT_RXINV_MASK                   (0x10000000U)
+#define LPUART_STAT_RXINV_SHIFT                  (28U)
+#define LPUART_STAT_RXINV(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_RXINV_SHIFT)) & LPUART_STAT_RXINV_MASK)
+#define LPUART_STAT_MSBF_MASK                    (0x20000000U)
+#define LPUART_STAT_MSBF_SHIFT                   (29U)
+#define LPUART_STAT_MSBF(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_MSBF_SHIFT)) & LPUART_STAT_MSBF_MASK)
+#define LPUART_STAT_RXEDGIF_MASK                 (0x40000000U)
+#define LPUART_STAT_RXEDGIF_SHIFT                (30U)
+#define LPUART_STAT_RXEDGIF(x)                   (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_RXEDGIF_SHIFT)) & LPUART_STAT_RXEDGIF_MASK)
+#define LPUART_STAT_LBKDIF_MASK                  (0x80000000U)
+#define LPUART_STAT_LBKDIF_SHIFT                 (31U)
+#define LPUART_STAT_LBKDIF(x)                    (((uint32_t)(((uint32_t)(x)) << LPUART_STAT_LBKDIF_SHIFT)) & LPUART_STAT_LBKDIF_MASK)
+
+/*! @name CTRL - LPUART Control Register */
+#define LPUART_CTRL_PT_MASK                      (0x1U)
+#define LPUART_CTRL_PT_SHIFT                     (0U)
+#define LPUART_CTRL_PT(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_PT_SHIFT)) & LPUART_CTRL_PT_MASK)
+#define LPUART_CTRL_PE_MASK                      (0x2U)
+#define LPUART_CTRL_PE_SHIFT                     (1U)
+#define LPUART_CTRL_PE(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_PE_SHIFT)) & LPUART_CTRL_PE_MASK)
+#define LPUART_CTRL_ILT_MASK                     (0x4U)
+#define LPUART_CTRL_ILT_SHIFT                    (2U)
+#define LPUART_CTRL_ILT(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_ILT_SHIFT)) & LPUART_CTRL_ILT_MASK)
+#define LPUART_CTRL_WAKE_MASK                    (0x8U)
+#define LPUART_CTRL_WAKE_SHIFT                   (3U)
+#define LPUART_CTRL_WAKE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_WAKE_SHIFT)) & LPUART_CTRL_WAKE_MASK)
+#define LPUART_CTRL_M_MASK                       (0x10U)
+#define LPUART_CTRL_M_SHIFT                      (4U)
+#define LPUART_CTRL_M(x)                         (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_M_SHIFT)) & LPUART_CTRL_M_MASK)
+#define LPUART_CTRL_RSRC_MASK                    (0x20U)
+#define LPUART_CTRL_RSRC_SHIFT                   (5U)
+#define LPUART_CTRL_RSRC(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_RSRC_SHIFT)) & LPUART_CTRL_RSRC_MASK)
+#define LPUART_CTRL_DOZEEN_MASK                  (0x40U)
+#define LPUART_CTRL_DOZEEN_SHIFT                 (6U)
+#define LPUART_CTRL_DOZEEN(x)                    (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_DOZEEN_SHIFT)) & LPUART_CTRL_DOZEEN_MASK)
+#define LPUART_CTRL_LOOPS_MASK                   (0x80U)
+#define LPUART_CTRL_LOOPS_SHIFT                  (7U)
+#define LPUART_CTRL_LOOPS(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_LOOPS_SHIFT)) & LPUART_CTRL_LOOPS_MASK)
+#define LPUART_CTRL_IDLECFG_MASK                 (0x700U)
+#define LPUART_CTRL_IDLECFG_SHIFT                (8U)
+#define LPUART_CTRL_IDLECFG(x)                   (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_IDLECFG_SHIFT)) & LPUART_CTRL_IDLECFG_MASK)
+#define LPUART_CTRL_MA2IE_MASK                   (0x4000U)
+#define LPUART_CTRL_MA2IE_SHIFT                  (14U)
+#define LPUART_CTRL_MA2IE(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_MA2IE_SHIFT)) & LPUART_CTRL_MA2IE_MASK)
+#define LPUART_CTRL_MA1IE_MASK                   (0x8000U)
+#define LPUART_CTRL_MA1IE_SHIFT                  (15U)
+#define LPUART_CTRL_MA1IE(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_MA1IE_SHIFT)) & LPUART_CTRL_MA1IE_MASK)
+#define LPUART_CTRL_SBK_MASK                     (0x10000U)
+#define LPUART_CTRL_SBK_SHIFT                    (16U)
+#define LPUART_CTRL_SBK(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_SBK_SHIFT)) & LPUART_CTRL_SBK_MASK)
+#define LPUART_CTRL_RWU_MASK                     (0x20000U)
+#define LPUART_CTRL_RWU_SHIFT                    (17U)
+#define LPUART_CTRL_RWU(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_RWU_SHIFT)) & LPUART_CTRL_RWU_MASK)
+#define LPUART_CTRL_RE_MASK                      (0x40000U)
+#define LPUART_CTRL_RE_SHIFT                     (18U)
+#define LPUART_CTRL_RE(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_RE_SHIFT)) & LPUART_CTRL_RE_MASK)
+#define LPUART_CTRL_TE_MASK                      (0x80000U)
+#define LPUART_CTRL_TE_SHIFT                     (19U)
+#define LPUART_CTRL_TE(x)                        (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_TE_SHIFT)) & LPUART_CTRL_TE_MASK)
+#define LPUART_CTRL_ILIE_MASK                    (0x100000U)
+#define LPUART_CTRL_ILIE_SHIFT                   (20U)
+#define LPUART_CTRL_ILIE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_ILIE_SHIFT)) & LPUART_CTRL_ILIE_MASK)
+#define LPUART_CTRL_RIE_MASK                     (0x200000U)
+#define LPUART_CTRL_RIE_SHIFT                    (21U)
+#define LPUART_CTRL_RIE(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_RIE_SHIFT)) & LPUART_CTRL_RIE_MASK)
+#define LPUART_CTRL_TCIE_MASK                    (0x400000U)
+#define LPUART_CTRL_TCIE_SHIFT                   (22U)
+#define LPUART_CTRL_TCIE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_TCIE_SHIFT)) & LPUART_CTRL_TCIE_MASK)
+#define LPUART_CTRL_TIE_MASK                     (0x800000U)
+#define LPUART_CTRL_TIE_SHIFT                    (23U)
+#define LPUART_CTRL_TIE(x)                       (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_TIE_SHIFT)) & LPUART_CTRL_TIE_MASK)
+#define LPUART_CTRL_PEIE_MASK                    (0x1000000U)
+#define LPUART_CTRL_PEIE_SHIFT                   (24U)
+#define LPUART_CTRL_PEIE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_PEIE_SHIFT)) & LPUART_CTRL_PEIE_MASK)
+#define LPUART_CTRL_FEIE_MASK                    (0x2000000U)
+#define LPUART_CTRL_FEIE_SHIFT                   (25U)
+#define LPUART_CTRL_FEIE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_FEIE_SHIFT)) & LPUART_CTRL_FEIE_MASK)
+#define LPUART_CTRL_NEIE_MASK                    (0x4000000U)
+#define LPUART_CTRL_NEIE_SHIFT                   (26U)
+#define LPUART_CTRL_NEIE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_NEIE_SHIFT)) & LPUART_CTRL_NEIE_MASK)
+#define LPUART_CTRL_ORIE_MASK                    (0x8000000U)
+#define LPUART_CTRL_ORIE_SHIFT                   (27U)
+#define LPUART_CTRL_ORIE(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_ORIE_SHIFT)) & LPUART_CTRL_ORIE_MASK)
+#define LPUART_CTRL_TXINV_MASK                   (0x10000000U)
+#define LPUART_CTRL_TXINV_SHIFT                  (28U)
+#define LPUART_CTRL_TXINV(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_TXINV_SHIFT)) & LPUART_CTRL_TXINV_MASK)
+#define LPUART_CTRL_TXDIR_MASK                   (0x20000000U)
+#define LPUART_CTRL_TXDIR_SHIFT                  (29U)
+#define LPUART_CTRL_TXDIR(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_TXDIR_SHIFT)) & LPUART_CTRL_TXDIR_MASK)
+#define LPUART_CTRL_R9T8_MASK                    (0x40000000U)
+#define LPUART_CTRL_R9T8_SHIFT                   (30U)
+#define LPUART_CTRL_R9T8(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_R9T8_SHIFT)) & LPUART_CTRL_R9T8_MASK)
+#define LPUART_CTRL_R8T9_MASK                    (0x80000000U)
+#define LPUART_CTRL_R8T9_SHIFT                   (31U)
+#define LPUART_CTRL_R8T9(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_CTRL_R8T9_SHIFT)) & LPUART_CTRL_R8T9_MASK)
+
+/*! @name DATA - LPUART Data Register */
+#define LPUART_DATA_R0T0_MASK                    (0x1U)
+#define LPUART_DATA_R0T0_SHIFT                   (0U)
+#define LPUART_DATA_R0T0(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R0T0_SHIFT)) & LPUART_DATA_R0T0_MASK)
+#define LPUART_DATA_R1T1_MASK                    (0x2U)
+#define LPUART_DATA_R1T1_SHIFT                   (1U)
+#define LPUART_DATA_R1T1(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R1T1_SHIFT)) & LPUART_DATA_R1T1_MASK)
+#define LPUART_DATA_R2T2_MASK                    (0x4U)
+#define LPUART_DATA_R2T2_SHIFT                   (2U)
+#define LPUART_DATA_R2T2(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R2T2_SHIFT)) & LPUART_DATA_R2T2_MASK)
+#define LPUART_DATA_R3T3_MASK                    (0x8U)
+#define LPUART_DATA_R3T3_SHIFT                   (3U)
+#define LPUART_DATA_R3T3(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R3T3_SHIFT)) & LPUART_DATA_R3T3_MASK)
+#define LPUART_DATA_R4T4_MASK                    (0x10U)
+#define LPUART_DATA_R4T4_SHIFT                   (4U)
+#define LPUART_DATA_R4T4(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R4T4_SHIFT)) & LPUART_DATA_R4T4_MASK)
+#define LPUART_DATA_R5T5_MASK                    (0x20U)
+#define LPUART_DATA_R5T5_SHIFT                   (5U)
+#define LPUART_DATA_R5T5(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R5T5_SHIFT)) & LPUART_DATA_R5T5_MASK)
+#define LPUART_DATA_R6T6_MASK                    (0x40U)
+#define LPUART_DATA_R6T6_SHIFT                   (6U)
+#define LPUART_DATA_R6T6(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R6T6_SHIFT)) & LPUART_DATA_R6T6_MASK)
+#define LPUART_DATA_R7T7_MASK                    (0x80U)
+#define LPUART_DATA_R7T7_SHIFT                   (7U)
+#define LPUART_DATA_R7T7(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R7T7_SHIFT)) & LPUART_DATA_R7T7_MASK)
+#define LPUART_DATA_R8T8_MASK                    (0x100U)
+#define LPUART_DATA_R8T8_SHIFT                   (8U)
+#define LPUART_DATA_R8T8(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R8T8_SHIFT)) & LPUART_DATA_R8T8_MASK)
+#define LPUART_DATA_R9T9_MASK                    (0x200U)
+#define LPUART_DATA_R9T9_SHIFT                   (9U)
+#define LPUART_DATA_R9T9(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_R9T9_SHIFT)) & LPUART_DATA_R9T9_MASK)
+#define LPUART_DATA_IDLINE_MASK                  (0x800U)
+#define LPUART_DATA_IDLINE_SHIFT                 (11U)
+#define LPUART_DATA_IDLINE(x)                    (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_IDLINE_SHIFT)) & LPUART_DATA_IDLINE_MASK)
+#define LPUART_DATA_RXEMPT_MASK                  (0x1000U)
+#define LPUART_DATA_RXEMPT_SHIFT                 (12U)
+#define LPUART_DATA_RXEMPT(x)                    (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_RXEMPT_SHIFT)) & LPUART_DATA_RXEMPT_MASK)
+#define LPUART_DATA_FRETSC_MASK                  (0x2000U)
+#define LPUART_DATA_FRETSC_SHIFT                 (13U)
+#define LPUART_DATA_FRETSC(x)                    (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_FRETSC_SHIFT)) & LPUART_DATA_FRETSC_MASK)
+#define LPUART_DATA_PARITYE_MASK                 (0x4000U)
+#define LPUART_DATA_PARITYE_SHIFT                (14U)
+#define LPUART_DATA_PARITYE(x)                   (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_PARITYE_SHIFT)) & LPUART_DATA_PARITYE_MASK)
+#define LPUART_DATA_NOISY_MASK                   (0x8000U)
+#define LPUART_DATA_NOISY_SHIFT                  (15U)
+#define LPUART_DATA_NOISY(x)                     (((uint32_t)(((uint32_t)(x)) << LPUART_DATA_NOISY_SHIFT)) & LPUART_DATA_NOISY_MASK)
+
+/*! @name MATCH - LPUART Match Address Register */
+#define LPUART_MATCH_MA1_MASK                    (0x3FFU)
+#define LPUART_MATCH_MA1_SHIFT                   (0U)
+#define LPUART_MATCH_MA1(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_MATCH_MA1_SHIFT)) & LPUART_MATCH_MA1_MASK)
+#define LPUART_MATCH_MA2_MASK                    (0x3FF0000U)
+#define LPUART_MATCH_MA2_SHIFT                   (16U)
+#define LPUART_MATCH_MA2(x)                      (((uint32_t)(((uint32_t)(x)) << LPUART_MATCH_MA2_SHIFT)) & LPUART_MATCH_MA2_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group LPUART_Register_Masks */
+
+
+/* LPUART - Peripheral instance base addresses */
+/** Peripheral LPUART0 base address */
+#define LPUART0_BASE                             (0x40054000u)
+/** Peripheral LPUART0 base pointer */
+#define LPUART0                                  ((LPUART_Type *)LPUART0_BASE)
+/** Array initializer of LPUART peripheral base addresses */
+#define LPUART_BASE_ADDRS                        { LPUART0_BASE }
+/** Array initializer of LPUART peripheral base pointers */
+#define LPUART_BASE_PTRS                         { LPUART0 }
+/** Interrupt vectors for the LPUART peripheral type */
+#define LPUART_RX_TX_IRQS                        { LPUART0_IRQn }
+#define LPUART_ERR_IRQS                          { LPUART0_IRQn }
+
+/*!
+ * @}
+ */ /* end of group LPUART_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- MCG Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MCG_Peripheral_Access_Layer MCG Peripheral Access Layer
+ * @{
+ */
+
+/** MCG - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t C1;                                 /**< MCG Control Register 1, offset: 0x0 */
+  __IO uint8_t C2;                                 /**< MCG Control Register 2, offset: 0x1 */
+       uint8_t RESERVED_0[4];
+  __I  uint8_t S;                                  /**< MCG Status Register, offset: 0x6 */
+       uint8_t RESERVED_1[1];
+  __IO uint8_t SC;                                 /**< MCG Status and Control Register, offset: 0x8 */
+       uint8_t RESERVED_2[15];
+  __IO uint8_t MC;                                 /**< MCG Miscellaneous Control Register, offset: 0x18 */
+} MCG_Type;
+
+/* ----------------------------------------------------------------------------
+   -- MCG Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MCG_Register_Masks MCG Register Masks
+ * @{
+ */
+
+/*! @name C1 - MCG Control Register 1 */
+#define MCG_C1_IREFSTEN_MASK                     (0x1U)
+#define MCG_C1_IREFSTEN_SHIFT                    (0U)
+#define MCG_C1_IREFSTEN(x)                       (((uint8_t)(((uint8_t)(x)) << MCG_C1_IREFSTEN_SHIFT)) & MCG_C1_IREFSTEN_MASK)
+#define MCG_C1_IRCLKEN_MASK                      (0x2U)
+#define MCG_C1_IRCLKEN_SHIFT                     (1U)
+#define MCG_C1_IRCLKEN(x)                        (((uint8_t)(((uint8_t)(x)) << MCG_C1_IRCLKEN_SHIFT)) & MCG_C1_IRCLKEN_MASK)
+#define MCG_C1_CLKS_MASK                         (0xC0U)
+#define MCG_C1_CLKS_SHIFT                        (6U)
+#define MCG_C1_CLKS(x)                           (((uint8_t)(((uint8_t)(x)) << MCG_C1_CLKS_SHIFT)) & MCG_C1_CLKS_MASK)
+
+/*! @name C2 - MCG Control Register 2 */
+#define MCG_C2_IRCS_MASK                         (0x1U)
+#define MCG_C2_IRCS_SHIFT                        (0U)
+#define MCG_C2_IRCS(x)                           (((uint8_t)(((uint8_t)(x)) << MCG_C2_IRCS_SHIFT)) & MCG_C2_IRCS_MASK)
+#define MCG_C2_EREFS0_MASK                       (0x4U)
+#define MCG_C2_EREFS0_SHIFT                      (2U)
+#define MCG_C2_EREFS0(x)                         (((uint8_t)(((uint8_t)(x)) << MCG_C2_EREFS0_SHIFT)) & MCG_C2_EREFS0_MASK)
+
+/*! @name S - MCG Status Register */
+#define MCG_S_OSCINIT0_MASK                      (0x2U)
+#define MCG_S_OSCINIT0_SHIFT                     (1U)
+#define MCG_S_OSCINIT0(x)                        (((uint8_t)(((uint8_t)(x)) << MCG_S_OSCINIT0_SHIFT)) & MCG_S_OSCINIT0_MASK)
+#define MCG_S_CLKST_MASK                         (0xCU)
+#define MCG_S_CLKST_SHIFT                        (2U)
+#define MCG_S_CLKST(x)                           (((uint8_t)(((uint8_t)(x)) << MCG_S_CLKST_SHIFT)) & MCG_S_CLKST_MASK)
+
+/*! @name SC - MCG Status and Control Register */
+#define MCG_SC_FCRDIV_MASK                       (0xEU)
+#define MCG_SC_FCRDIV_SHIFT                      (1U)
+#define MCG_SC_FCRDIV(x)                         (((uint8_t)(((uint8_t)(x)) << MCG_SC_FCRDIV_SHIFT)) & MCG_SC_FCRDIV_MASK)
+
+/*! @name MC - MCG Miscellaneous Control Register */
+#define MCG_MC_LIRC_DIV2_MASK                    (0x7U)
+#define MCG_MC_LIRC_DIV2_SHIFT                   (0U)
+#define MCG_MC_LIRC_DIV2(x)                      (((uint8_t)(((uint8_t)(x)) << MCG_MC_LIRC_DIV2_SHIFT)) & MCG_MC_LIRC_DIV2_MASK)
+#define MCG_MC_HIRCEN_MASK                       (0x80U)
+#define MCG_MC_HIRCEN_SHIFT                      (7U)
+#define MCG_MC_HIRCEN(x)                         (((uint8_t)(((uint8_t)(x)) << MCG_MC_HIRCEN_SHIFT)) & MCG_MC_HIRCEN_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group MCG_Register_Masks */
+
+
+/* MCG - Peripheral instance base addresses */
+/** Peripheral MCG base address */
+#define MCG_BASE                                 (0x40064000u)
+/** Peripheral MCG base pointer */
+#define MCG                                      ((MCG_Type *)MCG_BASE)
+/** Array initializer of MCG peripheral base addresses */
+#define MCG_BASE_ADDRS                           { MCG_BASE }
+/** Array initializer of MCG peripheral base pointers */
+#define MCG_BASE_PTRS                            { MCG }
+
+/*!
+ * @}
+ */ /* end of group MCG_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- MCM Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MCM_Peripheral_Access_Layer MCM Peripheral Access Layer
+ * @{
+ */
+
+/** MCM - Register Layout Typedef */
+typedef struct {
+       uint8_t RESERVED_0[8];
+  __I  uint16_t PLASC;                             /**< Crossbar Switch (AXBS) Slave Configuration, offset: 0x8 */
+  __I  uint16_t PLAMC;                             /**< Crossbar Switch (AXBS) Master Configuration, offset: 0xA */
+  __IO uint32_t PLACR;                             /**< Platform Control Register, offset: 0xC */
+       uint8_t RESERVED_1[48];
+  __IO uint32_t CPO;                               /**< Compute Operation Control Register, offset: 0x40 */
+} MCM_Type;
+
+/* ----------------------------------------------------------------------------
+   -- MCM Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MCM_Register_Masks MCM Register Masks
+ * @{
+ */
+
+/*! @name PLASC - Crossbar Switch (AXBS) Slave Configuration */
+#define MCM_PLASC_ASC_MASK                       (0xFFU)
+#define MCM_PLASC_ASC_SHIFT                      (0U)
+#define MCM_PLASC_ASC(x)                         (((uint16_t)(((uint16_t)(x)) << MCM_PLASC_ASC_SHIFT)) & MCM_PLASC_ASC_MASK)
+
+/*! @name PLAMC - Crossbar Switch (AXBS) Master Configuration */
+#define MCM_PLAMC_AMC_MASK                       (0xFFU)
+#define MCM_PLAMC_AMC_SHIFT                      (0U)
+#define MCM_PLAMC_AMC(x)                         (((uint16_t)(((uint16_t)(x)) << MCM_PLAMC_AMC_SHIFT)) & MCM_PLAMC_AMC_MASK)
+
+/*! @name PLACR - Platform Control Register */
+#define MCM_PLACR_EFDS_MASK                      (0x4000U)
+#define MCM_PLACR_EFDS_SHIFT                     (14U)
+#define MCM_PLACR_EFDS(x)                        (((uint32_t)(((uint32_t)(x)) << MCM_PLACR_EFDS_SHIFT)) & MCM_PLACR_EFDS_MASK)
+#define MCM_PLACR_DFCS_MASK                      (0x8000U)
+#define MCM_PLACR_DFCS_SHIFT                     (15U)
+#define MCM_PLACR_DFCS(x)                        (((uint32_t)(((uint32_t)(x)) << MCM_PLACR_DFCS_SHIFT)) & MCM_PLACR_DFCS_MASK)
+#define MCM_PLACR_ESFC_MASK                      (0x10000U)
+#define MCM_PLACR_ESFC_SHIFT                     (16U)
+#define MCM_PLACR_ESFC(x)                        (((uint32_t)(((uint32_t)(x)) << MCM_PLACR_ESFC_SHIFT)) & MCM_PLACR_ESFC_MASK)
+
+/*! @name CPO - Compute Operation Control Register */
+#define MCM_CPO_CPOREQ_MASK                      (0x1U)
+#define MCM_CPO_CPOREQ_SHIFT                     (0U)
+#define MCM_CPO_CPOREQ(x)                        (((uint32_t)(((uint32_t)(x)) << MCM_CPO_CPOREQ_SHIFT)) & MCM_CPO_CPOREQ_MASK)
+#define MCM_CPO_CPOACK_MASK                      (0x2U)
+#define MCM_CPO_CPOACK_SHIFT                     (1U)
+#define MCM_CPO_CPOACK(x)                        (((uint32_t)(((uint32_t)(x)) << MCM_CPO_CPOACK_SHIFT)) & MCM_CPO_CPOACK_MASK)
+#define MCM_CPO_CPOWOI_MASK                      (0x4U)
+#define MCM_CPO_CPOWOI_SHIFT                     (2U)
+#define MCM_CPO_CPOWOI(x)                        (((uint32_t)(((uint32_t)(x)) << MCM_CPO_CPOWOI_SHIFT)) & MCM_CPO_CPOWOI_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group MCM_Register_Masks */
+
+
+/* MCM - Peripheral instance base addresses */
+/** Peripheral MCM base address */
+#define MCM_BASE                                 (0xF0003000u)
+/** Peripheral MCM base pointer */
+#define MCM                                      ((MCM_Type *)MCM_BASE)
+/** Array initializer of MCM peripheral base addresses */
+#define MCM_BASE_ADDRS                           { MCM_BASE }
+/** Array initializer of MCM peripheral base pointers */
+#define MCM_BASE_PTRS                            { MCM }
+
+/*!
+ * @}
+ */ /* end of group MCM_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- MTB Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MTB_Peripheral_Access_Layer MTB Peripheral Access Layer
+ * @{
+ */
+
+/** MTB - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t POSITION;                          /**< MTB Position Register, offset: 0x0 */
+  __IO uint32_t MASTER;                            /**< MTB Master Register, offset: 0x4 */
+  __IO uint32_t FLOW;                              /**< MTB Flow Register, offset: 0x8 */
+  __I  uint32_t BASE;                              /**< MTB Base Register, offset: 0xC */
+       uint8_t RESERVED_0[3824];
+  __I  uint32_t MODECTRL;                          /**< Integration Mode Control Register, offset: 0xF00 */
+       uint8_t RESERVED_1[156];
+  __I  uint32_t TAGSET;                            /**< Claim TAG Set Register, offset: 0xFA0 */
+  __I  uint32_t TAGCLEAR;                          /**< Claim TAG Clear Register, offset: 0xFA4 */
+       uint8_t RESERVED_2[8];
+  __I  uint32_t LOCKACCESS;                        /**< Lock Access Register, offset: 0xFB0 */
+  __I  uint32_t LOCKSTAT;                          /**< Lock Status Register, offset: 0xFB4 */
+  __I  uint32_t AUTHSTAT;                          /**< Authentication Status Register, offset: 0xFB8 */
+  __I  uint32_t DEVICEARCH;                        /**< Device Architecture Register, offset: 0xFBC */
+       uint8_t RESERVED_3[8];
+  __I  uint32_t DEVICECFG;                         /**< Device Configuration Register, offset: 0xFC8 */
+  __I  uint32_t DEVICETYPID;                       /**< Device Type Identifier Register, offset: 0xFCC */
+  __I  uint32_t PERIPHID4;                         /**< Peripheral ID Register, offset: 0xFD0 */
+  __I  uint32_t PERIPHID5;                         /**< Peripheral ID Register, offset: 0xFD4 */
+  __I  uint32_t PERIPHID6;                         /**< Peripheral ID Register, offset: 0xFD8 */
+  __I  uint32_t PERIPHID7;                         /**< Peripheral ID Register, offset: 0xFDC */
+  __I  uint32_t PERIPHID0;                         /**< Peripheral ID Register, offset: 0xFE0 */
+  __I  uint32_t PERIPHID1;                         /**< Peripheral ID Register, offset: 0xFE4 */
+  __I  uint32_t PERIPHID2;                         /**< Peripheral ID Register, offset: 0xFE8 */
+  __I  uint32_t PERIPHID3;                         /**< Peripheral ID Register, offset: 0xFEC */
+  __I  uint32_t COMPID[4];                         /**< Component ID Register, array offset: 0xFF0, array step: 0x4 */
+} MTB_Type;
+
+/* ----------------------------------------------------------------------------
+   -- MTB Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MTB_Register_Masks MTB Register Masks
+ * @{
+ */
+
+/*! @name POSITION - MTB Position Register */
+#define MTB_POSITION_WRAP_MASK                   (0x4U)
+#define MTB_POSITION_WRAP_SHIFT                  (2U)
+#define MTB_POSITION_WRAP(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_POSITION_WRAP_SHIFT)) & MTB_POSITION_WRAP_MASK)
+#define MTB_POSITION_POINTER_MASK                (0xFFFFFFF8U)
+#define MTB_POSITION_POINTER_SHIFT               (3U)
+#define MTB_POSITION_POINTER(x)                  (((uint32_t)(((uint32_t)(x)) << MTB_POSITION_POINTER_SHIFT)) & MTB_POSITION_POINTER_MASK)
+
+/*! @name MASTER - MTB Master Register */
+#define MTB_MASTER_MASK_MASK                     (0x1FU)
+#define MTB_MASTER_MASK_SHIFT                    (0U)
+#define MTB_MASTER_MASK(x)                       (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_MASK_SHIFT)) & MTB_MASTER_MASK_MASK)
+#define MTB_MASTER_TSTARTEN_MASK                 (0x20U)
+#define MTB_MASTER_TSTARTEN_SHIFT                (5U)
+#define MTB_MASTER_TSTARTEN(x)                   (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_TSTARTEN_SHIFT)) & MTB_MASTER_TSTARTEN_MASK)
+#define MTB_MASTER_TSTOPEN_MASK                  (0x40U)
+#define MTB_MASTER_TSTOPEN_SHIFT                 (6U)
+#define MTB_MASTER_TSTOPEN(x)                    (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_TSTOPEN_SHIFT)) & MTB_MASTER_TSTOPEN_MASK)
+#define MTB_MASTER_SFRWPRIV_MASK                 (0x80U)
+#define MTB_MASTER_SFRWPRIV_SHIFT                (7U)
+#define MTB_MASTER_SFRWPRIV(x)                   (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_SFRWPRIV_SHIFT)) & MTB_MASTER_SFRWPRIV_MASK)
+#define MTB_MASTER_RAMPRIV_MASK                  (0x100U)
+#define MTB_MASTER_RAMPRIV_SHIFT                 (8U)
+#define MTB_MASTER_RAMPRIV(x)                    (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_RAMPRIV_SHIFT)) & MTB_MASTER_RAMPRIV_MASK)
+#define MTB_MASTER_HALTREQ_MASK                  (0x200U)
+#define MTB_MASTER_HALTREQ_SHIFT                 (9U)
+#define MTB_MASTER_HALTREQ(x)                    (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_HALTREQ_SHIFT)) & MTB_MASTER_HALTREQ_MASK)
+#define MTB_MASTER_EN_MASK                       (0x80000000U)
+#define MTB_MASTER_EN_SHIFT                      (31U)
+#define MTB_MASTER_EN(x)                         (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_EN_SHIFT)) & MTB_MASTER_EN_MASK)
+
+/*! @name FLOW - MTB Flow Register */
+#define MTB_FLOW_AUTOSTOP_MASK                   (0x1U)
+#define MTB_FLOW_AUTOSTOP_SHIFT                  (0U)
+#define MTB_FLOW_AUTOSTOP(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_FLOW_AUTOSTOP_SHIFT)) & MTB_FLOW_AUTOSTOP_MASK)
+#define MTB_FLOW_AUTOHALT_MASK                   (0x2U)
+#define MTB_FLOW_AUTOHALT_SHIFT                  (1U)
+#define MTB_FLOW_AUTOHALT(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_FLOW_AUTOHALT_SHIFT)) & MTB_FLOW_AUTOHALT_MASK)
+#define MTB_FLOW_WATERMARK_MASK                  (0xFFFFFFF8U)
+#define MTB_FLOW_WATERMARK_SHIFT                 (3U)
+#define MTB_FLOW_WATERMARK(x)                    (((uint32_t)(((uint32_t)(x)) << MTB_FLOW_WATERMARK_SHIFT)) & MTB_FLOW_WATERMARK_MASK)
+
+/*! @name BASE - MTB Base Register */
+#define MTB_BASE_BASEADDR_MASK                   (0xFFFFFFFFU)
+#define MTB_BASE_BASEADDR_SHIFT                  (0U)
+#define MTB_BASE_BASEADDR(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_BASE_BASEADDR_SHIFT)) & MTB_BASE_BASEADDR_MASK)
+
+/*! @name MODECTRL - Integration Mode Control Register */
+#define MTB_MODECTRL_MODECTRL_MASK               (0xFFFFFFFFU)
+#define MTB_MODECTRL_MODECTRL_SHIFT              (0U)
+#define MTB_MODECTRL_MODECTRL(x)                 (((uint32_t)(((uint32_t)(x)) << MTB_MODECTRL_MODECTRL_SHIFT)) & MTB_MODECTRL_MODECTRL_MASK)
+
+/*! @name TAGSET - Claim TAG Set Register */
+#define MTB_TAGSET_TAGSET_MASK                   (0xFFFFFFFFU)
+#define MTB_TAGSET_TAGSET_SHIFT                  (0U)
+#define MTB_TAGSET_TAGSET(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_TAGSET_TAGSET_SHIFT)) & MTB_TAGSET_TAGSET_MASK)
+
+/*! @name TAGCLEAR - Claim TAG Clear Register */
+#define MTB_TAGCLEAR_TAGCLEAR_MASK               (0xFFFFFFFFU)
+#define MTB_TAGCLEAR_TAGCLEAR_SHIFT              (0U)
+#define MTB_TAGCLEAR_TAGCLEAR(x)                 (((uint32_t)(((uint32_t)(x)) << MTB_TAGCLEAR_TAGCLEAR_SHIFT)) & MTB_TAGCLEAR_TAGCLEAR_MASK)
+
+/*! @name LOCKACCESS - Lock Access Register */
+#define MTB_LOCKACCESS_LOCKACCESS_MASK           (0xFFFFFFFFU)
+#define MTB_LOCKACCESS_LOCKACCESS_SHIFT          (0U)
+#define MTB_LOCKACCESS_LOCKACCESS(x)             (((uint32_t)(((uint32_t)(x)) << MTB_LOCKACCESS_LOCKACCESS_SHIFT)) & MTB_LOCKACCESS_LOCKACCESS_MASK)
+
+/*! @name LOCKSTAT - Lock Status Register */
+#define MTB_LOCKSTAT_LOCKSTAT_MASK               (0xFFFFFFFFU)
+#define MTB_LOCKSTAT_LOCKSTAT_SHIFT              (0U)
+#define MTB_LOCKSTAT_LOCKSTAT(x)                 (((uint32_t)(((uint32_t)(x)) << MTB_LOCKSTAT_LOCKSTAT_SHIFT)) & MTB_LOCKSTAT_LOCKSTAT_MASK)
+
+/*! @name AUTHSTAT - Authentication Status Register */
+#define MTB_AUTHSTAT_BIT0_MASK                   (0x1U)
+#define MTB_AUTHSTAT_BIT0_SHIFT                  (0U)
+#define MTB_AUTHSTAT_BIT0(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_AUTHSTAT_BIT0_SHIFT)) & MTB_AUTHSTAT_BIT0_MASK)
+#define MTB_AUTHSTAT_BIT1_MASK                   (0x2U)
+#define MTB_AUTHSTAT_BIT1_SHIFT                  (1U)
+#define MTB_AUTHSTAT_BIT1(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_AUTHSTAT_BIT1_SHIFT)) & MTB_AUTHSTAT_BIT1_MASK)
+#define MTB_AUTHSTAT_BIT2_MASK                   (0x4U)
+#define MTB_AUTHSTAT_BIT2_SHIFT                  (2U)
+#define MTB_AUTHSTAT_BIT2(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_AUTHSTAT_BIT2_SHIFT)) & MTB_AUTHSTAT_BIT2_MASK)
+#define MTB_AUTHSTAT_BIT3_MASK                   (0x8U)
+#define MTB_AUTHSTAT_BIT3_SHIFT                  (3U)
+#define MTB_AUTHSTAT_BIT3(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_AUTHSTAT_BIT3_SHIFT)) & MTB_AUTHSTAT_BIT3_MASK)
+
+/*! @name DEVICEARCH - Device Architecture Register */
+#define MTB_DEVICEARCH_DEVICEARCH_MASK           (0xFFFFFFFFU)
+#define MTB_DEVICEARCH_DEVICEARCH_SHIFT          (0U)
+#define MTB_DEVICEARCH_DEVICEARCH(x)             (((uint32_t)(((uint32_t)(x)) << MTB_DEVICEARCH_DEVICEARCH_SHIFT)) & MTB_DEVICEARCH_DEVICEARCH_MASK)
+
+/*! @name DEVICECFG - Device Configuration Register */
+#define MTB_DEVICECFG_DEVICECFG_MASK             (0xFFFFFFFFU)
+#define MTB_DEVICECFG_DEVICECFG_SHIFT            (0U)
+#define MTB_DEVICECFG_DEVICECFG(x)               (((uint32_t)(((uint32_t)(x)) << MTB_DEVICECFG_DEVICECFG_SHIFT)) & MTB_DEVICECFG_DEVICECFG_MASK)
+
+/*! @name DEVICETYPID - Device Type Identifier Register */
+#define MTB_DEVICETYPID_DEVICETYPID_MASK         (0xFFFFFFFFU)
+#define MTB_DEVICETYPID_DEVICETYPID_SHIFT        (0U)
+#define MTB_DEVICETYPID_DEVICETYPID(x)           (((uint32_t)(((uint32_t)(x)) << MTB_DEVICETYPID_DEVICETYPID_SHIFT)) & MTB_DEVICETYPID_DEVICETYPID_MASK)
+
+/*! @name PERIPHID4 - Peripheral ID Register */
+#define MTB_PERIPHID4_PERIPHID_MASK              (0xFFFFFFFFU)
+#define MTB_PERIPHID4_PERIPHID_SHIFT             (0U)
+#define MTB_PERIPHID4_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << MTB_PERIPHID4_PERIPHID_SHIFT)) & MTB_PERIPHID4_PERIPHID_MASK)
+
+/*! @name PERIPHID5 - Peripheral ID Register */
+#define MTB_PERIPHID5_PERIPHID_MASK              (0xFFFFFFFFU)
+#define MTB_PERIPHID5_PERIPHID_SHIFT             (0U)
+#define MTB_PERIPHID5_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << MTB_PERIPHID5_PERIPHID_SHIFT)) & MTB_PERIPHID5_PERIPHID_MASK)
+
+/*! @name PERIPHID6 - Peripheral ID Register */
+#define MTB_PERIPHID6_PERIPHID_MASK              (0xFFFFFFFFU)
+#define MTB_PERIPHID6_PERIPHID_SHIFT             (0U)
+#define MTB_PERIPHID6_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << MTB_PERIPHID6_PERIPHID_SHIFT)) & MTB_PERIPHID6_PERIPHID_MASK)
+
+/*! @name PERIPHID7 - Peripheral ID Register */
+#define MTB_PERIPHID7_PERIPHID_MASK              (0xFFFFFFFFU)
+#define MTB_PERIPHID7_PERIPHID_SHIFT             (0U)
+#define MTB_PERIPHID7_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << MTB_PERIPHID7_PERIPHID_SHIFT)) & MTB_PERIPHID7_PERIPHID_MASK)
+
+/*! @name PERIPHID0 - Peripheral ID Register */
+#define MTB_PERIPHID0_PERIPHID_MASK              (0xFFFFFFFFU)
+#define MTB_PERIPHID0_PERIPHID_SHIFT             (0U)
+#define MTB_PERIPHID0_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << MTB_PERIPHID0_PERIPHID_SHIFT)) & MTB_PERIPHID0_PERIPHID_MASK)
+
+/*! @name PERIPHID1 - Peripheral ID Register */
+#define MTB_PERIPHID1_PERIPHID_MASK              (0xFFFFFFFFU)
+#define MTB_PERIPHID1_PERIPHID_SHIFT             (0U)
+#define MTB_PERIPHID1_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << MTB_PERIPHID1_PERIPHID_SHIFT)) & MTB_PERIPHID1_PERIPHID_MASK)
+
+/*! @name PERIPHID2 - Peripheral ID Register */
+#define MTB_PERIPHID2_PERIPHID_MASK              (0xFFFFFFFFU)
+#define MTB_PERIPHID2_PERIPHID_SHIFT             (0U)
+#define MTB_PERIPHID2_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << MTB_PERIPHID2_PERIPHID_SHIFT)) & MTB_PERIPHID2_PERIPHID_MASK)
+
+/*! @name PERIPHID3 - Peripheral ID Register */
+#define MTB_PERIPHID3_PERIPHID_MASK              (0xFFFFFFFFU)
+#define MTB_PERIPHID3_PERIPHID_SHIFT             (0U)
+#define MTB_PERIPHID3_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << MTB_PERIPHID3_PERIPHID_SHIFT)) & MTB_PERIPHID3_PERIPHID_MASK)
+
+/*! @name COMPID - Component ID Register */
+#define MTB_COMPID_COMPID_MASK                   (0xFFFFFFFFU)
+#define MTB_COMPID_COMPID_SHIFT                  (0U)
+#define MTB_COMPID_COMPID(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_COMPID_COMPID_SHIFT)) & MTB_COMPID_COMPID_MASK)
+
+/* The count of MTB_COMPID */
+#define MTB_COMPID_COUNT                         (4U)
+
+
+/*!
+ * @}
+ */ /* end of group MTB_Register_Masks */
+
+
+/* MTB - Peripheral instance base addresses */
+/** Peripheral MTB base address */
+#define MTB_BASE                                 (0xF0000000u)
+/** Peripheral MTB base pointer */
+#define MTB                                      ((MTB_Type *)MTB_BASE)
+/** Array initializer of MTB peripheral base addresses */
+#define MTB_BASE_ADDRS                           { MTB_BASE }
+/** Array initializer of MTB peripheral base pointers */
+#define MTB_BASE_PTRS                            { MTB }
+
+/*!
+ * @}
+ */ /* end of group MTB_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- MTBDWT Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MTBDWT_Peripheral_Access_Layer MTBDWT Peripheral Access Layer
+ * @{
+ */
+
+/** MTBDWT - Register Layout Typedef */
+typedef struct {
+  __I  uint32_t CTRL;                              /**< MTB DWT Control Register, offset: 0x0 */
+       uint8_t RESERVED_0[28];
+  struct {                                         /* offset: 0x20, array step: 0x10 */
+    __IO uint32_t COMP;                              /**< MTB_DWT Comparator Register, array offset: 0x20, array step: 0x10 */
+    __IO uint32_t MASK;                              /**< MTB_DWT Comparator Mask Register, array offset: 0x24, array step: 0x10 */
+    __IO uint32_t FCT;                               /**< MTB_DWT Comparator Function Register 0..MTB_DWT Comparator Function Register 1, array offset: 0x28, array step: 0x10 */
+         uint8_t RESERVED_0[4];
+  } COMPARATOR[2];
+       uint8_t RESERVED_1[448];
+  __IO uint32_t TBCTRL;                            /**< MTB_DWT Trace Buffer Control Register, offset: 0x200 */
+       uint8_t RESERVED_2[3524];
+  __I  uint32_t DEVICECFG;                         /**< Device Configuration Register, offset: 0xFC8 */
+  __I  uint32_t DEVICETYPID;                       /**< Device Type Identifier Register, offset: 0xFCC */
+  __I  uint32_t PERIPHID4;                         /**< Peripheral ID Register, offset: 0xFD0 */
+  __I  uint32_t PERIPHID5;                         /**< Peripheral ID Register, offset: 0xFD4 */
+  __I  uint32_t PERIPHID6;                         /**< Peripheral ID Register, offset: 0xFD8 */
+  __I  uint32_t PERIPHID7;                         /**< Peripheral ID Register, offset: 0xFDC */
+  __I  uint32_t PERIPHID0;                         /**< Peripheral ID Register, offset: 0xFE0 */
+  __I  uint32_t PERIPHID1;                         /**< Peripheral ID Register, offset: 0xFE4 */
+  __I  uint32_t PERIPHID2;                         /**< Peripheral ID Register, offset: 0xFE8 */
+  __I  uint32_t PERIPHID3;                         /**< Peripheral ID Register, offset: 0xFEC */
+  __I  uint32_t COMPID[4];                         /**< Component ID Register, array offset: 0xFF0, array step: 0x4 */
+} MTBDWT_Type;
+
+/* ----------------------------------------------------------------------------
+   -- MTBDWT Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MTBDWT_Register_Masks MTBDWT Register Masks
+ * @{
+ */
+
+/*! @name CTRL - MTB DWT Control Register */
+#define MTBDWT_CTRL_DWTCFGCTRL_MASK              (0xFFFFFFFU)
+#define MTBDWT_CTRL_DWTCFGCTRL_SHIFT             (0U)
+#define MTBDWT_CTRL_DWTCFGCTRL(x)                (((uint32_t)(((uint32_t)(x)) << MTBDWT_CTRL_DWTCFGCTRL_SHIFT)) & MTBDWT_CTRL_DWTCFGCTRL_MASK)
+#define MTBDWT_CTRL_NUMCMP_MASK                  (0xF0000000U)
+#define MTBDWT_CTRL_NUMCMP_SHIFT                 (28U)
+#define MTBDWT_CTRL_NUMCMP(x)                    (((uint32_t)(((uint32_t)(x)) << MTBDWT_CTRL_NUMCMP_SHIFT)) & MTBDWT_CTRL_NUMCMP_MASK)
+
+/*! @name COMP - MTB_DWT Comparator Register */
+#define MTBDWT_COMP_COMP_MASK                    (0xFFFFFFFFU)
+#define MTBDWT_COMP_COMP_SHIFT                   (0U)
+#define MTBDWT_COMP_COMP(x)                      (((uint32_t)(((uint32_t)(x)) << MTBDWT_COMP_COMP_SHIFT)) & MTBDWT_COMP_COMP_MASK)
+
+/* The count of MTBDWT_COMP */
+#define MTBDWT_COMP_COUNT                        (2U)
+
+/*! @name MASK - MTB_DWT Comparator Mask Register */
+#define MTBDWT_MASK_MASK_MASK                    (0x1FU)
+#define MTBDWT_MASK_MASK_SHIFT                   (0U)
+#define MTBDWT_MASK_MASK(x)                      (((uint32_t)(((uint32_t)(x)) << MTBDWT_MASK_MASK_SHIFT)) & MTBDWT_MASK_MASK_MASK)
+
+/* The count of MTBDWT_MASK */
+#define MTBDWT_MASK_COUNT                        (2U)
+
+/*! @name FCT - MTB_DWT Comparator Function Register 0..MTB_DWT Comparator Function Register 1 */
+#define MTBDWT_FCT_FUNCTION_MASK                 (0xFU)
+#define MTBDWT_FCT_FUNCTION_SHIFT                (0U)
+#define MTBDWT_FCT_FUNCTION(x)                   (((uint32_t)(((uint32_t)(x)) << MTBDWT_FCT_FUNCTION_SHIFT)) & MTBDWT_FCT_FUNCTION_MASK)
+#define MTBDWT_FCT_DATAVMATCH_MASK               (0x100U)
+#define MTBDWT_FCT_DATAVMATCH_SHIFT              (8U)
+#define MTBDWT_FCT_DATAVMATCH(x)                 (((uint32_t)(((uint32_t)(x)) << MTBDWT_FCT_DATAVMATCH_SHIFT)) & MTBDWT_FCT_DATAVMATCH_MASK)
+#define MTBDWT_FCT_DATAVSIZE_MASK                (0xC00U)
+#define MTBDWT_FCT_DATAVSIZE_SHIFT               (10U)
+#define MTBDWT_FCT_DATAVSIZE(x)                  (((uint32_t)(((uint32_t)(x)) << MTBDWT_FCT_DATAVSIZE_SHIFT)) & MTBDWT_FCT_DATAVSIZE_MASK)
+#define MTBDWT_FCT_DATAVADDR0_MASK               (0xF000U)
+#define MTBDWT_FCT_DATAVADDR0_SHIFT              (12U)
+#define MTBDWT_FCT_DATAVADDR0(x)                 (((uint32_t)(((uint32_t)(x)) << MTBDWT_FCT_DATAVADDR0_SHIFT)) & MTBDWT_FCT_DATAVADDR0_MASK)
+#define MTBDWT_FCT_MATCHED_MASK                  (0x1000000U)
+#define MTBDWT_FCT_MATCHED_SHIFT                 (24U)
+#define MTBDWT_FCT_MATCHED(x)                    (((uint32_t)(((uint32_t)(x)) << MTBDWT_FCT_MATCHED_SHIFT)) & MTBDWT_FCT_MATCHED_MASK)
+
+/* The count of MTBDWT_FCT */
+#define MTBDWT_FCT_COUNT                         (2U)
+
+/*! @name TBCTRL - MTB_DWT Trace Buffer Control Register */
+#define MTBDWT_TBCTRL_ACOMP0_MASK                (0x1U)
+#define MTBDWT_TBCTRL_ACOMP0_SHIFT               (0U)
+#define MTBDWT_TBCTRL_ACOMP0(x)                  (((uint32_t)(((uint32_t)(x)) << MTBDWT_TBCTRL_ACOMP0_SHIFT)) & MTBDWT_TBCTRL_ACOMP0_MASK)
+#define MTBDWT_TBCTRL_ACOMP1_MASK                (0x2U)
+#define MTBDWT_TBCTRL_ACOMP1_SHIFT               (1U)
+#define MTBDWT_TBCTRL_ACOMP1(x)                  (((uint32_t)(((uint32_t)(x)) << MTBDWT_TBCTRL_ACOMP1_SHIFT)) & MTBDWT_TBCTRL_ACOMP1_MASK)
+#define MTBDWT_TBCTRL_NUMCOMP_MASK               (0xF0000000U)
+#define MTBDWT_TBCTRL_NUMCOMP_SHIFT              (28U)
+#define MTBDWT_TBCTRL_NUMCOMP(x)                 (((uint32_t)(((uint32_t)(x)) << MTBDWT_TBCTRL_NUMCOMP_SHIFT)) & MTBDWT_TBCTRL_NUMCOMP_MASK)
+
+/*! @name DEVICECFG - Device Configuration Register */
+#define MTBDWT_DEVICECFG_DEVICECFG_MASK          (0xFFFFFFFFU)
+#define MTBDWT_DEVICECFG_DEVICECFG_SHIFT         (0U)
+#define MTBDWT_DEVICECFG_DEVICECFG(x)            (((uint32_t)(((uint32_t)(x)) << MTBDWT_DEVICECFG_DEVICECFG_SHIFT)) & MTBDWT_DEVICECFG_DEVICECFG_MASK)
+
+/*! @name DEVICETYPID - Device Type Identifier Register */
+#define MTBDWT_DEVICETYPID_DEVICETYPID_MASK      (0xFFFFFFFFU)
+#define MTBDWT_DEVICETYPID_DEVICETYPID_SHIFT     (0U)
+#define MTBDWT_DEVICETYPID_DEVICETYPID(x)        (((uint32_t)(((uint32_t)(x)) << MTBDWT_DEVICETYPID_DEVICETYPID_SHIFT)) & MTBDWT_DEVICETYPID_DEVICETYPID_MASK)
+
+/*! @name PERIPHID4 - Peripheral ID Register */
+#define MTBDWT_PERIPHID4_PERIPHID_MASK           (0xFFFFFFFFU)
+#define MTBDWT_PERIPHID4_PERIPHID_SHIFT          (0U)
+#define MTBDWT_PERIPHID4_PERIPHID(x)             (((uint32_t)(((uint32_t)(x)) << MTBDWT_PERIPHID4_PERIPHID_SHIFT)) & MTBDWT_PERIPHID4_PERIPHID_MASK)
+
+/*! @name PERIPHID5 - Peripheral ID Register */
+#define MTBDWT_PERIPHID5_PERIPHID_MASK           (0xFFFFFFFFU)
+#define MTBDWT_PERIPHID5_PERIPHID_SHIFT          (0U)
+#define MTBDWT_PERIPHID5_PERIPHID(x)             (((uint32_t)(((uint32_t)(x)) << MTBDWT_PERIPHID5_PERIPHID_SHIFT)) & MTBDWT_PERIPHID5_PERIPHID_MASK)
+
+/*! @name PERIPHID6 - Peripheral ID Register */
+#define MTBDWT_PERIPHID6_PERIPHID_MASK           (0xFFFFFFFFU)
+#define MTBDWT_PERIPHID6_PERIPHID_SHIFT          (0U)
+#define MTBDWT_PERIPHID6_PERIPHID(x)             (((uint32_t)(((uint32_t)(x)) << MTBDWT_PERIPHID6_PERIPHID_SHIFT)) & MTBDWT_PERIPHID6_PERIPHID_MASK)
+
+/*! @name PERIPHID7 - Peripheral ID Register */
+#define MTBDWT_PERIPHID7_PERIPHID_MASK           (0xFFFFFFFFU)
+#define MTBDWT_PERIPHID7_PERIPHID_SHIFT          (0U)
+#define MTBDWT_PERIPHID7_PERIPHID(x)             (((uint32_t)(((uint32_t)(x)) << MTBDWT_PERIPHID7_PERIPHID_SHIFT)) & MTBDWT_PERIPHID7_PERIPHID_MASK)
+
+/*! @name PERIPHID0 - Peripheral ID Register */
+#define MTBDWT_PERIPHID0_PERIPHID_MASK           (0xFFFFFFFFU)
+#define MTBDWT_PERIPHID0_PERIPHID_SHIFT          (0U)
+#define MTBDWT_PERIPHID0_PERIPHID(x)             (((uint32_t)(((uint32_t)(x)) << MTBDWT_PERIPHID0_PERIPHID_SHIFT)) & MTBDWT_PERIPHID0_PERIPHID_MASK)
+
+/*! @name PERIPHID1 - Peripheral ID Register */
+#define MTBDWT_PERIPHID1_PERIPHID_MASK           (0xFFFFFFFFU)
+#define MTBDWT_PERIPHID1_PERIPHID_SHIFT          (0U)
+#define MTBDWT_PERIPHID1_PERIPHID(x)             (((uint32_t)(((uint32_t)(x)) << MTBDWT_PERIPHID1_PERIPHID_SHIFT)) & MTBDWT_PERIPHID1_PERIPHID_MASK)
+
+/*! @name PERIPHID2 - Peripheral ID Register */
+#define MTBDWT_PERIPHID2_PERIPHID_MASK           (0xFFFFFFFFU)
+#define MTBDWT_PERIPHID2_PERIPHID_SHIFT          (0U)
+#define MTBDWT_PERIPHID2_PERIPHID(x)             (((uint32_t)(((uint32_t)(x)) << MTBDWT_PERIPHID2_PERIPHID_SHIFT)) & MTBDWT_PERIPHID2_PERIPHID_MASK)
+
+/*! @name PERIPHID3 - Peripheral ID Register */
+#define MTBDWT_PERIPHID3_PERIPHID_MASK           (0xFFFFFFFFU)
+#define MTBDWT_PERIPHID3_PERIPHID_SHIFT          (0U)
+#define MTBDWT_PERIPHID3_PERIPHID(x)             (((uint32_t)(((uint32_t)(x)) << MTBDWT_PERIPHID3_PERIPHID_SHIFT)) & MTBDWT_PERIPHID3_PERIPHID_MASK)
+
+/*! @name COMPID - Component ID Register */
+#define MTBDWT_COMPID_COMPID_MASK                (0xFFFFFFFFU)
+#define MTBDWT_COMPID_COMPID_SHIFT               (0U)
+#define MTBDWT_COMPID_COMPID(x)                  (((uint32_t)(((uint32_t)(x)) << MTBDWT_COMPID_COMPID_SHIFT)) & MTBDWT_COMPID_COMPID_MASK)
+
+/* The count of MTBDWT_COMPID */
+#define MTBDWT_COMPID_COUNT                      (4U)
+
+
+/*!
+ * @}
+ */ /* end of group MTBDWT_Register_Masks */
+
+
+/* MTBDWT - Peripheral instance base addresses */
+/** Peripheral MTBDWT base address */
+#define MTBDWT_BASE                              (0xF0001000u)
+/** Peripheral MTBDWT base pointer */
+#define MTBDWT                                   ((MTBDWT_Type *)MTBDWT_BASE)
+/** Array initializer of MTBDWT peripheral base addresses */
+#define MTBDWT_BASE_ADDRS                        { MTBDWT_BASE }
+/** Array initializer of MTBDWT peripheral base pointers */
+#define MTBDWT_BASE_PTRS                         { MTBDWT }
+
+/*!
+ * @}
+ */ /* end of group MTBDWT_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- NV Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup NV_Peripheral_Access_Layer NV Peripheral Access Layer
+ * @{
+ */
+
+/** NV - Register Layout Typedef */
+typedef struct {
+  __I  uint8_t BACKKEY3;                           /**< Backdoor Comparison Key 3., offset: 0x0 */
+  __I  uint8_t BACKKEY2;                           /**< Backdoor Comparison Key 2., offset: 0x1 */
+  __I  uint8_t BACKKEY1;                           /**< Backdoor Comparison Key 1., offset: 0x2 */
+  __I  uint8_t BACKKEY0;                           /**< Backdoor Comparison Key 0., offset: 0x3 */
+  __I  uint8_t BACKKEY7;                           /**< Backdoor Comparison Key 7., offset: 0x4 */
+  __I  uint8_t BACKKEY6;                           /**< Backdoor Comparison Key 6., offset: 0x5 */
+  __I  uint8_t BACKKEY5;                           /**< Backdoor Comparison Key 5., offset: 0x6 */
+  __I  uint8_t BACKKEY4;                           /**< Backdoor Comparison Key 4., offset: 0x7 */
+  __I  uint8_t FPROT3;                             /**< Non-volatile P-Flash Protection 1 - Low Register, offset: 0x8 */
+  __I  uint8_t FPROT2;                             /**< Non-volatile P-Flash Protection 1 - High Register, offset: 0x9 */
+  __I  uint8_t FPROT1;                             /**< Non-volatile P-Flash Protection 0 - Low Register, offset: 0xA */
+  __I  uint8_t FPROT0;                             /**< Non-volatile P-Flash Protection 0 - High Register, offset: 0xB */
+  __I  uint8_t FSEC;                               /**< Non-volatile Flash Security Register, offset: 0xC */
+  __I  uint8_t FOPT;                               /**< Non-volatile Flash Option Register, offset: 0xD */
+} NV_Type;
+
+/* ----------------------------------------------------------------------------
+   -- NV Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup NV_Register_Masks NV Register Masks
+ * @{
+ */
+
+/*! @name BACKKEY3 - Backdoor Comparison Key 3. */
+#define NV_BACKKEY3_KEY_MASK                     (0xFFU)
+#define NV_BACKKEY3_KEY_SHIFT                    (0U)
+#define NV_BACKKEY3_KEY(x)                       (((uint8_t)(((uint8_t)(x)) << NV_BACKKEY3_KEY_SHIFT)) & NV_BACKKEY3_KEY_MASK)
+
+/*! @name BACKKEY2 - Backdoor Comparison Key 2. */
+#define NV_BACKKEY2_KEY_MASK                     (0xFFU)
+#define NV_BACKKEY2_KEY_SHIFT                    (0U)
+#define NV_BACKKEY2_KEY(x)                       (((uint8_t)(((uint8_t)(x)) << NV_BACKKEY2_KEY_SHIFT)) & NV_BACKKEY2_KEY_MASK)
+
+/*! @name BACKKEY1 - Backdoor Comparison Key 1. */
+#define NV_BACKKEY1_KEY_MASK                     (0xFFU)
+#define NV_BACKKEY1_KEY_SHIFT                    (0U)
+#define NV_BACKKEY1_KEY(x)                       (((uint8_t)(((uint8_t)(x)) << NV_BACKKEY1_KEY_SHIFT)) & NV_BACKKEY1_KEY_MASK)
+
+/*! @name BACKKEY0 - Backdoor Comparison Key 0. */
+#define NV_BACKKEY0_KEY_MASK                     (0xFFU)
+#define NV_BACKKEY0_KEY_SHIFT                    (0U)
+#define NV_BACKKEY0_KEY(x)                       (((uint8_t)(((uint8_t)(x)) << NV_BACKKEY0_KEY_SHIFT)) & NV_BACKKEY0_KEY_MASK)
+
+/*! @name BACKKEY7 - Backdoor Comparison Key 7. */
+#define NV_BACKKEY7_KEY_MASK                     (0xFFU)
+#define NV_BACKKEY7_KEY_SHIFT                    (0U)
+#define NV_BACKKEY7_KEY(x)                       (((uint8_t)(((uint8_t)(x)) << NV_BACKKEY7_KEY_SHIFT)) & NV_BACKKEY7_KEY_MASK)
+
+/*! @name BACKKEY6 - Backdoor Comparison Key 6. */
+#define NV_BACKKEY6_KEY_MASK                     (0xFFU)
+#define NV_BACKKEY6_KEY_SHIFT                    (0U)
+#define NV_BACKKEY6_KEY(x)                       (((uint8_t)(((uint8_t)(x)) << NV_BACKKEY6_KEY_SHIFT)) & NV_BACKKEY6_KEY_MASK)
+
+/*! @name BACKKEY5 - Backdoor Comparison Key 5. */
+#define NV_BACKKEY5_KEY_MASK                     (0xFFU)
+#define NV_BACKKEY5_KEY_SHIFT                    (0U)
+#define NV_BACKKEY5_KEY(x)                       (((uint8_t)(((uint8_t)(x)) << NV_BACKKEY5_KEY_SHIFT)) & NV_BACKKEY5_KEY_MASK)
+
+/*! @name BACKKEY4 - Backdoor Comparison Key 4. */
+#define NV_BACKKEY4_KEY_MASK                     (0xFFU)
+#define NV_BACKKEY4_KEY_SHIFT                    (0U)
+#define NV_BACKKEY4_KEY(x)                       (((uint8_t)(((uint8_t)(x)) << NV_BACKKEY4_KEY_SHIFT)) & NV_BACKKEY4_KEY_MASK)
+
+/*! @name FPROT3 - Non-volatile P-Flash Protection 1 - Low Register */
+#define NV_FPROT3_PROT_MASK                      (0xFFU)
+#define NV_FPROT3_PROT_SHIFT                     (0U)
+#define NV_FPROT3_PROT(x)                        (((uint8_t)(((uint8_t)(x)) << NV_FPROT3_PROT_SHIFT)) & NV_FPROT3_PROT_MASK)
+
+/*! @name FPROT2 - Non-volatile P-Flash Protection 1 - High Register */
+#define NV_FPROT2_PROT_MASK                      (0xFFU)
+#define NV_FPROT2_PROT_SHIFT                     (0U)
+#define NV_FPROT2_PROT(x)                        (((uint8_t)(((uint8_t)(x)) << NV_FPROT2_PROT_SHIFT)) & NV_FPROT2_PROT_MASK)
+
+/*! @name FPROT1 - Non-volatile P-Flash Protection 0 - Low Register */
+#define NV_FPROT1_PROT_MASK                      (0xFFU)
+#define NV_FPROT1_PROT_SHIFT                     (0U)
+#define NV_FPROT1_PROT(x)                        (((uint8_t)(((uint8_t)(x)) << NV_FPROT1_PROT_SHIFT)) & NV_FPROT1_PROT_MASK)
+
+/*! @name FPROT0 - Non-volatile P-Flash Protection 0 - High Register */
+#define NV_FPROT0_PROT_MASK                      (0xFFU)
+#define NV_FPROT0_PROT_SHIFT                     (0U)
+#define NV_FPROT0_PROT(x)                        (((uint8_t)(((uint8_t)(x)) << NV_FPROT0_PROT_SHIFT)) & NV_FPROT0_PROT_MASK)
+
+/*! @name FSEC - Non-volatile Flash Security Register */
+#define NV_FSEC_SEC_MASK                         (0x3U)
+#define NV_FSEC_SEC_SHIFT                        (0U)
+#define NV_FSEC_SEC(x)                           (((uint8_t)(((uint8_t)(x)) << NV_FSEC_SEC_SHIFT)) & NV_FSEC_SEC_MASK)
+#define NV_FSEC_FSLACC_MASK                      (0xCU)
+#define NV_FSEC_FSLACC_SHIFT                     (2U)
+#define NV_FSEC_FSLACC(x)                        (((uint8_t)(((uint8_t)(x)) << NV_FSEC_FSLACC_SHIFT)) & NV_FSEC_FSLACC_MASK)
+#define NV_FSEC_MEEN_MASK                        (0x30U)
+#define NV_FSEC_MEEN_SHIFT                       (4U)
+#define NV_FSEC_MEEN(x)                          (((uint8_t)(((uint8_t)(x)) << NV_FSEC_MEEN_SHIFT)) & NV_FSEC_MEEN_MASK)
+#define NV_FSEC_KEYEN_MASK                       (0xC0U)
+#define NV_FSEC_KEYEN_SHIFT                      (6U)
+#define NV_FSEC_KEYEN(x)                         (((uint8_t)(((uint8_t)(x)) << NV_FSEC_KEYEN_SHIFT)) & NV_FSEC_KEYEN_MASK)
+
+/*! @name FOPT - Non-volatile Flash Option Register */
+#define NV_FOPT_LPBOOT0_MASK                     (0x1U)
+#define NV_FOPT_LPBOOT0_SHIFT                    (0U)
+#define NV_FOPT_LPBOOT0(x)                       (((uint8_t)(((uint8_t)(x)) << NV_FOPT_LPBOOT0_SHIFT)) & NV_FOPT_LPBOOT0_MASK)
+#define NV_FOPT_BOOTPIN_OPT_MASK                 (0x2U)
+#define NV_FOPT_BOOTPIN_OPT_SHIFT                (1U)
+#define NV_FOPT_BOOTPIN_OPT(x)                   (((uint8_t)(((uint8_t)(x)) << NV_FOPT_BOOTPIN_OPT_SHIFT)) & NV_FOPT_BOOTPIN_OPT_MASK)
+#define NV_FOPT_NMI_DIS_MASK                     (0x4U)
+#define NV_FOPT_NMI_DIS_SHIFT                    (2U)
+#define NV_FOPT_NMI_DIS(x)                       (((uint8_t)(((uint8_t)(x)) << NV_FOPT_NMI_DIS_SHIFT)) & NV_FOPT_NMI_DIS_MASK)
+#define NV_FOPT_RESET_PIN_CFG_MASK               (0x8U)
+#define NV_FOPT_RESET_PIN_CFG_SHIFT              (3U)
+#define NV_FOPT_RESET_PIN_CFG(x)                 (((uint8_t)(((uint8_t)(x)) << NV_FOPT_RESET_PIN_CFG_SHIFT)) & NV_FOPT_RESET_PIN_CFG_MASK)
+#define NV_FOPT_LPBOOT1_MASK                     (0x10U)
+#define NV_FOPT_LPBOOT1_SHIFT                    (4U)
+#define NV_FOPT_LPBOOT1(x)                       (((uint8_t)(((uint8_t)(x)) << NV_FOPT_LPBOOT1_SHIFT)) & NV_FOPT_LPBOOT1_MASK)
+#define NV_FOPT_FAST_INIT_MASK                   (0x20U)
+#define NV_FOPT_FAST_INIT_SHIFT                  (5U)
+#define NV_FOPT_FAST_INIT(x)                     (((uint8_t)(((uint8_t)(x)) << NV_FOPT_FAST_INIT_SHIFT)) & NV_FOPT_FAST_INIT_MASK)
+#define NV_FOPT_BOOTSRC_SEL_MASK                 (0xC0U)
+#define NV_FOPT_BOOTSRC_SEL_SHIFT                (6U)
+#define NV_FOPT_BOOTSRC_SEL(x)                   (((uint8_t)(((uint8_t)(x)) << NV_FOPT_BOOTSRC_SEL_SHIFT)) & NV_FOPT_BOOTSRC_SEL_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group NV_Register_Masks */
+
+
+/* NV - Peripheral instance base addresses */
+/** Peripheral FTFA_FlashConfig base address */
+#define FTFA_FlashConfig_BASE                    (0x400u)
+/** Peripheral FTFA_FlashConfig base pointer */
+#define FTFA_FlashConfig                         ((NV_Type *)FTFA_FlashConfig_BASE)
+/** Array initializer of NV peripheral base addresses */
+#define NV_BASE_ADDRS                            { FTFA_FlashConfig_BASE }
+/** Array initializer of NV peripheral base pointers */
+#define NV_BASE_PTRS                             { FTFA_FlashConfig }
+
+/*!
+ * @}
+ */ /* end of group NV_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- OSC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup OSC_Peripheral_Access_Layer OSC Peripheral Access Layer
+ * @{
+ */
+
+/** OSC - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t CR;                                 /**< OSC Control Register, offset: 0x0 */
+} OSC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- OSC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup OSC_Register_Masks OSC Register Masks
+ * @{
+ */
+
+/*! @name CR - OSC Control Register */
+#define OSC_CR_SC16P_MASK                        (0x1U)
+#define OSC_CR_SC16P_SHIFT                       (0U)
+#define OSC_CR_SC16P(x)                          (((uint8_t)(((uint8_t)(x)) << OSC_CR_SC16P_SHIFT)) & OSC_CR_SC16P_MASK)
+#define OSC_CR_SC8P_MASK                         (0x2U)
+#define OSC_CR_SC8P_SHIFT                        (1U)
+#define OSC_CR_SC8P(x)                           (((uint8_t)(((uint8_t)(x)) << OSC_CR_SC8P_SHIFT)) & OSC_CR_SC8P_MASK)
+#define OSC_CR_SC4P_MASK                         (0x4U)
+#define OSC_CR_SC4P_SHIFT                        (2U)
+#define OSC_CR_SC4P(x)                           (((uint8_t)(((uint8_t)(x)) << OSC_CR_SC4P_SHIFT)) & OSC_CR_SC4P_MASK)
+#define OSC_CR_SC2P_MASK                         (0x8U)
+#define OSC_CR_SC2P_SHIFT                        (3U)
+#define OSC_CR_SC2P(x)                           (((uint8_t)(((uint8_t)(x)) << OSC_CR_SC2P_SHIFT)) & OSC_CR_SC2P_MASK)
+#define OSC_CR_EREFSTEN_MASK                     (0x20U)
+#define OSC_CR_EREFSTEN_SHIFT                    (5U)
+#define OSC_CR_EREFSTEN(x)                       (((uint8_t)(((uint8_t)(x)) << OSC_CR_EREFSTEN_SHIFT)) & OSC_CR_EREFSTEN_MASK)
+#define OSC_CR_ERCLKEN_MASK                      (0x80U)
+#define OSC_CR_ERCLKEN_SHIFT                     (7U)
+#define OSC_CR_ERCLKEN(x)                        (((uint8_t)(((uint8_t)(x)) << OSC_CR_ERCLKEN_SHIFT)) & OSC_CR_ERCLKEN_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group OSC_Register_Masks */
+
+
+/* OSC - Peripheral instance base addresses */
+/** Peripheral OSC base address */
+#define OSC_BASE                                 (0x40065000u)
+/** Peripheral OSC base pointer */
+#define OSC                                      ((OSC_Type *)OSC_BASE)
+/** Array initializer of OSC peripheral base addresses */
+#define OSC_BASE_ADDRS                           { OSC_BASE }
+/** Array initializer of OSC peripheral base pointers */
+#define OSC_BASE_PTRS                            { OSC }
+
+/*!
+ * @}
+ */ /* end of group OSC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- PMC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PMC_Peripheral_Access_Layer PMC Peripheral Access Layer
+ * @{
+ */
+
+/** PMC - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t LVDSC1;                             /**< Low Voltage Detect Status And Control 1 register, offset: 0x0 */
+  __IO uint8_t LVDSC2;                             /**< Low Voltage Detect Status And Control 2 register, offset: 0x1 */
+  __IO uint8_t REGSC;                              /**< Regulator Status And Control register, offset: 0x2 */
+} PMC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- PMC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PMC_Register_Masks PMC Register Masks
+ * @{
+ */
+
+/*! @name LVDSC1 - Low Voltage Detect Status And Control 1 register */
+#define PMC_LVDSC1_LVDV_MASK                     (0x3U)
+#define PMC_LVDSC1_LVDV_SHIFT                    (0U)
+#define PMC_LVDSC1_LVDV(x)                       (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC1_LVDV_SHIFT)) & PMC_LVDSC1_LVDV_MASK)
+#define PMC_LVDSC1_LVDRE_MASK                    (0x10U)
+#define PMC_LVDSC1_LVDRE_SHIFT                   (4U)
+#define PMC_LVDSC1_LVDRE(x)                      (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC1_LVDRE_SHIFT)) & PMC_LVDSC1_LVDRE_MASK)
+#define PMC_LVDSC1_LVDIE_MASK                    (0x20U)
+#define PMC_LVDSC1_LVDIE_SHIFT                   (5U)
+#define PMC_LVDSC1_LVDIE(x)                      (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC1_LVDIE_SHIFT)) & PMC_LVDSC1_LVDIE_MASK)
+#define PMC_LVDSC1_LVDACK_MASK                   (0x40U)
+#define PMC_LVDSC1_LVDACK_SHIFT                  (6U)
+#define PMC_LVDSC1_LVDACK(x)                     (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC1_LVDACK_SHIFT)) & PMC_LVDSC1_LVDACK_MASK)
+#define PMC_LVDSC1_LVDF_MASK                     (0x80U)
+#define PMC_LVDSC1_LVDF_SHIFT                    (7U)
+#define PMC_LVDSC1_LVDF(x)                       (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC1_LVDF_SHIFT)) & PMC_LVDSC1_LVDF_MASK)
+
+/*! @name LVDSC2 - Low Voltage Detect Status And Control 2 register */
+#define PMC_LVDSC2_LVWV_MASK                     (0x3U)
+#define PMC_LVDSC2_LVWV_SHIFT                    (0U)
+#define PMC_LVDSC2_LVWV(x)                       (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC2_LVWV_SHIFT)) & PMC_LVDSC2_LVWV_MASK)
+#define PMC_LVDSC2_LVWIE_MASK                    (0x20U)
+#define PMC_LVDSC2_LVWIE_SHIFT                   (5U)
+#define PMC_LVDSC2_LVWIE(x)                      (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC2_LVWIE_SHIFT)) & PMC_LVDSC2_LVWIE_MASK)
+#define PMC_LVDSC2_LVWACK_MASK                   (0x40U)
+#define PMC_LVDSC2_LVWACK_SHIFT                  (6U)
+#define PMC_LVDSC2_LVWACK(x)                     (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC2_LVWACK_SHIFT)) & PMC_LVDSC2_LVWACK_MASK)
+#define PMC_LVDSC2_LVWF_MASK                     (0x80U)
+#define PMC_LVDSC2_LVWF_SHIFT                    (7U)
+#define PMC_LVDSC2_LVWF(x)                       (((uint8_t)(((uint8_t)(x)) << PMC_LVDSC2_LVWF_SHIFT)) & PMC_LVDSC2_LVWF_MASK)
+
+/*! @name REGSC - Regulator Status And Control register */
+#define PMC_REGSC_BGBE_MASK                      (0x1U)
+#define PMC_REGSC_BGBE_SHIFT                     (0U)
+#define PMC_REGSC_BGBE(x)                        (((uint8_t)(((uint8_t)(x)) << PMC_REGSC_BGBE_SHIFT)) & PMC_REGSC_BGBE_MASK)
+#define PMC_REGSC_REGONS_MASK                    (0x4U)
+#define PMC_REGSC_REGONS_SHIFT                   (2U)
+#define PMC_REGSC_REGONS(x)                      (((uint8_t)(((uint8_t)(x)) << PMC_REGSC_REGONS_SHIFT)) & PMC_REGSC_REGONS_MASK)
+#define PMC_REGSC_ACKISO_MASK                    (0x8U)
+#define PMC_REGSC_ACKISO_SHIFT                   (3U)
+#define PMC_REGSC_ACKISO(x)                      (((uint8_t)(((uint8_t)(x)) << PMC_REGSC_ACKISO_SHIFT)) & PMC_REGSC_ACKISO_MASK)
+#define PMC_REGSC_BGEN_MASK                      (0x10U)
+#define PMC_REGSC_BGEN_SHIFT                     (4U)
+#define PMC_REGSC_BGEN(x)                        (((uint8_t)(((uint8_t)(x)) << PMC_REGSC_BGEN_SHIFT)) & PMC_REGSC_BGEN_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group PMC_Register_Masks */
+
+
+/* PMC - Peripheral instance base addresses */
+/** Peripheral PMC base address */
+#define PMC_BASE                                 (0x4007D000u)
+/** Peripheral PMC base pointer */
+#define PMC                                      ((PMC_Type *)PMC_BASE)
+/** Array initializer of PMC peripheral base addresses */
+#define PMC_BASE_ADDRS                           { PMC_BASE }
+/** Array initializer of PMC peripheral base pointers */
+#define PMC_BASE_PTRS                            { PMC }
+/** Interrupt vectors for the PMC peripheral type */
+#define PMC_IRQS                                 { PMC_IRQn }
+
+/*!
+ * @}
+ */ /* end of group PMC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- PORT Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PORT_Peripheral_Access_Layer PORT Peripheral Access Layer
+ * @{
+ */
+
+/** PORT - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t PCR[32];                           /**< Pin Control Register n, array offset: 0x0, array step: 0x4 */
+  __O  uint32_t GPCLR;                             /**< Global Pin Control Low Register, offset: 0x80 */
+  __O  uint32_t GPCHR;                             /**< Global Pin Control High Register, offset: 0x84 */
+       uint8_t RESERVED_0[24];
+  __IO uint32_t ISFR;                              /**< Interrupt Status Flag Register, offset: 0xA0 */
+} PORT_Type;
+
+/* ----------------------------------------------------------------------------
+   -- PORT Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PORT_Register_Masks PORT Register Masks
+ * @{
+ */
+
+/*! @name PCR - Pin Control Register n */
+#define PORT_PCR_PS_MASK                         (0x1U)
+#define PORT_PCR_PS_SHIFT                        (0U)
+#define PORT_PCR_PS(x)                           (((uint32_t)(((uint32_t)(x)) << PORT_PCR_PS_SHIFT)) & PORT_PCR_PS_MASK)
+#define PORT_PCR_PE_MASK                         (0x2U)
+#define PORT_PCR_PE_SHIFT                        (1U)
+#define PORT_PCR_PE(x)                           (((uint32_t)(((uint32_t)(x)) << PORT_PCR_PE_SHIFT)) & PORT_PCR_PE_MASK)
+#define PORT_PCR_SRE_MASK                        (0x4U)
+#define PORT_PCR_SRE_SHIFT                       (2U)
+#define PORT_PCR_SRE(x)                          (((uint32_t)(((uint32_t)(x)) << PORT_PCR_SRE_SHIFT)) & PORT_PCR_SRE_MASK)
+#define PORT_PCR_PFE_MASK                        (0x10U)
+#define PORT_PCR_PFE_SHIFT                       (4U)
+#define PORT_PCR_PFE(x)                          (((uint32_t)(((uint32_t)(x)) << PORT_PCR_PFE_SHIFT)) & PORT_PCR_PFE_MASK)
+#define PORT_PCR_DSE_MASK                        (0x40U)
+#define PORT_PCR_DSE_SHIFT                       (6U)
+#define PORT_PCR_DSE(x)                          (((uint32_t)(((uint32_t)(x)) << PORT_PCR_DSE_SHIFT)) & PORT_PCR_DSE_MASK)
+#define PORT_PCR_MUX_MASK                        (0x700U)
+#define PORT_PCR_MUX_SHIFT                       (8U)
+#define PORT_PCR_MUX(x)                          (((uint32_t)(((uint32_t)(x)) << PORT_PCR_MUX_SHIFT)) & PORT_PCR_MUX_MASK)
+#define PORT_PCR_IRQC_MASK                       (0xF0000U)
+#define PORT_PCR_IRQC_SHIFT                      (16U)
+#define PORT_PCR_IRQC(x)                         (((uint32_t)(((uint32_t)(x)) << PORT_PCR_IRQC_SHIFT)) & PORT_PCR_IRQC_MASK)
+#define PORT_PCR_ISF_MASK                        (0x1000000U)
+#define PORT_PCR_ISF_SHIFT                       (24U)
+#define PORT_PCR_ISF(x)                          (((uint32_t)(((uint32_t)(x)) << PORT_PCR_ISF_SHIFT)) & PORT_PCR_ISF_MASK)
+
+/* The count of PORT_PCR */
+#define PORT_PCR_COUNT                           (32U)
+
+/*! @name GPCLR - Global Pin Control Low Register */
+#define PORT_GPCLR_GPWD_MASK                     (0xFFFFU)
+#define PORT_GPCLR_GPWD_SHIFT                    (0U)
+#define PORT_GPCLR_GPWD(x)                       (((uint32_t)(((uint32_t)(x)) << PORT_GPCLR_GPWD_SHIFT)) & PORT_GPCLR_GPWD_MASK)
+#define PORT_GPCLR_GPWE_MASK                     (0xFFFF0000U)
+#define PORT_GPCLR_GPWE_SHIFT                    (16U)
+#define PORT_GPCLR_GPWE(x)                       (((uint32_t)(((uint32_t)(x)) << PORT_GPCLR_GPWE_SHIFT)) & PORT_GPCLR_GPWE_MASK)
+
+/*! @name GPCHR - Global Pin Control High Register */
+#define PORT_GPCHR_GPWD_MASK                     (0xFFFFU)
+#define PORT_GPCHR_GPWD_SHIFT                    (0U)
+#define PORT_GPCHR_GPWD(x)                       (((uint32_t)(((uint32_t)(x)) << PORT_GPCHR_GPWD_SHIFT)) & PORT_GPCHR_GPWD_MASK)
+#define PORT_GPCHR_GPWE_MASK                     (0xFFFF0000U)
+#define PORT_GPCHR_GPWE_SHIFT                    (16U)
+#define PORT_GPCHR_GPWE(x)                       (((uint32_t)(((uint32_t)(x)) << PORT_GPCHR_GPWE_SHIFT)) & PORT_GPCHR_GPWE_MASK)
+
+/*! @name ISFR - Interrupt Status Flag Register */
+#define PORT_ISFR_ISF_MASK                       (0xFFFFFFFFU)
+#define PORT_ISFR_ISF_SHIFT                      (0U)
+#define PORT_ISFR_ISF(x)                         (((uint32_t)(((uint32_t)(x)) << PORT_ISFR_ISF_SHIFT)) & PORT_ISFR_ISF_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group PORT_Register_Masks */
+
+
+/* PORT - Peripheral instance base addresses */
+/** Peripheral PORTA base address */
+#define PORTA_BASE                               (0x40049000u)
+/** Peripheral PORTA base pointer */
+#define PORTA                                    ((PORT_Type *)PORTA_BASE)
+/** Peripheral PORTB base address */
+#define PORTB_BASE                               (0x4004A000u)
+/** Peripheral PORTB base pointer */
+#define PORTB                                    ((PORT_Type *)PORTB_BASE)
+/** Array initializer of PORT peripheral base addresses */
+#define PORT_BASE_ADDRS                          { PORTA_BASE, PORTB_BASE }
+/** Array initializer of PORT peripheral base pointers */
+#define PORT_BASE_PTRS                           { PORTA, PORTB }
+/** Interrupt vectors for the PORT peripheral type */
+#define PORT_IRQS                                { PORTA_IRQn, PORTB_IRQn }
+
+/*!
+ * @}
+ */ /* end of group PORT_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- RCM Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup RCM_Peripheral_Access_Layer RCM Peripheral Access Layer
+ * @{
+ */
+
+/** RCM - Register Layout Typedef */
+typedef struct {
+  __I  uint8_t SRS0;                               /**< System Reset Status Register 0, offset: 0x0 */
+  __I  uint8_t SRS1;                               /**< System Reset Status Register 1, offset: 0x1 */
+       uint8_t RESERVED_0[2];
+  __IO uint8_t RPFC;                               /**< Reset Pin Filter Control register, offset: 0x4 */
+  __IO uint8_t RPFW;                               /**< Reset Pin Filter Width register, offset: 0x5 */
+  __IO uint8_t FM;                                 /**< Force Mode Register, offset: 0x6 */
+  __IO uint8_t MR;                                 /**< Mode Register, offset: 0x7 */
+  __IO uint8_t SSRS0;                              /**< Sticky System Reset Status Register 0, offset: 0x8 */
+  __IO uint8_t SSRS1;                              /**< Sticky System Reset Status Register 1, offset: 0x9 */
+} RCM_Type;
+
+/* ----------------------------------------------------------------------------
+   -- RCM Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup RCM_Register_Masks RCM Register Masks
+ * @{
+ */
+
+/*! @name SRS0 - System Reset Status Register 0 */
+#define RCM_SRS0_WAKEUP_MASK                     (0x1U)
+#define RCM_SRS0_WAKEUP_SHIFT                    (0U)
+#define RCM_SRS0_WAKEUP(x)                       (((uint8_t)(((uint8_t)(x)) << RCM_SRS0_WAKEUP_SHIFT)) & RCM_SRS0_WAKEUP_MASK)
+#define RCM_SRS0_LVD_MASK                        (0x2U)
+#define RCM_SRS0_LVD_SHIFT                       (1U)
+#define RCM_SRS0_LVD(x)                          (((uint8_t)(((uint8_t)(x)) << RCM_SRS0_LVD_SHIFT)) & RCM_SRS0_LVD_MASK)
+#define RCM_SRS0_WDOG_MASK                       (0x20U)
+#define RCM_SRS0_WDOG_SHIFT                      (5U)
+#define RCM_SRS0_WDOG(x)                         (((uint8_t)(((uint8_t)(x)) << RCM_SRS0_WDOG_SHIFT)) & RCM_SRS0_WDOG_MASK)
+#define RCM_SRS0_PIN_MASK                        (0x40U)
+#define RCM_SRS0_PIN_SHIFT                       (6U)
+#define RCM_SRS0_PIN(x)                          (((uint8_t)(((uint8_t)(x)) << RCM_SRS0_PIN_SHIFT)) & RCM_SRS0_PIN_MASK)
+#define RCM_SRS0_POR_MASK                        (0x80U)
+#define RCM_SRS0_POR_SHIFT                       (7U)
+#define RCM_SRS0_POR(x)                          (((uint8_t)(((uint8_t)(x)) << RCM_SRS0_POR_SHIFT)) & RCM_SRS0_POR_MASK)
+
+/*! @name SRS1 - System Reset Status Register 1 */
+#define RCM_SRS1_LOCKUP_MASK                     (0x2U)
+#define RCM_SRS1_LOCKUP_SHIFT                    (1U)
+#define RCM_SRS1_LOCKUP(x)                       (((uint8_t)(((uint8_t)(x)) << RCM_SRS1_LOCKUP_SHIFT)) & RCM_SRS1_LOCKUP_MASK)
+#define RCM_SRS1_SW_MASK                         (0x4U)
+#define RCM_SRS1_SW_SHIFT                        (2U)
+#define RCM_SRS1_SW(x)                           (((uint8_t)(((uint8_t)(x)) << RCM_SRS1_SW_SHIFT)) & RCM_SRS1_SW_MASK)
+#define RCM_SRS1_MDM_AP_MASK                     (0x8U)
+#define RCM_SRS1_MDM_AP_SHIFT                    (3U)
+#define RCM_SRS1_MDM_AP(x)                       (((uint8_t)(((uint8_t)(x)) << RCM_SRS1_MDM_AP_SHIFT)) & RCM_SRS1_MDM_AP_MASK)
+#define RCM_SRS1_SACKERR_MASK                    (0x20U)
+#define RCM_SRS1_SACKERR_SHIFT                   (5U)
+#define RCM_SRS1_SACKERR(x)                      (((uint8_t)(((uint8_t)(x)) << RCM_SRS1_SACKERR_SHIFT)) & RCM_SRS1_SACKERR_MASK)
+
+/*! @name RPFC - Reset Pin Filter Control register */
+#define RCM_RPFC_RSTFLTSRW_MASK                  (0x3U)
+#define RCM_RPFC_RSTFLTSRW_SHIFT                 (0U)
+#define RCM_RPFC_RSTFLTSRW(x)                    (((uint8_t)(((uint8_t)(x)) << RCM_RPFC_RSTFLTSRW_SHIFT)) & RCM_RPFC_RSTFLTSRW_MASK)
+#define RCM_RPFC_RSTFLTSS_MASK                   (0x4U)
+#define RCM_RPFC_RSTFLTSS_SHIFT                  (2U)
+#define RCM_RPFC_RSTFLTSS(x)                     (((uint8_t)(((uint8_t)(x)) << RCM_RPFC_RSTFLTSS_SHIFT)) & RCM_RPFC_RSTFLTSS_MASK)
+
+/*! @name RPFW - Reset Pin Filter Width register */
+#define RCM_RPFW_RSTFLTSEL_MASK                  (0x1FU)
+#define RCM_RPFW_RSTFLTSEL_SHIFT                 (0U)
+#define RCM_RPFW_RSTFLTSEL(x)                    (((uint8_t)(((uint8_t)(x)) << RCM_RPFW_RSTFLTSEL_SHIFT)) & RCM_RPFW_RSTFLTSEL_MASK)
+
+/*! @name FM - Force Mode Register */
+#define RCM_FM_FORCEROM_MASK                     (0x6U)
+#define RCM_FM_FORCEROM_SHIFT                    (1U)
+#define RCM_FM_FORCEROM(x)                       (((uint8_t)(((uint8_t)(x)) << RCM_FM_FORCEROM_SHIFT)) & RCM_FM_FORCEROM_MASK)
+
+/*! @name MR - Mode Register */
+#define RCM_MR_BOOTROM_MASK                      (0x6U)
+#define RCM_MR_BOOTROM_SHIFT                     (1U)
+#define RCM_MR_BOOTROM(x)                        (((uint8_t)(((uint8_t)(x)) << RCM_MR_BOOTROM_SHIFT)) & RCM_MR_BOOTROM_MASK)
+
+/*! @name SSRS0 - Sticky System Reset Status Register 0 */
+#define RCM_SSRS0_SWAKEUP_MASK                   (0x1U)
+#define RCM_SSRS0_SWAKEUP_SHIFT                  (0U)
+#define RCM_SSRS0_SWAKEUP(x)                     (((uint8_t)(((uint8_t)(x)) << RCM_SSRS0_SWAKEUP_SHIFT)) & RCM_SSRS0_SWAKEUP_MASK)
+#define RCM_SSRS0_SLVD_MASK                      (0x2U)
+#define RCM_SSRS0_SLVD_SHIFT                     (1U)
+#define RCM_SSRS0_SLVD(x)                        (((uint8_t)(((uint8_t)(x)) << RCM_SSRS0_SLVD_SHIFT)) & RCM_SSRS0_SLVD_MASK)
+#define RCM_SSRS0_SWDOG_MASK                     (0x20U)
+#define RCM_SSRS0_SWDOG_SHIFT                    (5U)
+#define RCM_SSRS0_SWDOG(x)                       (((uint8_t)(((uint8_t)(x)) << RCM_SSRS0_SWDOG_SHIFT)) & RCM_SSRS0_SWDOG_MASK)
+#define RCM_SSRS0_SPIN_MASK                      (0x40U)
+#define RCM_SSRS0_SPIN_SHIFT                     (6U)
+#define RCM_SSRS0_SPIN(x)                        (((uint8_t)(((uint8_t)(x)) << RCM_SSRS0_SPIN_SHIFT)) & RCM_SSRS0_SPIN_MASK)
+#define RCM_SSRS0_SPOR_MASK                      (0x80U)
+#define RCM_SSRS0_SPOR_SHIFT                     (7U)
+#define RCM_SSRS0_SPOR(x)                        (((uint8_t)(((uint8_t)(x)) << RCM_SSRS0_SPOR_SHIFT)) & RCM_SSRS0_SPOR_MASK)
+
+/*! @name SSRS1 - Sticky System Reset Status Register 1 */
+#define RCM_SSRS1_SLOCKUP_MASK                   (0x2U)
+#define RCM_SSRS1_SLOCKUP_SHIFT                  (1U)
+#define RCM_SSRS1_SLOCKUP(x)                     (((uint8_t)(((uint8_t)(x)) << RCM_SSRS1_SLOCKUP_SHIFT)) & RCM_SSRS1_SLOCKUP_MASK)
+#define RCM_SSRS1_SSW_MASK                       (0x4U)
+#define RCM_SSRS1_SSW_SHIFT                      (2U)
+#define RCM_SSRS1_SSW(x)                         (((uint8_t)(((uint8_t)(x)) << RCM_SSRS1_SSW_SHIFT)) & RCM_SSRS1_SSW_MASK)
+#define RCM_SSRS1_SMDM_AP_MASK                   (0x8U)
+#define RCM_SSRS1_SMDM_AP_SHIFT                  (3U)
+#define RCM_SSRS1_SMDM_AP(x)                     (((uint8_t)(((uint8_t)(x)) << RCM_SSRS1_SMDM_AP_SHIFT)) & RCM_SSRS1_SMDM_AP_MASK)
+#define RCM_SSRS1_SSACKERR_MASK                  (0x20U)
+#define RCM_SSRS1_SSACKERR_SHIFT                 (5U)
+#define RCM_SSRS1_SSACKERR(x)                    (((uint8_t)(((uint8_t)(x)) << RCM_SSRS1_SSACKERR_SHIFT)) & RCM_SSRS1_SSACKERR_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group RCM_Register_Masks */
+
+
+/* RCM - Peripheral instance base addresses */
+/** Peripheral RCM base address */
+#define RCM_BASE                                 (0x4007F000u)
+/** Peripheral RCM base pointer */
+#define RCM                                      ((RCM_Type *)RCM_BASE)
+/** Array initializer of RCM peripheral base addresses */
+#define RCM_BASE_ADDRS                           { RCM_BASE }
+/** Array initializer of RCM peripheral base pointers */
+#define RCM_BASE_PTRS                            { RCM }
+
+/*!
+ * @}
+ */ /* end of group RCM_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- RFSYS Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup RFSYS_Peripheral_Access_Layer RFSYS Peripheral Access Layer
+ * @{
+ */
+
+/** RFSYS - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t REG[4];                            /**< Register file register, array offset: 0x0, array step: 0x4 */
+} RFSYS_Type;
+
+/* ----------------------------------------------------------------------------
+   -- RFSYS Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup RFSYS_Register_Masks RFSYS Register Masks
+ * @{
+ */
+
+/*! @name REG - Register file register */
+#define RFSYS_REG_LL_MASK                        (0xFFU)
+#define RFSYS_REG_LL_SHIFT                       (0U)
+#define RFSYS_REG_LL(x)                          (((uint32_t)(((uint32_t)(x)) << RFSYS_REG_LL_SHIFT)) & RFSYS_REG_LL_MASK)
+#define RFSYS_REG_LH_MASK                        (0xFF00U)
+#define RFSYS_REG_LH_SHIFT                       (8U)
+#define RFSYS_REG_LH(x)                          (((uint32_t)(((uint32_t)(x)) << RFSYS_REG_LH_SHIFT)) & RFSYS_REG_LH_MASK)
+#define RFSYS_REG_HL_MASK                        (0xFF0000U)
+#define RFSYS_REG_HL_SHIFT                       (16U)
+#define RFSYS_REG_HL(x)                          (((uint32_t)(((uint32_t)(x)) << RFSYS_REG_HL_SHIFT)) & RFSYS_REG_HL_MASK)
+#define RFSYS_REG_HH_MASK                        (0xFF000000U)
+#define RFSYS_REG_HH_SHIFT                       (24U)
+#define RFSYS_REG_HH(x)                          (((uint32_t)(((uint32_t)(x)) << RFSYS_REG_HH_SHIFT)) & RFSYS_REG_HH_MASK)
+
+/* The count of RFSYS_REG */
+#define RFSYS_REG_COUNT                          (4U)
+
+
+/*!
+ * @}
+ */ /* end of group RFSYS_Register_Masks */
+
+
+/* RFSYS - Peripheral instance base addresses */
+/** Peripheral RFSYS base address */
+#define RFSYS_BASE                               (0x40041000u)
+/** Peripheral RFSYS base pointer */
+#define RFSYS                                    ((RFSYS_Type *)RFSYS_BASE)
+/** Array initializer of RFSYS peripheral base addresses */
+#define RFSYS_BASE_ADDRS                         { RFSYS_BASE }
+/** Array initializer of RFSYS peripheral base pointers */
+#define RFSYS_BASE_PTRS                          { RFSYS }
+
+/*!
+ * @}
+ */ /* end of group RFSYS_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- ROM Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ROM_Peripheral_Access_Layer ROM Peripheral Access Layer
+ * @{
+ */
+
+/** ROM - Register Layout Typedef */
+typedef struct {
+  __I  uint32_t ENTRY[3];                          /**< Entry, array offset: 0x0, array step: 0x4 */
+  __I  uint32_t TABLEMARK;                         /**< End of Table Marker Register, offset: 0xC */
+       uint8_t RESERVED_0[4028];
+  __I  uint32_t SYSACCESS;                         /**< System Access Register, offset: 0xFCC */
+  __I  uint32_t PERIPHID4;                         /**< Peripheral ID Register, offset: 0xFD0 */
+  __I  uint32_t PERIPHID5;                         /**< Peripheral ID Register, offset: 0xFD4 */
+  __I  uint32_t PERIPHID6;                         /**< Peripheral ID Register, offset: 0xFD8 */
+  __I  uint32_t PERIPHID7;                         /**< Peripheral ID Register, offset: 0xFDC */
+  __I  uint32_t PERIPHID0;                         /**< Peripheral ID Register, offset: 0xFE0 */
+  __I  uint32_t PERIPHID1;                         /**< Peripheral ID Register, offset: 0xFE4 */
+  __I  uint32_t PERIPHID2;                         /**< Peripheral ID Register, offset: 0xFE8 */
+  __I  uint32_t PERIPHID3;                         /**< Peripheral ID Register, offset: 0xFEC */
+  __I  uint32_t COMPID[4];                         /**< Component ID Register, array offset: 0xFF0, array step: 0x4 */
+} ROM_Type;
+
+/* ----------------------------------------------------------------------------
+   -- ROM Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ROM_Register_Masks ROM Register Masks
+ * @{
+ */
+
+/*! @name ENTRY - Entry */
+#define ROM_ENTRY_ENTRY_MASK                     (0xFFFFFFFFU)
+#define ROM_ENTRY_ENTRY_SHIFT                    (0U)
+#define ROM_ENTRY_ENTRY(x)                       (((uint32_t)(((uint32_t)(x)) << ROM_ENTRY_ENTRY_SHIFT)) & ROM_ENTRY_ENTRY_MASK)
+
+/* The count of ROM_ENTRY */
+#define ROM_ENTRY_COUNT                          (3U)
+
+/*! @name TABLEMARK - End of Table Marker Register */
+#define ROM_TABLEMARK_MARK_MASK                  (0xFFFFFFFFU)
+#define ROM_TABLEMARK_MARK_SHIFT                 (0U)
+#define ROM_TABLEMARK_MARK(x)                    (((uint32_t)(((uint32_t)(x)) << ROM_TABLEMARK_MARK_SHIFT)) & ROM_TABLEMARK_MARK_MASK)
+
+/*! @name SYSACCESS - System Access Register */
+#define ROM_SYSACCESS_SYSACCESS_MASK             (0xFFFFFFFFU)
+#define ROM_SYSACCESS_SYSACCESS_SHIFT            (0U)
+#define ROM_SYSACCESS_SYSACCESS(x)               (((uint32_t)(((uint32_t)(x)) << ROM_SYSACCESS_SYSACCESS_SHIFT)) & ROM_SYSACCESS_SYSACCESS_MASK)
+
+/*! @name PERIPHID4 - Peripheral ID Register */
+#define ROM_PERIPHID4_PERIPHID_MASK              (0xFFFFFFFFU)
+#define ROM_PERIPHID4_PERIPHID_SHIFT             (0U)
+#define ROM_PERIPHID4_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << ROM_PERIPHID4_PERIPHID_SHIFT)) & ROM_PERIPHID4_PERIPHID_MASK)
+
+/*! @name PERIPHID5 - Peripheral ID Register */
+#define ROM_PERIPHID5_PERIPHID_MASK              (0xFFFFFFFFU)
+#define ROM_PERIPHID5_PERIPHID_SHIFT             (0U)
+#define ROM_PERIPHID5_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << ROM_PERIPHID5_PERIPHID_SHIFT)) & ROM_PERIPHID5_PERIPHID_MASK)
+
+/*! @name PERIPHID6 - Peripheral ID Register */
+#define ROM_PERIPHID6_PERIPHID_MASK              (0xFFFFFFFFU)
+#define ROM_PERIPHID6_PERIPHID_SHIFT             (0U)
+#define ROM_PERIPHID6_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << ROM_PERIPHID6_PERIPHID_SHIFT)) & ROM_PERIPHID6_PERIPHID_MASK)
+
+/*! @name PERIPHID7 - Peripheral ID Register */
+#define ROM_PERIPHID7_PERIPHID_MASK              (0xFFFFFFFFU)
+#define ROM_PERIPHID7_PERIPHID_SHIFT             (0U)
+#define ROM_PERIPHID7_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << ROM_PERIPHID7_PERIPHID_SHIFT)) & ROM_PERIPHID7_PERIPHID_MASK)
+
+/*! @name PERIPHID0 - Peripheral ID Register */
+#define ROM_PERIPHID0_PERIPHID_MASK              (0xFFFFFFFFU)
+#define ROM_PERIPHID0_PERIPHID_SHIFT             (0U)
+#define ROM_PERIPHID0_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << ROM_PERIPHID0_PERIPHID_SHIFT)) & ROM_PERIPHID0_PERIPHID_MASK)
+
+/*! @name PERIPHID1 - Peripheral ID Register */
+#define ROM_PERIPHID1_PERIPHID_MASK              (0xFFFFFFFFU)
+#define ROM_PERIPHID1_PERIPHID_SHIFT             (0U)
+#define ROM_PERIPHID1_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << ROM_PERIPHID1_PERIPHID_SHIFT)) & ROM_PERIPHID1_PERIPHID_MASK)
+
+/*! @name PERIPHID2 - Peripheral ID Register */
+#define ROM_PERIPHID2_PERIPHID_MASK              (0xFFFFFFFFU)
+#define ROM_PERIPHID2_PERIPHID_SHIFT             (0U)
+#define ROM_PERIPHID2_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << ROM_PERIPHID2_PERIPHID_SHIFT)) & ROM_PERIPHID2_PERIPHID_MASK)
+
+/*! @name PERIPHID3 - Peripheral ID Register */
+#define ROM_PERIPHID3_PERIPHID_MASK              (0xFFFFFFFFU)
+#define ROM_PERIPHID3_PERIPHID_SHIFT             (0U)
+#define ROM_PERIPHID3_PERIPHID(x)                (((uint32_t)(((uint32_t)(x)) << ROM_PERIPHID3_PERIPHID_SHIFT)) & ROM_PERIPHID3_PERIPHID_MASK)
+
+/*! @name COMPID - Component ID Register */
+#define ROM_COMPID_COMPID_MASK                   (0xFFFFFFFFU)
+#define ROM_COMPID_COMPID_SHIFT                  (0U)
+#define ROM_COMPID_COMPID(x)                     (((uint32_t)(((uint32_t)(x)) << ROM_COMPID_COMPID_SHIFT)) & ROM_COMPID_COMPID_MASK)
+
+/* The count of ROM_COMPID */
+#define ROM_COMPID_COUNT                         (4U)
+
+
+/*!
+ * @}
+ */ /* end of group ROM_Register_Masks */
+
+
+/* ROM - Peripheral instance base addresses */
+/** Peripheral ROM base address */
+#define ROM_BASE                                 (0xF0002000u)
+/** Peripheral ROM base pointer */
+#define ROM                                      ((ROM_Type *)ROM_BASE)
+/** Array initializer of ROM peripheral base addresses */
+#define ROM_BASE_ADDRS                           { ROM_BASE }
+/** Array initializer of ROM peripheral base pointers */
+#define ROM_BASE_PTRS                            { ROM }
+
+/*!
+ * @}
+ */ /* end of group ROM_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- RTC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup RTC_Peripheral_Access_Layer RTC Peripheral Access Layer
+ * @{
+ */
+
+/** RTC - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t TSR;                               /**< RTC Time Seconds Register, offset: 0x0 */
+  __IO uint32_t TPR;                               /**< RTC Time Prescaler Register, offset: 0x4 */
+  __IO uint32_t TAR;                               /**< RTC Time Alarm Register, offset: 0x8 */
+  __IO uint32_t TCR;                               /**< RTC Time Compensation Register, offset: 0xC */
+  __IO uint32_t CR;                                /**< RTC Control Register, offset: 0x10 */
+  __IO uint32_t SR;                                /**< RTC Status Register, offset: 0x14 */
+  __IO uint32_t LR;                                /**< RTC Lock Register, offset: 0x18 */
+  __IO uint32_t IER;                               /**< RTC Interrupt Enable Register, offset: 0x1C */
+} RTC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- RTC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup RTC_Register_Masks RTC Register Masks
+ * @{
+ */
+
+/*! @name TSR - RTC Time Seconds Register */
+#define RTC_TSR_TSR_MASK                         (0xFFFFFFFFU)
+#define RTC_TSR_TSR_SHIFT                        (0U)
+#define RTC_TSR_TSR(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_TSR_TSR_SHIFT)) & RTC_TSR_TSR_MASK)
+
+/*! @name TPR - RTC Time Prescaler Register */
+#define RTC_TPR_TPR_MASK                         (0xFFFFU)
+#define RTC_TPR_TPR_SHIFT                        (0U)
+#define RTC_TPR_TPR(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_TPR_TPR_SHIFT)) & RTC_TPR_TPR_MASK)
+
+/*! @name TAR - RTC Time Alarm Register */
+#define RTC_TAR_TAR_MASK                         (0xFFFFFFFFU)
+#define RTC_TAR_TAR_SHIFT                        (0U)
+#define RTC_TAR_TAR(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_TAR_TAR_SHIFT)) & RTC_TAR_TAR_MASK)
+
+/*! @name TCR - RTC Time Compensation Register */
+#define RTC_TCR_TCR_MASK                         (0xFFU)
+#define RTC_TCR_TCR_SHIFT                        (0U)
+#define RTC_TCR_TCR(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_TCR_TCR_SHIFT)) & RTC_TCR_TCR_MASK)
+#define RTC_TCR_CIR_MASK                         (0xFF00U)
+#define RTC_TCR_CIR_SHIFT                        (8U)
+#define RTC_TCR_CIR(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_TCR_CIR_SHIFT)) & RTC_TCR_CIR_MASK)
+#define RTC_TCR_TCV_MASK                         (0xFF0000U)
+#define RTC_TCR_TCV_SHIFT                        (16U)
+#define RTC_TCR_TCV(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_TCR_TCV_SHIFT)) & RTC_TCR_TCV_MASK)
+#define RTC_TCR_CIC_MASK                         (0xFF000000U)
+#define RTC_TCR_CIC_SHIFT                        (24U)
+#define RTC_TCR_CIC(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_TCR_CIC_SHIFT)) & RTC_TCR_CIC_MASK)
+
+/*! @name CR - RTC Control Register */
+#define RTC_CR_SWR_MASK                          (0x1U)
+#define RTC_CR_SWR_SHIFT                         (0U)
+#define RTC_CR_SWR(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_CR_SWR_SHIFT)) & RTC_CR_SWR_MASK)
+#define RTC_CR_WPE_MASK                          (0x2U)
+#define RTC_CR_WPE_SHIFT                         (1U)
+#define RTC_CR_WPE(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_CR_WPE_SHIFT)) & RTC_CR_WPE_MASK)
+#define RTC_CR_SUP_MASK                          (0x4U)
+#define RTC_CR_SUP_SHIFT                         (2U)
+#define RTC_CR_SUP(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_CR_SUP_SHIFT)) & RTC_CR_SUP_MASK)
+#define RTC_CR_UM_MASK                           (0x8U)
+#define RTC_CR_UM_SHIFT                          (3U)
+#define RTC_CR_UM(x)                             (((uint32_t)(((uint32_t)(x)) << RTC_CR_UM_SHIFT)) & RTC_CR_UM_MASK)
+#define RTC_CR_WPS_MASK                          (0x10U)
+#define RTC_CR_WPS_SHIFT                         (4U)
+#define RTC_CR_WPS(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_CR_WPS_SHIFT)) & RTC_CR_WPS_MASK)
+#define RTC_CR_OSCE_MASK                         (0x100U)
+#define RTC_CR_OSCE_SHIFT                        (8U)
+#define RTC_CR_OSCE(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_CR_OSCE_SHIFT)) & RTC_CR_OSCE_MASK)
+#define RTC_CR_CLKO_MASK                         (0x200U)
+#define RTC_CR_CLKO_SHIFT                        (9U)
+#define RTC_CR_CLKO(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_CR_CLKO_SHIFT)) & RTC_CR_CLKO_MASK)
+#define RTC_CR_SC16P_MASK                        (0x400U)
+#define RTC_CR_SC16P_SHIFT                       (10U)
+#define RTC_CR_SC16P(x)                          (((uint32_t)(((uint32_t)(x)) << RTC_CR_SC16P_SHIFT)) & RTC_CR_SC16P_MASK)
+#define RTC_CR_SC8P_MASK                         (0x800U)
+#define RTC_CR_SC8P_SHIFT                        (11U)
+#define RTC_CR_SC8P(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_CR_SC8P_SHIFT)) & RTC_CR_SC8P_MASK)
+#define RTC_CR_SC4P_MASK                         (0x1000U)
+#define RTC_CR_SC4P_SHIFT                        (12U)
+#define RTC_CR_SC4P(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_CR_SC4P_SHIFT)) & RTC_CR_SC4P_MASK)
+#define RTC_CR_SC2P_MASK                         (0x2000U)
+#define RTC_CR_SC2P_SHIFT                        (13U)
+#define RTC_CR_SC2P(x)                           (((uint32_t)(((uint32_t)(x)) << RTC_CR_SC2P_SHIFT)) & RTC_CR_SC2P_MASK)
+
+/*! @name SR - RTC Status Register */
+#define RTC_SR_TIF_MASK                          (0x1U)
+#define RTC_SR_TIF_SHIFT                         (0U)
+#define RTC_SR_TIF(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_SR_TIF_SHIFT)) & RTC_SR_TIF_MASK)
+#define RTC_SR_TOF_MASK                          (0x2U)
+#define RTC_SR_TOF_SHIFT                         (1U)
+#define RTC_SR_TOF(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_SR_TOF_SHIFT)) & RTC_SR_TOF_MASK)
+#define RTC_SR_TAF_MASK                          (0x4U)
+#define RTC_SR_TAF_SHIFT                         (2U)
+#define RTC_SR_TAF(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_SR_TAF_SHIFT)) & RTC_SR_TAF_MASK)
+#define RTC_SR_TCE_MASK                          (0x10U)
+#define RTC_SR_TCE_SHIFT                         (4U)
+#define RTC_SR_TCE(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_SR_TCE_SHIFT)) & RTC_SR_TCE_MASK)
+
+/*! @name LR - RTC Lock Register */
+#define RTC_LR_TCL_MASK                          (0x8U)
+#define RTC_LR_TCL_SHIFT                         (3U)
+#define RTC_LR_TCL(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_LR_TCL_SHIFT)) & RTC_LR_TCL_MASK)
+#define RTC_LR_CRL_MASK                          (0x10U)
+#define RTC_LR_CRL_SHIFT                         (4U)
+#define RTC_LR_CRL(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_LR_CRL_SHIFT)) & RTC_LR_CRL_MASK)
+#define RTC_LR_SRL_MASK                          (0x20U)
+#define RTC_LR_SRL_SHIFT                         (5U)
+#define RTC_LR_SRL(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_LR_SRL_SHIFT)) & RTC_LR_SRL_MASK)
+#define RTC_LR_LRL_MASK                          (0x40U)
+#define RTC_LR_LRL_SHIFT                         (6U)
+#define RTC_LR_LRL(x)                            (((uint32_t)(((uint32_t)(x)) << RTC_LR_LRL_SHIFT)) & RTC_LR_LRL_MASK)
+
+/*! @name IER - RTC Interrupt Enable Register */
+#define RTC_IER_TIIE_MASK                        (0x1U)
+#define RTC_IER_TIIE_SHIFT                       (0U)
+#define RTC_IER_TIIE(x)                          (((uint32_t)(((uint32_t)(x)) << RTC_IER_TIIE_SHIFT)) & RTC_IER_TIIE_MASK)
+#define RTC_IER_TOIE_MASK                        (0x2U)
+#define RTC_IER_TOIE_SHIFT                       (1U)
+#define RTC_IER_TOIE(x)                          (((uint32_t)(((uint32_t)(x)) << RTC_IER_TOIE_SHIFT)) & RTC_IER_TOIE_MASK)
+#define RTC_IER_TAIE_MASK                        (0x4U)
+#define RTC_IER_TAIE_SHIFT                       (2U)
+#define RTC_IER_TAIE(x)                          (((uint32_t)(((uint32_t)(x)) << RTC_IER_TAIE_SHIFT)) & RTC_IER_TAIE_MASK)
+#define RTC_IER_TSIE_MASK                        (0x10U)
+#define RTC_IER_TSIE_SHIFT                       (4U)
+#define RTC_IER_TSIE(x)                          (((uint32_t)(((uint32_t)(x)) << RTC_IER_TSIE_SHIFT)) & RTC_IER_TSIE_MASK)
+#define RTC_IER_WPON_MASK                        (0x80U)
+#define RTC_IER_WPON_SHIFT                       (7U)
+#define RTC_IER_WPON(x)                          (((uint32_t)(((uint32_t)(x)) << RTC_IER_WPON_SHIFT)) & RTC_IER_WPON_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group RTC_Register_Masks */
+
+
+/* RTC - Peripheral instance base addresses */
+/** Peripheral RTC base address */
+#define RTC_BASE                                 (0x4003D000u)
+/** Peripheral RTC base pointer */
+#define RTC                                      ((RTC_Type *)RTC_BASE)
+/** Array initializer of RTC peripheral base addresses */
+#define RTC_BASE_ADDRS                           { RTC_BASE }
+/** Array initializer of RTC peripheral base pointers */
+#define RTC_BASE_PTRS                            { RTC }
+/** Interrupt vectors for the RTC peripheral type */
+#define RTC_IRQS                                 { RTC_IRQn }
+#define RTC_SECONDS_IRQS                         { RTC_Seconds_IRQn }
+
+/*!
+ * @}
+ */ /* end of group RTC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- SIM Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SIM_Peripheral_Access_Layer SIM Peripheral Access Layer
+ * @{
+ */
+
+/** SIM - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t SOPT1;                             /**< System Options Register 1, offset: 0x0 */
+       uint8_t RESERVED_0[4096];
+  __IO uint32_t SOPT2;                             /**< System Options Register 2, offset: 0x1004 */
+       uint8_t RESERVED_1[4];
+  __IO uint32_t SOPT4;                             /**< System Options Register 4, offset: 0x100C */
+  __IO uint32_t SOPT5;                             /**< System Options Register 5, offset: 0x1010 */
+       uint8_t RESERVED_2[4];
+  __IO uint32_t SOPT7;                             /**< System Options Register 7, offset: 0x1018 */
+       uint8_t RESERVED_3[8];
+  __I  uint32_t SDID;                              /**< System Device Identification Register, offset: 0x1024 */
+       uint8_t RESERVED_4[12];
+  __IO uint32_t SCGC4;                             /**< System Clock Gating Control Register 4, offset: 0x1034 */
+  __IO uint32_t SCGC5;                             /**< System Clock Gating Control Register 5, offset: 0x1038 */
+  __IO uint32_t SCGC6;                             /**< System Clock Gating Control Register 6, offset: 0x103C */
+       uint8_t RESERVED_5[4];
+  __IO uint32_t CLKDIV1;                           /**< System Clock Divider Register 1, offset: 0x1044 */
+       uint8_t RESERVED_6[4];
+  __IO uint32_t FCFG1;                             /**< Flash Configuration Register 1, offset: 0x104C */
+  __I  uint32_t FCFG2;                             /**< Flash Configuration Register 2, offset: 0x1050 */
+       uint8_t RESERVED_7[4];
+  __I  uint32_t UIDMH;                             /**< Unique Identification Register Mid-High, offset: 0x1058 */
+  __I  uint32_t UIDML;                             /**< Unique Identification Register Mid Low, offset: 0x105C */
+  __I  uint32_t UIDL;                              /**< Unique Identification Register Low, offset: 0x1060 */
+       uint8_t RESERVED_8[156];
+  __IO uint32_t COPC;                              /**< COP Control Register, offset: 0x1100 */
+  __O  uint32_t SRVCOP;                            /**< Service COP, offset: 0x1104 */
+} SIM_Type;
+
+/* ----------------------------------------------------------------------------
+   -- SIM Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SIM_Register_Masks SIM Register Masks
+ * @{
+ */
+
+/*! @name SOPT1 - System Options Register 1 */
+#define SIM_SOPT1_OSC32KOUT_MASK                 (0x30000U)
+#define SIM_SOPT1_OSC32KOUT_SHIFT                (16U)
+#define SIM_SOPT1_OSC32KOUT(x)                   (((uint32_t)(((uint32_t)(x)) << SIM_SOPT1_OSC32KOUT_SHIFT)) & SIM_SOPT1_OSC32KOUT_MASK)
+#define SIM_SOPT1_OSC32KSEL_MASK                 (0xC0000U)
+#define SIM_SOPT1_OSC32KSEL_SHIFT                (18U)
+#define SIM_SOPT1_OSC32KSEL(x)                   (((uint32_t)(((uint32_t)(x)) << SIM_SOPT1_OSC32KSEL_SHIFT)) & SIM_SOPT1_OSC32KSEL_MASK)
+
+/*! @name SOPT2 - System Options Register 2 */
+#define SIM_SOPT2_RTCCLKOUTSEL_MASK              (0x10U)
+#define SIM_SOPT2_RTCCLKOUTSEL_SHIFT             (4U)
+#define SIM_SOPT2_RTCCLKOUTSEL(x)                (((uint32_t)(((uint32_t)(x)) << SIM_SOPT2_RTCCLKOUTSEL_SHIFT)) & SIM_SOPT2_RTCCLKOUTSEL_MASK)
+#define SIM_SOPT2_CLKOUTSEL_MASK                 (0xE0U)
+#define SIM_SOPT2_CLKOUTSEL_SHIFT                (5U)
+#define SIM_SOPT2_CLKOUTSEL(x)                   (((uint32_t)(((uint32_t)(x)) << SIM_SOPT2_CLKOUTSEL_SHIFT)) & SIM_SOPT2_CLKOUTSEL_MASK)
+#define SIM_SOPT2_TPMSRC_MASK                    (0x3000000U)
+#define SIM_SOPT2_TPMSRC_SHIFT                   (24U)
+#define SIM_SOPT2_TPMSRC(x)                      (((uint32_t)(((uint32_t)(x)) << SIM_SOPT2_TPMSRC_SHIFT)) & SIM_SOPT2_TPMSRC_MASK)
+#define SIM_SOPT2_LPUART0SRC_MASK                (0xC000000U)
+#define SIM_SOPT2_LPUART0SRC_SHIFT               (26U)
+#define SIM_SOPT2_LPUART0SRC(x)                  (((uint32_t)(((uint32_t)(x)) << SIM_SOPT2_LPUART0SRC_SHIFT)) & SIM_SOPT2_LPUART0SRC_MASK)
+
+/*! @name SOPT4 - System Options Register 4 */
+#define SIM_SOPT4_TPM1CH0SRC_MASK                (0x40000U)
+#define SIM_SOPT4_TPM1CH0SRC_SHIFT               (18U)
+#define SIM_SOPT4_TPM1CH0SRC(x)                  (((uint32_t)(((uint32_t)(x)) << SIM_SOPT4_TPM1CH0SRC_SHIFT)) & SIM_SOPT4_TPM1CH0SRC_MASK)
+#define SIM_SOPT4_TPM0CLKSEL_MASK                (0x1000000U)
+#define SIM_SOPT4_TPM0CLKSEL_SHIFT               (24U)
+#define SIM_SOPT4_TPM0CLKSEL(x)                  (((uint32_t)(((uint32_t)(x)) << SIM_SOPT4_TPM0CLKSEL_SHIFT)) & SIM_SOPT4_TPM0CLKSEL_MASK)
+#define SIM_SOPT4_TPM1CLKSEL_MASK                (0x2000000U)
+#define SIM_SOPT4_TPM1CLKSEL_SHIFT               (25U)
+#define SIM_SOPT4_TPM1CLKSEL(x)                  (((uint32_t)(((uint32_t)(x)) << SIM_SOPT4_TPM1CLKSEL_SHIFT)) & SIM_SOPT4_TPM1CLKSEL_MASK)
+
+/*! @name SOPT5 - System Options Register 5 */
+#define SIM_SOPT5_LPUART0TXSRC_MASK              (0x1U)
+#define SIM_SOPT5_LPUART0TXSRC_SHIFT             (0U)
+#define SIM_SOPT5_LPUART0TXSRC(x)                (((uint32_t)(((uint32_t)(x)) << SIM_SOPT5_LPUART0TXSRC_SHIFT)) & SIM_SOPT5_LPUART0TXSRC_MASK)
+#define SIM_SOPT5_LPUART0RXSRC_MASK              (0x4U)
+#define SIM_SOPT5_LPUART0RXSRC_SHIFT             (2U)
+#define SIM_SOPT5_LPUART0RXSRC(x)                (((uint32_t)(((uint32_t)(x)) << SIM_SOPT5_LPUART0RXSRC_SHIFT)) & SIM_SOPT5_LPUART0RXSRC_MASK)
+#define SIM_SOPT5_LPUART0ODE_MASK                (0x10000U)
+#define SIM_SOPT5_LPUART0ODE_SHIFT               (16U)
+#define SIM_SOPT5_LPUART0ODE(x)                  (((uint32_t)(((uint32_t)(x)) << SIM_SOPT5_LPUART0ODE_SHIFT)) & SIM_SOPT5_LPUART0ODE_MASK)
+
+/*! @name SOPT7 - System Options Register 7 */
+#define SIM_SOPT7_ADC0TRGSEL_MASK                (0xFU)
+#define SIM_SOPT7_ADC0TRGSEL_SHIFT               (0U)
+#define SIM_SOPT7_ADC0TRGSEL(x)                  (((uint32_t)(((uint32_t)(x)) << SIM_SOPT7_ADC0TRGSEL_SHIFT)) & SIM_SOPT7_ADC0TRGSEL_MASK)
+#define SIM_SOPT7_ADC0PRETRGSEL_MASK             (0x10U)
+#define SIM_SOPT7_ADC0PRETRGSEL_SHIFT            (4U)
+#define SIM_SOPT7_ADC0PRETRGSEL(x)               (((uint32_t)(((uint32_t)(x)) << SIM_SOPT7_ADC0PRETRGSEL_SHIFT)) & SIM_SOPT7_ADC0PRETRGSEL_MASK)
+#define SIM_SOPT7_ADC0ALTTRGEN_MASK              (0x80U)
+#define SIM_SOPT7_ADC0ALTTRGEN_SHIFT             (7U)
+#define SIM_SOPT7_ADC0ALTTRGEN(x)                (((uint32_t)(((uint32_t)(x)) << SIM_SOPT7_ADC0ALTTRGEN_SHIFT)) & SIM_SOPT7_ADC0ALTTRGEN_MASK)
+
+/*! @name SDID - System Device Identification Register */
+#define SIM_SDID_PINID_MASK                      (0xFU)
+#define SIM_SDID_PINID_SHIFT                     (0U)
+#define SIM_SDID_PINID(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SDID_PINID_SHIFT)) & SIM_SDID_PINID_MASK)
+#define SIM_SDID_DIEID_MASK                      (0xF80U)
+#define SIM_SDID_DIEID_SHIFT                     (7U)
+#define SIM_SDID_DIEID(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SDID_DIEID_SHIFT)) & SIM_SDID_DIEID_MASK)
+#define SIM_SDID_REVID_MASK                      (0xF000U)
+#define SIM_SDID_REVID_SHIFT                     (12U)
+#define SIM_SDID_REVID(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SDID_REVID_SHIFT)) & SIM_SDID_REVID_MASK)
+#define SIM_SDID_SRAMSIZE_MASK                   (0xF0000U)
+#define SIM_SDID_SRAMSIZE_SHIFT                  (16U)
+#define SIM_SDID_SRAMSIZE(x)                     (((uint32_t)(((uint32_t)(x)) << SIM_SDID_SRAMSIZE_SHIFT)) & SIM_SDID_SRAMSIZE_MASK)
+#define SIM_SDID_SERIESID_MASK                   (0xF00000U)
+#define SIM_SDID_SERIESID_SHIFT                  (20U)
+#define SIM_SDID_SERIESID(x)                     (((uint32_t)(((uint32_t)(x)) << SIM_SDID_SERIESID_SHIFT)) & SIM_SDID_SERIESID_MASK)
+#define SIM_SDID_SUBFAMID_MASK                   (0xF000000U)
+#define SIM_SDID_SUBFAMID_SHIFT                  (24U)
+#define SIM_SDID_SUBFAMID(x)                     (((uint32_t)(((uint32_t)(x)) << SIM_SDID_SUBFAMID_SHIFT)) & SIM_SDID_SUBFAMID_MASK)
+#define SIM_SDID_FAMID_MASK                      (0xF0000000U)
+#define SIM_SDID_FAMID_SHIFT                     (28U)
+#define SIM_SDID_FAMID(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SDID_FAMID_SHIFT)) & SIM_SDID_FAMID_MASK)
+
+/*! @name SCGC4 - System Clock Gating Control Register 4 */
+#define SIM_SCGC4_I2C0_MASK                      (0x40U)
+#define SIM_SCGC4_I2C0_SHIFT                     (6U)
+#define SIM_SCGC4_I2C0(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SCGC4_I2C0_SHIFT)) & SIM_SCGC4_I2C0_MASK)
+#define SIM_SCGC4_CMP_MASK                       (0x80000U)
+#define SIM_SCGC4_CMP_SHIFT                      (19U)
+#define SIM_SCGC4_CMP(x)                         (((uint32_t)(((uint32_t)(x)) << SIM_SCGC4_CMP_SHIFT)) & SIM_SCGC4_CMP_MASK)
+#define SIM_SCGC4_VREF_MASK                      (0x100000U)
+#define SIM_SCGC4_VREF_SHIFT                     (20U)
+#define SIM_SCGC4_VREF(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SCGC4_VREF_SHIFT)) & SIM_SCGC4_VREF_MASK)
+#define SIM_SCGC4_SPI0_MASK                      (0x400000U)
+#define SIM_SCGC4_SPI0_SHIFT                     (22U)
+#define SIM_SCGC4_SPI0(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SCGC4_SPI0_SHIFT)) & SIM_SCGC4_SPI0_MASK)
+
+/*! @name SCGC5 - System Clock Gating Control Register 5 */
+#define SIM_SCGC5_LPTMR_MASK                     (0x1U)
+#define SIM_SCGC5_LPTMR_SHIFT                    (0U)
+#define SIM_SCGC5_LPTMR(x)                       (((uint32_t)(((uint32_t)(x)) << SIM_SCGC5_LPTMR_SHIFT)) & SIM_SCGC5_LPTMR_MASK)
+#define SIM_SCGC5_PORTA_MASK                     (0x200U)
+#define SIM_SCGC5_PORTA_SHIFT                    (9U)
+#define SIM_SCGC5_PORTA(x)                       (((uint32_t)(((uint32_t)(x)) << SIM_SCGC5_PORTA_SHIFT)) & SIM_SCGC5_PORTA_MASK)
+#define SIM_SCGC5_PORTB_MASK                     (0x400U)
+#define SIM_SCGC5_PORTB_SHIFT                    (10U)
+#define SIM_SCGC5_PORTB(x)                       (((uint32_t)(((uint32_t)(x)) << SIM_SCGC5_PORTB_SHIFT)) & SIM_SCGC5_PORTB_MASK)
+#define SIM_SCGC5_LPUART0_MASK                   (0x100000U)
+#define SIM_SCGC5_LPUART0_SHIFT                  (20U)
+#define SIM_SCGC5_LPUART0(x)                     (((uint32_t)(((uint32_t)(x)) << SIM_SCGC5_LPUART0_SHIFT)) & SIM_SCGC5_LPUART0_MASK)
+
+/*! @name SCGC6 - System Clock Gating Control Register 6 */
+#define SIM_SCGC6_FTF_MASK                       (0x1U)
+#define SIM_SCGC6_FTF_SHIFT                      (0U)
+#define SIM_SCGC6_FTF(x)                         (((uint32_t)(((uint32_t)(x)) << SIM_SCGC6_FTF_SHIFT)) & SIM_SCGC6_FTF_MASK)
+#define SIM_SCGC6_TPM0_MASK                      (0x1000000U)
+#define SIM_SCGC6_TPM0_SHIFT                     (24U)
+#define SIM_SCGC6_TPM0(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SCGC6_TPM0_SHIFT)) & SIM_SCGC6_TPM0_MASK)
+#define SIM_SCGC6_TPM1_MASK                      (0x2000000U)
+#define SIM_SCGC6_TPM1_SHIFT                     (25U)
+#define SIM_SCGC6_TPM1(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SCGC6_TPM1_SHIFT)) & SIM_SCGC6_TPM1_MASK)
+#define SIM_SCGC6_ADC0_MASK                      (0x8000000U)
+#define SIM_SCGC6_ADC0_SHIFT                     (27U)
+#define SIM_SCGC6_ADC0(x)                        (((uint32_t)(((uint32_t)(x)) << SIM_SCGC6_ADC0_SHIFT)) & SIM_SCGC6_ADC0_MASK)
+#define SIM_SCGC6_RTC_MASK                       (0x20000000U)
+#define SIM_SCGC6_RTC_SHIFT                      (29U)
+#define SIM_SCGC6_RTC(x)                         (((uint32_t)(((uint32_t)(x)) << SIM_SCGC6_RTC_SHIFT)) & SIM_SCGC6_RTC_MASK)
+
+/*! @name CLKDIV1 - System Clock Divider Register 1 */
+#define SIM_CLKDIV1_OUTDIV4_MASK                 (0x70000U)
+#define SIM_CLKDIV1_OUTDIV4_SHIFT                (16U)
+#define SIM_CLKDIV1_OUTDIV4(x)                   (((uint32_t)(((uint32_t)(x)) << SIM_CLKDIV1_OUTDIV4_SHIFT)) & SIM_CLKDIV1_OUTDIV4_MASK)
+#define SIM_CLKDIV1_OUTDIV1_MASK                 (0xF0000000U)
+#define SIM_CLKDIV1_OUTDIV1_SHIFT                (28U)
+#define SIM_CLKDIV1_OUTDIV1(x)                   (((uint32_t)(((uint32_t)(x)) << SIM_CLKDIV1_OUTDIV1_SHIFT)) & SIM_CLKDIV1_OUTDIV1_MASK)
+
+/*! @name FCFG1 - Flash Configuration Register 1 */
+#define SIM_FCFG1_FLASHDIS_MASK                  (0x1U)
+#define SIM_FCFG1_FLASHDIS_SHIFT                 (0U)
+#define SIM_FCFG1_FLASHDIS(x)                    (((uint32_t)(((uint32_t)(x)) << SIM_FCFG1_FLASHDIS_SHIFT)) & SIM_FCFG1_FLASHDIS_MASK)
+#define SIM_FCFG1_FLASHDOZE_MASK                 (0x2U)
+#define SIM_FCFG1_FLASHDOZE_SHIFT                (1U)
+#define SIM_FCFG1_FLASHDOZE(x)                   (((uint32_t)(((uint32_t)(x)) << SIM_FCFG1_FLASHDOZE_SHIFT)) & SIM_FCFG1_FLASHDOZE_MASK)
+#define SIM_FCFG1_PFSIZE_MASK                    (0xF000000U)
+#define SIM_FCFG1_PFSIZE_SHIFT                   (24U)
+#define SIM_FCFG1_PFSIZE(x)                      (((uint32_t)(((uint32_t)(x)) << SIM_FCFG1_PFSIZE_SHIFT)) & SIM_FCFG1_PFSIZE_MASK)
+
+/*! @name FCFG2 - Flash Configuration Register 2 */
+#define SIM_FCFG2_MAXADDR0_MASK                  (0x7F000000U)
+#define SIM_FCFG2_MAXADDR0_SHIFT                 (24U)
+#define SIM_FCFG2_MAXADDR0(x)                    (((uint32_t)(((uint32_t)(x)) << SIM_FCFG2_MAXADDR0_SHIFT)) & SIM_FCFG2_MAXADDR0_MASK)
+
+/*! @name UIDMH - Unique Identification Register Mid-High */
+#define SIM_UIDMH_UID_MASK                       (0xFFFFU)
+#define SIM_UIDMH_UID_SHIFT                      (0U)
+#define SIM_UIDMH_UID(x)                         (((uint32_t)(((uint32_t)(x)) << SIM_UIDMH_UID_SHIFT)) & SIM_UIDMH_UID_MASK)
+
+/*! @name UIDML - Unique Identification Register Mid Low */
+#define SIM_UIDML_UID_MASK                       (0xFFFFFFFFU)
+#define SIM_UIDML_UID_SHIFT                      (0U)
+#define SIM_UIDML_UID(x)                         (((uint32_t)(((uint32_t)(x)) << SIM_UIDML_UID_SHIFT)) & SIM_UIDML_UID_MASK)
+
+/*! @name UIDL - Unique Identification Register Low */
+#define SIM_UIDL_UID_MASK                        (0xFFFFFFFFU)
+#define SIM_UIDL_UID_SHIFT                       (0U)
+#define SIM_UIDL_UID(x)                          (((uint32_t)(((uint32_t)(x)) << SIM_UIDL_UID_SHIFT)) & SIM_UIDL_UID_MASK)
+
+/*! @name COPC - COP Control Register */
+#define SIM_COPC_COPW_MASK                       (0x1U)
+#define SIM_COPC_COPW_SHIFT                      (0U)
+#define SIM_COPC_COPW(x)                         (((uint32_t)(((uint32_t)(x)) << SIM_COPC_COPW_SHIFT)) & SIM_COPC_COPW_MASK)
+#define SIM_COPC_COPCLKS_MASK                    (0x2U)
+#define SIM_COPC_COPCLKS_SHIFT                   (1U)
+#define SIM_COPC_COPCLKS(x)                      (((uint32_t)(((uint32_t)(x)) << SIM_COPC_COPCLKS_SHIFT)) & SIM_COPC_COPCLKS_MASK)
+#define SIM_COPC_COPT_MASK                       (0xCU)
+#define SIM_COPC_COPT_SHIFT                      (2U)
+#define SIM_COPC_COPT(x)                         (((uint32_t)(((uint32_t)(x)) << SIM_COPC_COPT_SHIFT)) & SIM_COPC_COPT_MASK)
+#define SIM_COPC_COPSTPEN_MASK                   (0x10U)
+#define SIM_COPC_COPSTPEN_SHIFT                  (4U)
+#define SIM_COPC_COPSTPEN(x)                     (((uint32_t)(((uint32_t)(x)) << SIM_COPC_COPSTPEN_SHIFT)) & SIM_COPC_COPSTPEN_MASK)
+#define SIM_COPC_COPDBGEN_MASK                   (0x20U)
+#define SIM_COPC_COPDBGEN_SHIFT                  (5U)
+#define SIM_COPC_COPDBGEN(x)                     (((uint32_t)(((uint32_t)(x)) << SIM_COPC_COPDBGEN_SHIFT)) & SIM_COPC_COPDBGEN_MASK)
+#define SIM_COPC_COPCLKSEL_MASK                  (0xC0U)
+#define SIM_COPC_COPCLKSEL_SHIFT                 (6U)
+#define SIM_COPC_COPCLKSEL(x)                    (((uint32_t)(((uint32_t)(x)) << SIM_COPC_COPCLKSEL_SHIFT)) & SIM_COPC_COPCLKSEL_MASK)
+
+/*! @name SRVCOP - Service COP */
+#define SIM_SRVCOP_SRVCOP_MASK                   (0xFFU)
+#define SIM_SRVCOP_SRVCOP_SHIFT                  (0U)
+#define SIM_SRVCOP_SRVCOP(x)                     (((uint32_t)(((uint32_t)(x)) << SIM_SRVCOP_SRVCOP_SHIFT)) & SIM_SRVCOP_SRVCOP_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group SIM_Register_Masks */
+
+
+/* SIM - Peripheral instance base addresses */
+/** Peripheral SIM base address */
+#define SIM_BASE                                 (0x40047000u)
+/** Peripheral SIM base pointer */
+#define SIM                                      ((SIM_Type *)SIM_BASE)
+/** Array initializer of SIM peripheral base addresses */
+#define SIM_BASE_ADDRS                           { SIM_BASE }
+/** Array initializer of SIM peripheral base pointers */
+#define SIM_BASE_PTRS                            { SIM }
+
+/*!
+ * @}
+ */ /* end of group SIM_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- SMC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SMC_Peripheral_Access_Layer SMC Peripheral Access Layer
+ * @{
+ */
+
+/** SMC - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t PMPROT;                             /**< Power Mode Protection register, offset: 0x0 */
+  __IO uint8_t PMCTRL;                             /**< Power Mode Control register, offset: 0x1 */
+  __IO uint8_t STOPCTRL;                           /**< Stop Control Register, offset: 0x2 */
+  __I  uint8_t PMSTAT;                             /**< Power Mode Status register, offset: 0x3 */
+} SMC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- SMC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SMC_Register_Masks SMC Register Masks
+ * @{
+ */
+
+/*! @name PMPROT - Power Mode Protection register */
+#define SMC_PMPROT_AVLLS_MASK                    (0x2U)
+#define SMC_PMPROT_AVLLS_SHIFT                   (1U)
+#define SMC_PMPROT_AVLLS(x)                      (((uint8_t)(((uint8_t)(x)) << SMC_PMPROT_AVLLS_SHIFT)) & SMC_PMPROT_AVLLS_MASK)
+#define SMC_PMPROT_AVLP_MASK                     (0x20U)
+#define SMC_PMPROT_AVLP_SHIFT                    (5U)
+#define SMC_PMPROT_AVLP(x)                       (((uint8_t)(((uint8_t)(x)) << SMC_PMPROT_AVLP_SHIFT)) & SMC_PMPROT_AVLP_MASK)
+
+/*! @name PMCTRL - Power Mode Control register */
+#define SMC_PMCTRL_STOPM_MASK                    (0x7U)
+#define SMC_PMCTRL_STOPM_SHIFT                   (0U)
+#define SMC_PMCTRL_STOPM(x)                      (((uint8_t)(((uint8_t)(x)) << SMC_PMCTRL_STOPM_SHIFT)) & SMC_PMCTRL_STOPM_MASK)
+#define SMC_PMCTRL_STOPA_MASK                    (0x8U)
+#define SMC_PMCTRL_STOPA_SHIFT                   (3U)
+#define SMC_PMCTRL_STOPA(x)                      (((uint8_t)(((uint8_t)(x)) << SMC_PMCTRL_STOPA_SHIFT)) & SMC_PMCTRL_STOPA_MASK)
+#define SMC_PMCTRL_RUNM_MASK                     (0x60U)
+#define SMC_PMCTRL_RUNM_SHIFT                    (5U)
+#define SMC_PMCTRL_RUNM(x)                       (((uint8_t)(((uint8_t)(x)) << SMC_PMCTRL_RUNM_SHIFT)) & SMC_PMCTRL_RUNM_MASK)
+
+/*! @name STOPCTRL - Stop Control Register */
+#define SMC_STOPCTRL_VLLSM_MASK                  (0x7U)
+#define SMC_STOPCTRL_VLLSM_SHIFT                 (0U)
+#define SMC_STOPCTRL_VLLSM(x)                    (((uint8_t)(((uint8_t)(x)) << SMC_STOPCTRL_VLLSM_SHIFT)) & SMC_STOPCTRL_VLLSM_MASK)
+#define SMC_STOPCTRL_LPOPO_MASK                  (0x8U)
+#define SMC_STOPCTRL_LPOPO_SHIFT                 (3U)
+#define SMC_STOPCTRL_LPOPO(x)                    (((uint8_t)(((uint8_t)(x)) << SMC_STOPCTRL_LPOPO_SHIFT)) & SMC_STOPCTRL_LPOPO_MASK)
+#define SMC_STOPCTRL_PORPO_MASK                  (0x20U)
+#define SMC_STOPCTRL_PORPO_SHIFT                 (5U)
+#define SMC_STOPCTRL_PORPO(x)                    (((uint8_t)(((uint8_t)(x)) << SMC_STOPCTRL_PORPO_SHIFT)) & SMC_STOPCTRL_PORPO_MASK)
+#define SMC_STOPCTRL_PSTOPO_MASK                 (0xC0U)
+#define SMC_STOPCTRL_PSTOPO_SHIFT                (6U)
+#define SMC_STOPCTRL_PSTOPO(x)                   (((uint8_t)(((uint8_t)(x)) << SMC_STOPCTRL_PSTOPO_SHIFT)) & SMC_STOPCTRL_PSTOPO_MASK)
+
+/*! @name PMSTAT - Power Mode Status register */
+#define SMC_PMSTAT_PMSTAT_MASK                   (0x7FU)
+#define SMC_PMSTAT_PMSTAT_SHIFT                  (0U)
+#define SMC_PMSTAT_PMSTAT(x)                     (((uint8_t)(((uint8_t)(x)) << SMC_PMSTAT_PMSTAT_SHIFT)) & SMC_PMSTAT_PMSTAT_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group SMC_Register_Masks */
+
+
+/* SMC - Peripheral instance base addresses */
+/** Peripheral SMC base address */
+#define SMC_BASE                                 (0x4007E000u)
+/** Peripheral SMC base pointer */
+#define SMC                                      ((SMC_Type *)SMC_BASE)
+/** Array initializer of SMC peripheral base addresses */
+#define SMC_BASE_ADDRS                           { SMC_BASE }
+/** Array initializer of SMC peripheral base pointers */
+#define SMC_BASE_PTRS                            { SMC }
+
+/*!
+ * @}
+ */ /* end of group SMC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- SPI Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SPI_Peripheral_Access_Layer SPI Peripheral Access Layer
+ * @{
+ */
+
+/** SPI - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t S;                                  /**< SPI Status Register, offset: 0x0 */
+  __IO uint8_t BR;                                 /**< SPI Baud Rate Register, offset: 0x1 */
+  __IO uint8_t C2;                                 /**< SPI Control Register 2, offset: 0x2 */
+  __IO uint8_t C1;                                 /**< SPI Control Register 1, offset: 0x3 */
+  __IO uint8_t M;                                  /**< SPI Match Register, offset: 0x4 */
+       uint8_t RESERVED_0[1];
+  __IO uint8_t D;                                  /**< SPI Data Register, offset: 0x6 */
+} SPI_Type;
+
+/* ----------------------------------------------------------------------------
+   -- SPI Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SPI_Register_Masks SPI Register Masks
+ * @{
+ */
+
+/*! @name S - SPI Status Register */
+#define SPI_S_MODF_MASK                          (0x10U)
+#define SPI_S_MODF_SHIFT                         (4U)
+#define SPI_S_MODF(x)                            (((uint8_t)(((uint8_t)(x)) << SPI_S_MODF_SHIFT)) & SPI_S_MODF_MASK)
+#define SPI_S_SPTEF_MASK                         (0x20U)
+#define SPI_S_SPTEF_SHIFT                        (5U)
+#define SPI_S_SPTEF(x)                           (((uint8_t)(((uint8_t)(x)) << SPI_S_SPTEF_SHIFT)) & SPI_S_SPTEF_MASK)
+#define SPI_S_SPMF_MASK                          (0x40U)
+#define SPI_S_SPMF_SHIFT                         (6U)
+#define SPI_S_SPMF(x)                            (((uint8_t)(((uint8_t)(x)) << SPI_S_SPMF_SHIFT)) & SPI_S_SPMF_MASK)
+#define SPI_S_SPRF_MASK                          (0x80U)
+#define SPI_S_SPRF_SHIFT                         (7U)
+#define SPI_S_SPRF(x)                            (((uint8_t)(((uint8_t)(x)) << SPI_S_SPRF_SHIFT)) & SPI_S_SPRF_MASK)
+
+/*! @name BR - SPI Baud Rate Register */
+#define SPI_BR_SPR_MASK                          (0xFU)
+#define SPI_BR_SPR_SHIFT                         (0U)
+#define SPI_BR_SPR(x)                            (((uint8_t)(((uint8_t)(x)) << SPI_BR_SPR_SHIFT)) & SPI_BR_SPR_MASK)
+#define SPI_BR_SPPR_MASK                         (0x70U)
+#define SPI_BR_SPPR_SHIFT                        (4U)
+#define SPI_BR_SPPR(x)                           (((uint8_t)(((uint8_t)(x)) << SPI_BR_SPPR_SHIFT)) & SPI_BR_SPPR_MASK)
+
+/*! @name C2 - SPI Control Register 2 */
+#define SPI_C2_SPC0_MASK                         (0x1U)
+#define SPI_C2_SPC0_SHIFT                        (0U)
+#define SPI_C2_SPC0(x)                           (((uint8_t)(((uint8_t)(x)) << SPI_C2_SPC0_SHIFT)) & SPI_C2_SPC0_MASK)
+#define SPI_C2_SPISWAI_MASK                      (0x2U)
+#define SPI_C2_SPISWAI_SHIFT                     (1U)
+#define SPI_C2_SPISWAI(x)                        (((uint8_t)(((uint8_t)(x)) << SPI_C2_SPISWAI_SHIFT)) & SPI_C2_SPISWAI_MASK)
+#define SPI_C2_BIDIROE_MASK                      (0x8U)
+#define SPI_C2_BIDIROE_SHIFT                     (3U)
+#define SPI_C2_BIDIROE(x)                        (((uint8_t)(((uint8_t)(x)) << SPI_C2_BIDIROE_SHIFT)) & SPI_C2_BIDIROE_MASK)
+#define SPI_C2_MODFEN_MASK                       (0x10U)
+#define SPI_C2_MODFEN_SHIFT                      (4U)
+#define SPI_C2_MODFEN(x)                         (((uint8_t)(((uint8_t)(x)) << SPI_C2_MODFEN_SHIFT)) & SPI_C2_MODFEN_MASK)
+#define SPI_C2_SPMIE_MASK                        (0x80U)
+#define SPI_C2_SPMIE_SHIFT                       (7U)
+#define SPI_C2_SPMIE(x)                          (((uint8_t)(((uint8_t)(x)) << SPI_C2_SPMIE_SHIFT)) & SPI_C2_SPMIE_MASK)
+
+/*! @name C1 - SPI Control Register 1 */
+#define SPI_C1_LSBFE_MASK                        (0x1U)
+#define SPI_C1_LSBFE_SHIFT                       (0U)
+#define SPI_C1_LSBFE(x)                          (((uint8_t)(((uint8_t)(x)) << SPI_C1_LSBFE_SHIFT)) & SPI_C1_LSBFE_MASK)
+#define SPI_C1_SSOE_MASK                         (0x2U)
+#define SPI_C1_SSOE_SHIFT                        (1U)
+#define SPI_C1_SSOE(x)                           (((uint8_t)(((uint8_t)(x)) << SPI_C1_SSOE_SHIFT)) & SPI_C1_SSOE_MASK)
+#define SPI_C1_CPHA_MASK                         (0x4U)
+#define SPI_C1_CPHA_SHIFT                        (2U)
+#define SPI_C1_CPHA(x)                           (((uint8_t)(((uint8_t)(x)) << SPI_C1_CPHA_SHIFT)) & SPI_C1_CPHA_MASK)
+#define SPI_C1_CPOL_MASK                         (0x8U)
+#define SPI_C1_CPOL_SHIFT                        (3U)
+#define SPI_C1_CPOL(x)                           (((uint8_t)(((uint8_t)(x)) << SPI_C1_CPOL_SHIFT)) & SPI_C1_CPOL_MASK)
+#define SPI_C1_MSTR_MASK                         (0x10U)
+#define SPI_C1_MSTR_SHIFT                        (4U)
+#define SPI_C1_MSTR(x)                           (((uint8_t)(((uint8_t)(x)) << SPI_C1_MSTR_SHIFT)) & SPI_C1_MSTR_MASK)
+#define SPI_C1_SPTIE_MASK                        (0x20U)
+#define SPI_C1_SPTIE_SHIFT                       (5U)
+#define SPI_C1_SPTIE(x)                          (((uint8_t)(((uint8_t)(x)) << SPI_C1_SPTIE_SHIFT)) & SPI_C1_SPTIE_MASK)
+#define SPI_C1_SPE_MASK                          (0x40U)
+#define SPI_C1_SPE_SHIFT                         (6U)
+#define SPI_C1_SPE(x)                            (((uint8_t)(((uint8_t)(x)) << SPI_C1_SPE_SHIFT)) & SPI_C1_SPE_MASK)
+#define SPI_C1_SPIE_MASK                         (0x80U)
+#define SPI_C1_SPIE_SHIFT                        (7U)
+#define SPI_C1_SPIE(x)                           (((uint8_t)(((uint8_t)(x)) << SPI_C1_SPIE_SHIFT)) & SPI_C1_SPIE_MASK)
+
+/*! @name M - SPI Match Register */
+#define SPI_M_Bits_MASK                          (0xFFU)
+#define SPI_M_Bits_SHIFT                         (0U)
+#define SPI_M_Bits(x)                            (((uint8_t)(((uint8_t)(x)) << SPI_M_Bits_SHIFT)) & SPI_M_Bits_MASK)
+
+/*! @name D - SPI Data Register */
+#define SPI_D_Bits_MASK                          (0xFFU)
+#define SPI_D_Bits_SHIFT                         (0U)
+#define SPI_D_Bits(x)                            (((uint8_t)(((uint8_t)(x)) << SPI_D_Bits_SHIFT)) & SPI_D_Bits_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group SPI_Register_Masks */
+
+
+/* SPI - Peripheral instance base addresses */
+/** Peripheral SPI0 base address */
+#define SPI0_BASE                                (0x40076000u)
+/** Peripheral SPI0 base pointer */
+#define SPI0                                     ((SPI_Type *)SPI0_BASE)
+/** Array initializer of SPI peripheral base addresses */
+#define SPI_BASE_ADDRS                           { SPI0_BASE }
+/** Array initializer of SPI peripheral base pointers */
+#define SPI_BASE_PTRS                            { SPI0 }
+/** Interrupt vectors for the SPI peripheral type */
+#define SPI_IRQS                                 { SPI0_IRQn }
+
+/*!
+ * @}
+ */ /* end of group SPI_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- TPM Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup TPM_Peripheral_Access_Layer TPM Peripheral Access Layer
+ * @{
+ */
+
+/** TPM - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t SC;                                /**< Status and Control, offset: 0x0 */
+  __IO uint32_t CNT;                               /**< Counter, offset: 0x4 */
+  __IO uint32_t MOD;                               /**< Modulo, offset: 0x8 */
+  struct {                                         /* offset: 0xC, array step: 0x8 */
+    __IO uint32_t CnSC;                              /**< Channel (n) Status and Control, array offset: 0xC, array step: 0x8 */
+    __IO uint32_t CnV;                               /**< Channel (n) Value, array offset: 0x10, array step: 0x8 */
+  } CONTROLS[2];
+       uint8_t RESERVED_0[52];
+  __IO uint32_t STATUS;                            /**< Capture and Compare Status, offset: 0x50 */
+       uint8_t RESERVED_1[48];
+  __IO uint32_t CONF;                              /**< Configuration, offset: 0x84 */
+} TPM_Type;
+
+/* ----------------------------------------------------------------------------
+   -- TPM Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup TPM_Register_Masks TPM Register Masks
+ * @{
+ */
+
+/*! @name SC - Status and Control */
+#define TPM_SC_PS_MASK                           (0x7U)
+#define TPM_SC_PS_SHIFT                          (0U)
+#define TPM_SC_PS(x)                             (((uint32_t)(((uint32_t)(x)) << TPM_SC_PS_SHIFT)) & TPM_SC_PS_MASK)
+#define TPM_SC_CMOD_MASK                         (0x18U)
+#define TPM_SC_CMOD_SHIFT                        (3U)
+#define TPM_SC_CMOD(x)                           (((uint32_t)(((uint32_t)(x)) << TPM_SC_CMOD_SHIFT)) & TPM_SC_CMOD_MASK)
+#define TPM_SC_CPWMS_MASK                        (0x20U)
+#define TPM_SC_CPWMS_SHIFT                       (5U)
+#define TPM_SC_CPWMS(x)                          (((uint32_t)(((uint32_t)(x)) << TPM_SC_CPWMS_SHIFT)) & TPM_SC_CPWMS_MASK)
+#define TPM_SC_TOIE_MASK                         (0x40U)
+#define TPM_SC_TOIE_SHIFT                        (6U)
+#define TPM_SC_TOIE(x)                           (((uint32_t)(((uint32_t)(x)) << TPM_SC_TOIE_SHIFT)) & TPM_SC_TOIE_MASK)
+#define TPM_SC_TOF_MASK                          (0x80U)
+#define TPM_SC_TOF_SHIFT                         (7U)
+#define TPM_SC_TOF(x)                            (((uint32_t)(((uint32_t)(x)) << TPM_SC_TOF_SHIFT)) & TPM_SC_TOF_MASK)
+
+/*! @name CNT - Counter */
+#define TPM_CNT_COUNT_MASK                       (0xFFFFU)
+#define TPM_CNT_COUNT_SHIFT                      (0U)
+#define TPM_CNT_COUNT(x)                         (((uint32_t)(((uint32_t)(x)) << TPM_CNT_COUNT_SHIFT)) & TPM_CNT_COUNT_MASK)
+
+/*! @name MOD - Modulo */
+#define TPM_MOD_MOD_MASK                         (0xFFFFU)
+#define TPM_MOD_MOD_SHIFT                        (0U)
+#define TPM_MOD_MOD(x)                           (((uint32_t)(((uint32_t)(x)) << TPM_MOD_MOD_SHIFT)) & TPM_MOD_MOD_MASK)
+
+/*! @name CnSC - Channel (n) Status and Control */
+#define TPM_CnSC_ELSA_MASK                       (0x4U)
+#define TPM_CnSC_ELSA_SHIFT                      (2U)
+#define TPM_CnSC_ELSA(x)                         (((uint32_t)(((uint32_t)(x)) << TPM_CnSC_ELSA_SHIFT)) & TPM_CnSC_ELSA_MASK)
+#define TPM_CnSC_ELSB_MASK                       (0x8U)
+#define TPM_CnSC_ELSB_SHIFT                      (3U)
+#define TPM_CnSC_ELSB(x)                         (((uint32_t)(((uint32_t)(x)) << TPM_CnSC_ELSB_SHIFT)) & TPM_CnSC_ELSB_MASK)
+#define TPM_CnSC_MSA_MASK                        (0x10U)
+#define TPM_CnSC_MSA_SHIFT                       (4U)
+#define TPM_CnSC_MSA(x)                          (((uint32_t)(((uint32_t)(x)) << TPM_CnSC_MSA_SHIFT)) & TPM_CnSC_MSA_MASK)
+#define TPM_CnSC_MSB_MASK                        (0x20U)
+#define TPM_CnSC_MSB_SHIFT                       (5U)
+#define TPM_CnSC_MSB(x)                          (((uint32_t)(((uint32_t)(x)) << TPM_CnSC_MSB_SHIFT)) & TPM_CnSC_MSB_MASK)
+#define TPM_CnSC_CHIE_MASK                       (0x40U)
+#define TPM_CnSC_CHIE_SHIFT                      (6U)
+#define TPM_CnSC_CHIE(x)                         (((uint32_t)(((uint32_t)(x)) << TPM_CnSC_CHIE_SHIFT)) & TPM_CnSC_CHIE_MASK)
+#define TPM_CnSC_CHF_MASK                        (0x80U)
+#define TPM_CnSC_CHF_SHIFT                       (7U)
+#define TPM_CnSC_CHF(x)                          (((uint32_t)(((uint32_t)(x)) << TPM_CnSC_CHF_SHIFT)) & TPM_CnSC_CHF_MASK)
+
+/* The count of TPM_CnSC */
+#define TPM_CnSC_COUNT                           (2U)
+
+/*! @name CnV - Channel (n) Value */
+#define TPM_CnV_VAL_MASK                         (0xFFFFU)
+#define TPM_CnV_VAL_SHIFT                        (0U)
+#define TPM_CnV_VAL(x)                           (((uint32_t)(((uint32_t)(x)) << TPM_CnV_VAL_SHIFT)) & TPM_CnV_VAL_MASK)
+
+/* The count of TPM_CnV */
+#define TPM_CnV_COUNT                            (2U)
+
+/*! @name STATUS - Capture and Compare Status */
+#define TPM_STATUS_CH0F_MASK                     (0x1U)
+#define TPM_STATUS_CH0F_SHIFT                    (0U)
+#define TPM_STATUS_CH0F(x)                       (((uint32_t)(((uint32_t)(x)) << TPM_STATUS_CH0F_SHIFT)) & TPM_STATUS_CH0F_MASK)
+#define TPM_STATUS_CH1F_MASK                     (0x2U)
+#define TPM_STATUS_CH1F_SHIFT                    (1U)
+#define TPM_STATUS_CH1F(x)                       (((uint32_t)(((uint32_t)(x)) << TPM_STATUS_CH1F_SHIFT)) & TPM_STATUS_CH1F_MASK)
+#define TPM_STATUS_TOF_MASK                      (0x100U)
+#define TPM_STATUS_TOF_SHIFT                     (8U)
+#define TPM_STATUS_TOF(x)                        (((uint32_t)(((uint32_t)(x)) << TPM_STATUS_TOF_SHIFT)) & TPM_STATUS_TOF_MASK)
+
+/*! @name CONF - Configuration */
+#define TPM_CONF_DOZEEN_MASK                     (0x20U)
+#define TPM_CONF_DOZEEN_SHIFT                    (5U)
+#define TPM_CONF_DOZEEN(x)                       (((uint32_t)(((uint32_t)(x)) << TPM_CONF_DOZEEN_SHIFT)) & TPM_CONF_DOZEEN_MASK)
+#define TPM_CONF_DBGMODE_MASK                    (0xC0U)
+#define TPM_CONF_DBGMODE_SHIFT                   (6U)
+#define TPM_CONF_DBGMODE(x)                      (((uint32_t)(((uint32_t)(x)) << TPM_CONF_DBGMODE_SHIFT)) & TPM_CONF_DBGMODE_MASK)
+#define TPM_CONF_GTBEEN_MASK                     (0x200U)
+#define TPM_CONF_GTBEEN_SHIFT                    (9U)
+#define TPM_CONF_GTBEEN(x)                       (((uint32_t)(((uint32_t)(x)) << TPM_CONF_GTBEEN_SHIFT)) & TPM_CONF_GTBEEN_MASK)
+#define TPM_CONF_CSOT_MASK                       (0x10000U)
+#define TPM_CONF_CSOT_SHIFT                      (16U)
+#define TPM_CONF_CSOT(x)                         (((uint32_t)(((uint32_t)(x)) << TPM_CONF_CSOT_SHIFT)) & TPM_CONF_CSOT_MASK)
+#define TPM_CONF_CSOO_MASK                       (0x20000U)
+#define TPM_CONF_CSOO_SHIFT                      (17U)
+#define TPM_CONF_CSOO(x)                         (((uint32_t)(((uint32_t)(x)) << TPM_CONF_CSOO_SHIFT)) & TPM_CONF_CSOO_MASK)
+#define TPM_CONF_CROT_MASK                       (0x40000U)
+#define TPM_CONF_CROT_SHIFT                      (18U)
+#define TPM_CONF_CROT(x)                         (((uint32_t)(((uint32_t)(x)) << TPM_CONF_CROT_SHIFT)) & TPM_CONF_CROT_MASK)
+#define TPM_CONF_TRGSEL_MASK                     (0xF000000U)
+#define TPM_CONF_TRGSEL_SHIFT                    (24U)
+#define TPM_CONF_TRGSEL(x)                       (((uint32_t)(((uint32_t)(x)) << TPM_CONF_TRGSEL_SHIFT)) & TPM_CONF_TRGSEL_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group TPM_Register_Masks */
+
+
+/* TPM - Peripheral instance base addresses */
+/** Peripheral TPM0 base address */
+#define TPM0_BASE                                (0x40038000u)
+/** Peripheral TPM0 base pointer */
+#define TPM0                                     ((TPM_Type *)TPM0_BASE)
+/** Peripheral TPM1 base address */
+#define TPM1_BASE                                (0x40039000u)
+/** Peripheral TPM1 base pointer */
+#define TPM1                                     ((TPM_Type *)TPM1_BASE)
+/** Array initializer of TPM peripheral base addresses */
+#define TPM_BASE_ADDRS                           { TPM0_BASE, TPM1_BASE }
+/** Array initializer of TPM peripheral base pointers */
+#define TPM_BASE_PTRS                            { TPM0, TPM1 }
+/** Interrupt vectors for the TPM peripheral type */
+#define TPM_IRQS                                 { TPM0_IRQn, TPM1_IRQn }
+
+/*!
+ * @}
+ */ /* end of group TPM_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- VREF Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup VREF_Peripheral_Access_Layer VREF Peripheral Access Layer
+ * @{
+ */
+
+/** VREF - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t TRM;                                /**< VREF Trim Register, offset: 0x0 */
+  __IO uint8_t SC;                                 /**< VREF Status and Control Register, offset: 0x1 */
+} VREF_Type;
+
+/* ----------------------------------------------------------------------------
+   -- VREF Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup VREF_Register_Masks VREF Register Masks
+ * @{
+ */
+
+/*! @name TRM - VREF Trim Register */
+#define VREF_TRM_TRIM_MASK                       (0x3FU)
+#define VREF_TRM_TRIM_SHIFT                      (0U)
+#define VREF_TRM_TRIM(x)                         (((uint8_t)(((uint8_t)(x)) << VREF_TRM_TRIM_SHIFT)) & VREF_TRM_TRIM_MASK)
+#define VREF_TRM_CHOPEN_MASK                     (0x40U)
+#define VREF_TRM_CHOPEN_SHIFT                    (6U)
+#define VREF_TRM_CHOPEN(x)                       (((uint8_t)(((uint8_t)(x)) << VREF_TRM_CHOPEN_SHIFT)) & VREF_TRM_CHOPEN_MASK)
+
+/*! @name SC - VREF Status and Control Register */
+#define VREF_SC_MODE_LV_MASK                     (0x3U)
+#define VREF_SC_MODE_LV_SHIFT                    (0U)
+#define VREF_SC_MODE_LV(x)                       (((uint8_t)(((uint8_t)(x)) << VREF_SC_MODE_LV_SHIFT)) & VREF_SC_MODE_LV_MASK)
+#define VREF_SC_VREFST_MASK                      (0x4U)
+#define VREF_SC_VREFST_SHIFT                     (2U)
+#define VREF_SC_VREFST(x)                        (((uint8_t)(((uint8_t)(x)) << VREF_SC_VREFST_SHIFT)) & VREF_SC_VREFST_MASK)
+#define VREF_SC_ICOMPEN_MASK                     (0x20U)
+#define VREF_SC_ICOMPEN_SHIFT                    (5U)
+#define VREF_SC_ICOMPEN(x)                       (((uint8_t)(((uint8_t)(x)) << VREF_SC_ICOMPEN_SHIFT)) & VREF_SC_ICOMPEN_MASK)
+#define VREF_SC_REGEN_MASK                       (0x40U)
+#define VREF_SC_REGEN_SHIFT                      (6U)
+#define VREF_SC_REGEN(x)                         (((uint8_t)(((uint8_t)(x)) << VREF_SC_REGEN_SHIFT)) & VREF_SC_REGEN_MASK)
+#define VREF_SC_VREFEN_MASK                      (0x80U)
+#define VREF_SC_VREFEN_SHIFT                     (7U)
+#define VREF_SC_VREFEN(x)                        (((uint8_t)(((uint8_t)(x)) << VREF_SC_VREFEN_SHIFT)) & VREF_SC_VREFEN_MASK)
+
+
+/*!
+ * @}
+ */ /* end of group VREF_Register_Masks */
+
+
+/* VREF - Peripheral instance base addresses */
+/** Peripheral VREF base address */
+#define VREF_BASE                                (0x40074000u)
+/** Peripheral VREF base pointer */
+#define VREF                                     ((VREF_Type *)VREF_BASE)
+/** Array initializer of VREF peripheral base addresses */
+#define VREF_BASE_ADDRS                          { VREF_BASE }
+/** Array initializer of VREF peripheral base pointers */
+#define VREF_BASE_PTRS                           { VREF }
+
+/*!
+ * @}
+ */ /* end of group VREF_Peripheral_Access_Layer */
+
+
+/*
+** End of section using anonymous unions
+*/
+
+#if defined(__ARMCC_VERSION)
+  #pragma pop
+#elif defined(__CWCC__)
+  #pragma pop
+#elif defined(__GNUC__)
+  /* leave anonymous unions enabled */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=default
+#else
+  #error Not supported compiler type
+#endif
+
+/*!
+ * @}
+ */ /* end of group Peripheral_access_layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- Macros for use with bit field definitions (xxx_SHIFT, xxx_MASK).
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup Bit_Field_Generic_Macros Macros for use with bit field definitions (xxx_SHIFT, xxx_MASK).
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+  #if (__ARMCC_VERSION >= 6010050)
+    #pragma clang system_header
+  #endif
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma system_include
+#endif
+
+/**
+ * @brief Mask and left-shift a bit field value for use in a register bit range.
+ * @param field Name of the register bit field.
+ * @param value Value of the bit field.
+ * @return Masked and shifted value.
+ */
+#define NXP_VAL2FLD(field, value)    (((value) << (field ## _SHIFT)) & (field ## _MASK))
+/**
+ * @brief Mask and right-shift a register value to extract a bit field value.
+ * @param field Name of the register bit field.
+ * @param value Value of the register.
+ * @return Masked and shifted bit field value.
+ */
+#define NXP_FLD2VAL(field, value)    (((value) & (field ## _MASK)) >> (field ## _SHIFT))
+
+/*!
+ * @}
+ */ /* end of group Bit_Field_Generic_Macros */
+
+
+/* ----------------------------------------------------------------------------
+   -- SDK Compatibility
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SDK_Compatibility_Symbols SDK Compatibility
+ * @{
+ */
+
+#define I2C_S1_REG(base)                  I2C_S_REG(base)
+#define I2C_S1_RXAK_MASK                  I2C_S_RXAK_MASK
+#define I2C_S1_RXAK_SHIFT                 I2C_S_RXAK_SHIFT
+#define I2C_S1_IICIF_MASK                 I2C_S_IICIF_MASK
+#define I2C_S1_IICIF_SHIFT                I2C_S_IICIF_SHIFT
+#define I2C_S1_SRW_MASK                   I2C_S_SRW_MASK
+#define I2C_S1_SRW_SHIFT                  I2C_S_SRW_SHIFT
+#define I2C_S1_RAM_MASK                   I2C_S_RAM_MASK
+#define I2C_S1_RAM_SHIFT                  I2C_S_RAM_SHIFT
+#define I2C_S1_ARBL_MASK                  I2C_S_ARBL_MASK
+#define I2C_S1_ARBL_SHIFT                 I2C_S_ARBL_SHIFT
+#define I2C_S1_BUSY_MASK                  I2C_S_BUSY_MASK
+#define I2C_S1_BUSY_SHIFT                 I2C_S_BUSY_SHIFT
+#define I2C_S1_IAAS_MASK                  I2C_S_IAAS_MASK
+#define I2C_S1_IAAS_SHIFT                 I2C_S_IAAS_SHIFT
+#define I2C_S1_TCF_MASK                   I2C_S_TCF_MASK
+#define I2C_S1_TCF_SHIFT                  I2C_S_TCF_SHIFT
+#define I2C0_S1                           I2C0_S
+#define I2C_FLT_STOPIE_MASK               This_symbol_has_been_deprecated
+#define I2C_FLT_STOPIE_SHIFT              This_symbol_has_been_deprecated
+#define MCG_HCTRIM_COARSE_TRIM_MASK       This_symbol_has_been_deprecated
+#define MCG_HCTRIM_COARSE_TRIM_SHIFT      This_symbol_has_been_deprecated
+#define MCG_HCTRIM_COARSE_TRIM(x)         This_symbol_has_been_deprecated
+#define MCG_HTTRIM_TEMPCO_TRIM_MASK       This_symbol_has_been_deprecated
+#define MCG_HTTRIM_TEMPCO_TRIM_SHIFT      This_symbol_has_been_deprecated
+#define MCG_HTTRIM_TEMPCO_TRIM(x)         This_symbol_has_been_deprecated
+#define MCG_HFTRIM_FINE_TRIM_MASK         This_symbol_has_been_deprecated
+#define MCG_HFTRIM_FINE_TRIM_SHIFT        This_symbol_has_been_deprecated
+#define MCG_HFTRIM_FINE_TRIM(x)           This_symbol_has_been_deprecated
+#define MCG_LTRIMRNG_STRIMRNG_MASK        This_symbol_has_been_deprecated
+#define MCG_LTRIMRNG_STRIMRNG_SHIFT       This_symbol_has_been_deprecated
+#define MCG_LTRIMRNG_STRIMRNG(x)          This_symbol_has_been_deprecated
+#define MCG_LTRIMRNG_FTRIMRNG_MASK        This_symbol_has_been_deprecated
+#define MCG_LTRIMRNG_FTRIMRNG_SHIFT       This_symbol_has_been_deprecated
+#define MCG_LTRIMRNG_FTRIMRNG(x)          This_symbol_has_been_deprecated
+#define MCG_LFTRIM_LIRC_FTRIM_MASK        This_symbol_has_been_deprecated
+#define MCG_LFTRIM_LIRC_FTRIM_SHIFT       This_symbol_has_been_deprecated
+#define MCG_LFTRIM_LIRC_FTRIM(x)          This_symbol_has_been_deprecated
+#define MCG_LSTRIM_LIRC_STRIM_MASK        This_symbol_has_been_deprecated
+#define MCG_LSTRIM_LIRC_STRIM_SHIFT       This_symbol_has_been_deprecated
+#define MCG_LSTRIM_LIRC_STRIM(x)          This_symbol_has_been_deprecated
+#define PTA_BASE                          GPIOA_BASE
+#define PTB_BASE                          GPIOB_BASE
+#define PTA                               GPIOA
+#define PTB                               GPIOB
+#define FPTA_BASE                         FGPIOA_BASE
+#define FPTB_BASE                         FGPIOB_BASE
+#define FPTA                              FGPIOA
+#define FPTB                              FGPIOB
+
+/*!
+ * @}
+ */ /* end of group SDK_Compatibility_Symbols */
+
+
+#endif  /* _MKL03Z4_H_ */
+
diff --git a/KL0/MKL03Z4/MKL03Z4_COMMON.h b/KL0/MKL03Z4/MKL03Z4_COMMON.h
new file mode 100644
index 0000000..30f235e
--- /dev/null
+++ b/KL0/MKL03Z4/MKL03Z4_COMMON.h
@@ -0,0 +1 @@
+#include "MKL03Z4.h"
\ No newline at end of file
diff --git a/KL0/MKL03Z4/MKL03Z4_features.h b/KL0/MKL03Z4/MKL03Z4_features.h
new file mode 100644
index 0000000..1d4657b
--- /dev/null
+++ b/KL0/MKL03Z4/MKL03Z4_features.h
@@ -0,0 +1,1832 @@
+/*
+** ###################################################################
+**     Version:             rev. 1.8, 2015-05-25
+**     Build:               b170918
+**
+**     Abstract:
+**         Chip specific module features.
+**
+**     The Clear BSD License
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2017 NXP
+**     All rights reserved.
+**     
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted (subject to the limitations in the disclaimer below) provided
+**      that the following conditions are met:
+**
+**     1. Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     2. Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     3. Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+**     Revisions:
+**     - rev. 1.0 (2013-12-11)
+**         Initial version.
+**     - rev. 1.1 (2014-01-30)
+**         Added single maximum value generation and a constrain to varying feature values that only numbers can have maximum.
+**     - rev. 1.2 (2014-04-16)
+**         Update of the I2C module (SMBUS feature).
+**         Update of the MCG_Light module.
+**         Added register file system (RFSYS).
+**     - rev. 1.3 (2014-04-30)
+**         PEx compatibility macros has been added.
+**     - rev. 1.4 (2014-06-27)
+**         I2C_S1 register was renamed.
+**         GPIO - Modules PTA,PTB renamed to GPIOA,GPIOB.
+**     - rev. 1.5 (2014-08-28)
+**         Update of system files - default clock configuration changed.
+**         Update of startup files - possibility to override DefaultISR added.
+**     - rev. 1.6 (2015-01-21)
+**         Added FSL_FEATURE_SOC_peripheral_COUNT with number of peripheral instances
+**     - rev. 1.7 (2015-05-19)
+**         FSL_FEATURE_SOC_CAU_COUNT remamed to FSL_FEATURE_SOC_MMCAU_COUNT.
+**         Added FSL_FEATURE_SOC_peripheral_COUNT for TRNG and HSADC.
+**         Added features for PORT.
+**     - rev. 1.8 (2015-05-25)
+**         Added FSL_FEATURE_FLASH_PFLASH_START_ADDRESS
+**
+** ###################################################################
+*/
+
+#ifndef _MKL03Z4_FEATURES_H_
+#define _MKL03Z4_FEATURES_H_
+
+/* SOC module features */
+
+/* @brief ACMP availability on the SoC. */
+#define FSL_FEATURE_SOC_ACMP_COUNT (0)
+/* @brief ADC16 availability on the SoC. */
+#define FSL_FEATURE_SOC_ADC16_COUNT (1)
+/* @brief ADC12 availability on the SoC. */
+#define FSL_FEATURE_SOC_ADC12_COUNT (0)
+/* @brief AFE availability on the SoC. */
+#define FSL_FEATURE_SOC_AFE_COUNT (0)
+/* @brief AIPS availability on the SoC. */
+#define FSL_FEATURE_SOC_AIPS_COUNT (0)
+/* @brief AOI availability on the SoC. */
+#define FSL_FEATURE_SOC_AOI_COUNT (0)
+/* @brief AXBS availability on the SoC. */
+#define FSL_FEATURE_SOC_AXBS_COUNT (0)
+/* @brief ASMC availability on the SoC. */
+#define FSL_FEATURE_SOC_ASMC_COUNT (0)
+/* @brief CADC availability on the SoC. */
+#define FSL_FEATURE_SOC_CADC_COUNT (0)
+/* @brief FLEXCAN availability on the SoC. */
+#define FSL_FEATURE_SOC_FLEXCAN_COUNT (0)
+/* @brief MMCAU availability on the SoC. */
+#define FSL_FEATURE_SOC_MMCAU_COUNT (0)
+/* @brief CMP availability on the SoC. */
+#define FSL_FEATURE_SOC_CMP_COUNT (1)
+/* @brief CMT availability on the SoC. */
+#define FSL_FEATURE_SOC_CMT_COUNT (0)
+/* @brief CNC availability on the SoC. */
+#define FSL_FEATURE_SOC_CNC_COUNT (0)
+/* @brief CRC availability on the SoC. */
+#define FSL_FEATURE_SOC_CRC_COUNT (0)
+/* @brief DAC availability on the SoC. */
+#define FSL_FEATURE_SOC_DAC_COUNT (0)
+/* @brief DAC32 availability on the SoC. */
+#define FSL_FEATURE_SOC_DAC32_COUNT (0)
+/* @brief DCDC availability on the SoC. */
+#define FSL_FEATURE_SOC_DCDC_COUNT (0)
+/* @brief DDR availability on the SoC. */
+#define FSL_FEATURE_SOC_DDR_COUNT (0)
+/* @brief DMA availability on the SoC. */
+#define FSL_FEATURE_SOC_DMA_COUNT (0)
+/* @brief EDMA availability on the SoC. */
+#define FSL_FEATURE_SOC_EDMA_COUNT (0)
+/* @brief DMAMUX availability on the SoC. */
+#define FSL_FEATURE_SOC_DMAMUX_COUNT (0)
+/* @brief DRY availability on the SoC. */
+#define FSL_FEATURE_SOC_DRY_COUNT (0)
+/* @brief DSPI availability on the SoC. */
+#define FSL_FEATURE_SOC_DSPI_COUNT (0)
+/* @brief EMVSIM availability on the SoC. */
+#define FSL_FEATURE_SOC_EMVSIM_COUNT (0)
+/* @brief ENC availability on the SoC. */
+#define FSL_FEATURE_SOC_ENC_COUNT (0)
+/* @brief ENET availability on the SoC. */
+#define FSL_FEATURE_SOC_ENET_COUNT (0)
+/* @brief EWM availability on the SoC. */
+#define FSL_FEATURE_SOC_EWM_COUNT (0)
+/* @brief FB availability on the SoC. */
+#define FSL_FEATURE_SOC_FB_COUNT (0)
+/* @brief FGPIO availability on the SoC. */
+#define FSL_FEATURE_SOC_FGPIO_COUNT (2)
+/* @brief FLEXIO availability on the SoC. */
+#define FSL_FEATURE_SOC_FLEXIO_COUNT (0)
+/* @brief FMC availability on the SoC. */
+#define FSL_FEATURE_SOC_FMC_COUNT (0)
+/* @brief FSKDT availability on the SoC. */
+#define FSL_FEATURE_SOC_FSKDT_COUNT (0)
+/* @brief FTFA availability on the SoC. */
+#define FSL_FEATURE_SOC_FTFA_COUNT (1)
+/* @brief FTFE availability on the SoC. */
+#define FSL_FEATURE_SOC_FTFE_COUNT (0)
+/* @brief FTFL availability on the SoC. */
+#define FSL_FEATURE_SOC_FTFL_COUNT (0)
+/* @brief FTM availability on the SoC. */
+#define FSL_FEATURE_SOC_FTM_COUNT (0)
+/* @brief FTMRA availability on the SoC. */
+#define FSL_FEATURE_SOC_FTMRA_COUNT (0)
+/* @brief FTMRE availability on the SoC. */
+#define FSL_FEATURE_SOC_FTMRE_COUNT (0)
+/* @brief FTMRH availability on the SoC. */
+#define FSL_FEATURE_SOC_FTMRH_COUNT (0)
+/* @brief GPIO availability on the SoC. */
+#define FSL_FEATURE_SOC_GPIO_COUNT (2)
+/* @brief HSADC availability on the SoC. */
+#define FSL_FEATURE_SOC_HSADC_COUNT (0)
+/* @brief I2C availability on the SoC. */
+#define FSL_FEATURE_SOC_I2C_COUNT (1)
+/* @brief I2S availability on the SoC. */
+#define FSL_FEATURE_SOC_I2S_COUNT (0)
+/* @brief ICS availability on the SoC. */
+#define FSL_FEATURE_SOC_ICS_COUNT (0)
+/* @brief INTMUX availability on the SoC. */
+#define FSL_FEATURE_SOC_INTMUX_COUNT (0)
+/* @brief IRQ availability on the SoC. */
+#define FSL_FEATURE_SOC_IRQ_COUNT (0)
+/* @brief KBI availability on the SoC. */
+#define FSL_FEATURE_SOC_KBI_COUNT (0)
+/* @brief SLCD availability on the SoC. */
+#define FSL_FEATURE_SOC_SLCD_COUNT (0)
+/* @brief LCDC availability on the SoC. */
+#define FSL_FEATURE_SOC_LCDC_COUNT (0)
+/* @brief LDO availability on the SoC. */
+#define FSL_FEATURE_SOC_LDO_COUNT (0)
+/* @brief LLWU availability on the SoC. */
+#define FSL_FEATURE_SOC_LLWU_COUNT (1)
+/* @brief LMEM availability on the SoC. */
+#define FSL_FEATURE_SOC_LMEM_COUNT (0)
+/* @brief LPI2C availability on the SoC. */
+#define FSL_FEATURE_SOC_LPI2C_COUNT (0)
+/* @brief LPIT availability on the SoC. */
+#define FSL_FEATURE_SOC_LPIT_COUNT (0)
+/* @brief LPSCI availability on the SoC. */
+#define FSL_FEATURE_SOC_LPSCI_COUNT (0)
+/* @brief LPSPI availability on the SoC. */
+#define FSL_FEATURE_SOC_LPSPI_COUNT (0)
+/* @brief LPTMR availability on the SoC. */
+#define FSL_FEATURE_SOC_LPTMR_COUNT (1)
+/* @brief LPTPM availability on the SoC. */
+#define FSL_FEATURE_SOC_LPTPM_COUNT (0)
+/* @brief LPUART availability on the SoC. */
+#define FSL_FEATURE_SOC_LPUART_COUNT (1)
+/* @brief LTC availability on the SoC. */
+#define FSL_FEATURE_SOC_LTC_COUNT (0)
+/* @brief MC availability on the SoC. */
+#define FSL_FEATURE_SOC_MC_COUNT (0)
+/* @brief MCG availability on the SoC. */
+#define FSL_FEATURE_SOC_MCG_COUNT (0)
+/* @brief MCGLITE availability on the SoC. */
+#define FSL_FEATURE_SOC_MCGLITE_COUNT (1)
+/* @brief MCM availability on the SoC. */
+#define FSL_FEATURE_SOC_MCM_COUNT (1)
+/* @brief MMAU availability on the SoC. */
+#define FSL_FEATURE_SOC_MMAU_COUNT (0)
+/* @brief MMDVSQ availability on the SoC. */
+#define FSL_FEATURE_SOC_MMDVSQ_COUNT (0)
+/* @brief SYSMPU availability on the SoC. */
+#define FSL_FEATURE_SOC_SYSMPU_COUNT (0)
+/* @brief MSCAN availability on the SoC. */
+#define FSL_FEATURE_SOC_MSCAN_COUNT (0)
+/* @brief MSCM availability on the SoC. */
+#define FSL_FEATURE_SOC_MSCM_COUNT (0)
+/* @brief MTB availability on the SoC. */
+#define FSL_FEATURE_SOC_MTB_COUNT (1)
+/* @brief MTBDWT availability on the SoC. */
+#define FSL_FEATURE_SOC_MTBDWT_COUNT (1)
+/* @brief MU availability on the SoC. */
+#define FSL_FEATURE_SOC_MU_COUNT (0)
+/* @brief NFC availability on the SoC. */
+#define FSL_FEATURE_SOC_NFC_COUNT (0)
+/* @brief OPAMP availability on the SoC. */
+#define FSL_FEATURE_SOC_OPAMP_COUNT (0)
+/* @brief OSC availability on the SoC. */
+#define FSL_FEATURE_SOC_OSC_COUNT (1)
+/* @brief OSC32 availability on the SoC. */
+#define FSL_FEATURE_SOC_OSC32_COUNT (0)
+/* @brief OTFAD availability on the SoC. */
+#define FSL_FEATURE_SOC_OTFAD_COUNT (0)
+/* @brief PDB availability on the SoC. */
+#define FSL_FEATURE_SOC_PDB_COUNT (0)
+/* @brief PCC availability on the SoC. */
+#define FSL_FEATURE_SOC_PCC_COUNT (0)
+/* @brief PGA availability on the SoC. */
+#define FSL_FEATURE_SOC_PGA_COUNT (0)
+/* @brief PIT availability on the SoC. */
+#define FSL_FEATURE_SOC_PIT_COUNT (0)
+/* @brief PMC availability on the SoC. */
+#define FSL_FEATURE_SOC_PMC_COUNT (1)
+/* @brief PORT availability on the SoC. */
+#define FSL_FEATURE_SOC_PORT_COUNT (2)
+/* @brief PWM availability on the SoC. */
+#define FSL_FEATURE_SOC_PWM_COUNT (0)
+/* @brief PWT availability on the SoC. */
+#define FSL_FEATURE_SOC_PWT_COUNT (0)
+/* @brief QuadSPI availability on the SoC. */
+#define FSL_FEATURE_SOC_QuadSPI_COUNT (0)
+/* @brief RCM availability on the SoC. */
+#define FSL_FEATURE_SOC_RCM_COUNT (1)
+/* @brief RFSYS availability on the SoC. */
+#define FSL_FEATURE_SOC_RFSYS_COUNT (1)
+/* @brief RFVBAT availability on the SoC. */
+#define FSL_FEATURE_SOC_RFVBAT_COUNT (0)
+/* @brief RNG availability on the SoC. */
+#define FSL_FEATURE_SOC_RNG_COUNT (0)
+/* @brief RNGB availability on the SoC. */
+#define FSL_FEATURE_SOC_RNGB_COUNT (0)
+/* @brief ROM availability on the SoC. */
+#define FSL_FEATURE_SOC_ROM_COUNT (1)
+/* @brief RSIM availability on the SoC. */
+#define FSL_FEATURE_SOC_RSIM_COUNT (0)
+/* @brief RTC availability on the SoC. */
+#define FSL_FEATURE_SOC_RTC_COUNT (1)
+/* @brief SCG availability on the SoC. */
+#define FSL_FEATURE_SOC_SCG_COUNT (0)
+/* @brief SCI availability on the SoC. */
+#define FSL_FEATURE_SOC_SCI_COUNT (0)
+/* @brief SDHC availability on the SoC. */
+#define FSL_FEATURE_SOC_SDHC_COUNT (0)
+/* @brief SDRAM availability on the SoC. */
+#define FSL_FEATURE_SOC_SDRAM_COUNT (0)
+/* @brief SEMA42 availability on the SoC. */
+#define FSL_FEATURE_SOC_SEMA42_COUNT (0)
+/* @brief SIM availability on the SoC. */
+#define FSL_FEATURE_SOC_SIM_COUNT (1)
+/* @brief SMC availability on the SoC. */
+#define FSL_FEATURE_SOC_SMC_COUNT (1)
+/* @brief SPI availability on the SoC. */
+#define FSL_FEATURE_SOC_SPI_COUNT (1)
+/* @brief TMR availability on the SoC. */
+#define FSL_FEATURE_SOC_TMR_COUNT (0)
+/* @brief TPM availability on the SoC. */
+#define FSL_FEATURE_SOC_TPM_COUNT (2)
+/* @brief TRGMUX availability on the SoC. */
+#define FSL_FEATURE_SOC_TRGMUX_COUNT (0)
+/* @brief TRIAMP availability on the SoC. */
+#define FSL_FEATURE_SOC_TRIAMP_COUNT (0)
+/* @brief TRNG availability on the SoC. */
+#define FSL_FEATURE_SOC_TRNG_COUNT (0)
+/* @brief TSI availability on the SoC. */
+#define FSL_FEATURE_SOC_TSI_COUNT (0)
+/* @brief TSTMR availability on the SoC. */
+#define FSL_FEATURE_SOC_TSTMR_COUNT (0)
+/* @brief UART availability on the SoC. */
+#define FSL_FEATURE_SOC_UART_COUNT (0)
+/* @brief USB availability on the SoC. */
+#define FSL_FEATURE_SOC_USB_COUNT (0)
+/* @brief USBDCD availability on the SoC. */
+#define FSL_FEATURE_SOC_USBDCD_COUNT (0)
+/* @brief USBHS availability on the SoC. */
+#define FSL_FEATURE_SOC_USBHS_COUNT (0)
+/* @brief USBHSDCD availability on the SoC. */
+#define FSL_FEATURE_SOC_USBHSDCD_COUNT (0)
+/* @brief USBPHY availability on the SoC. */
+#define FSL_FEATURE_SOC_USBPHY_COUNT (0)
+/* @brief VREF availability on the SoC. */
+#define FSL_FEATURE_SOC_VREF_COUNT (1)
+/* @brief WDOG availability on the SoC. */
+#define FSL_FEATURE_SOC_WDOG_COUNT (0)
+/* @brief XBAR availability on the SoC. */
+#define FSL_FEATURE_SOC_XBAR_COUNT (0)
+/* @brief XBARA availability on the SoC. */
+#define FSL_FEATURE_SOC_XBARA_COUNT (0)
+/* @brief XBARB availability on the SoC. */
+#define FSL_FEATURE_SOC_XBARB_COUNT (0)
+/* @brief XCVR availability on the SoC. */
+#define FSL_FEATURE_SOC_XCVR_COUNT (0)
+/* @brief XRDC availability on the SoC. */
+#define FSL_FEATURE_SOC_XRDC_COUNT (0)
+/* @brief ZLL availability on the SoC. */
+#define FSL_FEATURE_SOC_ZLL_COUNT (0)
+
+/* ADC16 module features */
+
+/* @brief Has Programmable Gain Amplifier (PGA) in ADC (register PGA). */
+#define FSL_FEATURE_ADC16_HAS_PGA (0)
+/* @brief Has PGA chopping control in ADC (bit PGA[PGACHPb] or PGA[PGACHP]). */
+#define FSL_FEATURE_ADC16_HAS_PGA_CHOPPING (0)
+/* @brief Has PGA offset measurement mode in ADC (bit PGA[PGAOFSM]). */
+#define FSL_FEATURE_ADC16_HAS_PGA_OFFSET_MEASUREMENT (0)
+/* @brief Has DMA support (bit SC2[DMAEN] or SC4[DMAEN]). */
+#define FSL_FEATURE_ADC16_HAS_DMA (0)
+/* @brief Has differential mode (bitfield SC1x[DIFF]). */
+#define FSL_FEATURE_ADC16_HAS_DIFF_MODE (0)
+/* @brief Has FIFO (bit SC4[AFDEP]). */
+#define FSL_FEATURE_ADC16_HAS_FIFO (0)
+/* @brief FIFO size if available (bitfield SC4[AFDEP]). */
+#define FSL_FEATURE_ADC16_FIFO_SIZE (0)
+/* @brief Has channel set a/b multiplexor (bitfield CFG2[MUXSEL]). */
+#define FSL_FEATURE_ADC16_HAS_MUX_SELECT (1)
+/* @brief Has HW trigger masking (bitfield SC5[HTRGMASKE]. */
+#define FSL_FEATURE_ADC16_HAS_HW_TRIGGER_MASK (0)
+/* @brief Has calibration feature (bit SC3[CAL] and registers CLPx, CLMx). */
+#define FSL_FEATURE_ADC16_HAS_CALIBRATION (1)
+/* @brief Has HW averaging (bit SC3[AVGE]). */
+#define FSL_FEATURE_ADC16_HAS_HW_AVERAGE (1)
+/* @brief Has offset correction (register OFS). */
+#define FSL_FEATURE_ADC16_HAS_OFFSET_CORRECTION (1)
+/* @brief Maximum ADC resolution. */
+#define FSL_FEATURE_ADC16_MAX_RESOLUTION (12)
+/* @brief Number of SC1x and Rx register pairs (conversion control and result registers). */
+#define FSL_FEATURE_ADC16_CONVERSION_CONTROL_COUNT (2)
+
+/* CMP module features */
+
+/* @brief Has Trigger mode in CMP (register bit field CR1[TRIGM]). */
+#define FSL_FEATURE_CMP_HAS_TRIGGER_MODE (1)
+/* @brief Has Window mode in CMP (register bit field CR1[WE]). */
+#define FSL_FEATURE_CMP_HAS_WINDOW_MODE (0)
+/* @brief Has External sample supported in CMP (register bit field CR1[SE]). */
+#define FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT (0)
+/* @brief Has DMA support in CMP (register bit field SCR[DMAEN]). */
+#define FSL_FEATURE_CMP_HAS_DMA (0)
+/* @brief Has Pass Through mode in CMP (register bit field MUXCR[PSTM]). */
+#define FSL_FEATURE_CMP_HAS_PASS_THROUGH_MODE (0)
+/* @brief Has DAC Test function in CMP (register DACTEST). */
+#define FSL_FEATURE_CMP_HAS_DAC_TEST (0)
+
+/* COP module features */
+
+/* @brief Has the COP Debug Enable bit (COPC[COPDBGEN]) */
+#define FSL_FEATURE_COP_HAS_DEBUG_ENABLE (1)
+/* @brief Has the COP Stop mode Enable bit (COPC[COPSTPEN]) */
+#define FSL_FEATURE_COP_HAS_STOP_ENABLE (1)
+/* @brief Has more clock sources like MCGIRC */
+#define FSL_FEATURE_COP_HAS_MORE_CLKSRC (1)
+/* @brief Has the timeout long and short mode bit (COPC[COPCLKS]) */
+#define FSL_FEATURE_COP_HAS_LONGTIME_MODE (1)
+
+/* FLASH module features */
+
+#if defined(CPU_MKL03Z16VFG4) || defined(CPU_MKL03Z16VFK4)
+    /* @brief Is of type FTFA. */
+    #define FSL_FEATURE_FLASH_IS_FTFA (1)
+    /* @brief Is of type FTFE. */
+    #define FSL_FEATURE_FLASH_IS_FTFE (0)
+    /* @brief Is of type FTFL. */
+    #define FSL_FEATURE_FLASH_IS_FTFL (0)
+    /* @brief Has flags indicating the status of the FlexRAM (register bits FCNFG[EEERDY], FCNFG[RAMRDY] and FCNFG[PFLSH]). */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_RAM_FLAGS (0)
+    /* @brief Has program flash swapping status flag (register bit FCNFG[SWAP]). */
+    #define FSL_FEATURE_FLASH_HAS_PFLASH_SWAPPING_STATUS_FLAG (0)
+    /* @brief Has EEPROM region protection (register FEPROT). */
+    #define FSL_FEATURE_FLASH_HAS_EEROM_REGION_PROTECTION (0)
+    /* @brief Has data flash region protection (register FDPROT). */
+    #define FSL_FEATURE_FLASH_HAS_DATA_FLASH_REGION_PROTECTION (0)
+    /* @brief Has flash access control (registers XACCHn, SACCHn, where n is a number, FACSS and FACSN). */
+    #define FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL (0)
+    /* @brief Has flash cache control in FMC module. */
+    #define FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has flash cache control in MCM module. */
+    #define FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has flash cache control in MSCM module. */
+    #define FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has prefetch speculation control in flash, such as kv5x. */
+    #define FSL_FEATURE_FLASH_PREFETCH_SPECULATION_CONTROL_IN_FLASH (0)
+    /* @brief P-Flash flash size coding rule version, value 0 for K1 and K2, value 1 for K3. */
+    #define FSL_FEATURE_FLASH_SIZE_ENCODING_RULE_VERSION (0)
+    /* @brief P-Flash start address. */
+    #define FSL_FEATURE_FLASH_PFLASH_START_ADDRESS (0x00000000)
+    /* @brief P-Flash block count. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT (1)
+    /* @brief P-Flash block size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_SIZE (16384)
+    /* @brief P-Flash sector size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_SECTOR_SIZE (1024)
+    /* @brief P-Flash write unit size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE (4)
+    /* @brief P-Flash data path width. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_DATA_PATH_WIDTH (4)
+    /* @brief P-Flash block swap feature. */
+    #define FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP (0)
+    /* @brief P-Flash protection region count. */
+    #define FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT (32)
+    /* @brief Has FlexNVM memory. */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_NVM (0)
+    /* @brief FlexNVM start address. (Valid only if FlexNVM is available.) */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_START_ADDRESS (0x00000000)
+    /* @brief FlexNVM block count. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT (0)
+    /* @brief FlexNVM block size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SIZE (0)
+    /* @brief FlexNVM sector size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE (0)
+    /* @brief FlexNVM write unit size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_WRITE_UNIT_SIZE (0)
+    /* @brief FlexNVM data path width. */
+    #define FSL_FEATURE_FLASH_FLEX_BLOCK_DATA_PATH_WIDTH (0)
+    /* @brief Has FlexRAM memory. */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_RAM (0)
+    /* @brief FlexRAM start address. (Valid only if FlexRAM is available.) */
+    #define FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS (0x00000000)
+    /* @brief FlexRAM size. */
+    #define FSL_FEATURE_FLASH_FLEX_RAM_SIZE (0)
+    /* @brief Has 0x00 Read 1s Block command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_BLOCK_CMD (0)
+    /* @brief Has 0x01 Read 1s Section command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_SECTION_CMD (1)
+    /* @brief Has 0x02 Program Check command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_CHECK_CMD (1)
+    /* @brief Has 0x03 Read Resource command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD (1)
+    /* @brief Has 0x06 Program Longword command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_LONGWORD_CMD (1)
+    /* @brief Has 0x07 Program Phrase command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_PHRASE_CMD (0)
+    /* @brief Has 0x08 Erase Flash Block command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_FLASH_BLOCK_CMD (0)
+    /* @brief Has 0x09 Erase Flash Sector command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_FLASH_SECTOR_CMD (1)
+    /* @brief Has 0x0B Program Section command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD (0)
+    /* @brief Has 0x40 Read 1s All Blocks command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_ALL_BLOCKS_CMD (1)
+    /* @brief Has 0x41 Read Once command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_ONCE_CMD (1)
+    /* @brief Has 0x43 Program Once command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_ONCE_CMD (1)
+    /* @brief Has 0x44 Erase All Blocks command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_CMD (1)
+    /* @brief Has 0x45 Verify Backdoor Access Key command. */
+    #define FSL_FEATURE_FLASH_HAS_VERIFY_BACKDOOR_ACCESS_KEY_CMD (1)
+    /* @brief Has 0x46 Swap Control command. */
+    #define FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD (0)
+    /* @brief Has 0x49 Erase All Blocks Unsecure command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD (1)
+    /* @brief Has 0x4A Read 1s All Execute-only Segments command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_ALL_EXECUTE_ONLY_SEGMENTS_CMD (0)
+    /* @brief Has 0x4B Erase All Execute-only Segments command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_EXECUTE_ONLY_SEGMENTS_CMD (0)
+    /* @brief Has 0x80 Program Partition command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD (0)
+    /* @brief Has 0x81 Set FlexRAM Function command. */
+    #define FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD (0)
+    /* @brief P-Flash Erase/Read 1st all block command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Erase sector command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Rrogram/Verify section command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Read resource command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_RESOURCE_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_CHECK_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Erase/Read 1st all block command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Erase sector command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_SECTOR_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Rrogram/Verify section command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_SECTION_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Read resource command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_RESOURCE_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_CHECK_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM partition code 0000 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0001 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0010 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0011 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0100 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0101 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0110 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0111 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1000 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1001 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1010 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1011 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1100 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1101 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1110 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1111 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 (0xFFFFFFFF)
+    /* @brief Emulated eeprom size code 0000 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0000 (0xFFFF)
+    /* @brief Emulated eeprom size code 0001 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0001 (0xFFFF)
+    /* @brief Emulated eeprom size code 0010 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0010 (0xFFFF)
+    /* @brief Emulated eeprom size code 0011 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0011 (0xFFFF)
+    /* @brief Emulated eeprom size code 0100 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0100 (0xFFFF)
+    /* @brief Emulated eeprom size code 0101 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0101 (0xFFFF)
+    /* @brief Emulated eeprom size code 0110 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0110 (0xFFFF)
+    /* @brief Emulated eeprom size code 0111 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0111 (0xFFFF)
+    /* @brief Emulated eeprom size code 1000 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1000 (0xFFFF)
+    /* @brief Emulated eeprom size code 1001 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1001 (0xFFFF)
+    /* @brief Emulated eeprom size code 1010 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1010 (0xFFFF)
+    /* @brief Emulated eeprom size code 1011 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1011 (0xFFFF)
+    /* @brief Emulated eeprom size code 1100 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1100 (0xFFFF)
+    /* @brief Emulated eeprom size code 1101 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1101 (0xFFFF)
+    /* @brief Emulated eeprom size code 1110 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1110 (0xFFFF)
+    /* @brief Emulated eeprom size code 1111 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1111 (0xFFFF)
+#elif defined(CPU_MKL03Z32CAF4) || defined(CPU_MKL03Z32VFG4) || defined(CPU_MKL03Z32VFK4)
+    /* @brief Is of type FTFA. */
+    #define FSL_FEATURE_FLASH_IS_FTFA (1)
+    /* @brief Is of type FTFE. */
+    #define FSL_FEATURE_FLASH_IS_FTFE (0)
+    /* @brief Is of type FTFL. */
+    #define FSL_FEATURE_FLASH_IS_FTFL (0)
+    /* @brief Has flags indicating the status of the FlexRAM (register bits FCNFG[EEERDY], FCNFG[RAMRDY] and FCNFG[PFLSH]). */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_RAM_FLAGS (0)
+    /* @brief Has program flash swapping status flag (register bit FCNFG[SWAP]). */
+    #define FSL_FEATURE_FLASH_HAS_PFLASH_SWAPPING_STATUS_FLAG (0)
+    /* @brief Has EEPROM region protection (register FEPROT). */
+    #define FSL_FEATURE_FLASH_HAS_EEROM_REGION_PROTECTION (0)
+    /* @brief Has data flash region protection (register FDPROT). */
+    #define FSL_FEATURE_FLASH_HAS_DATA_FLASH_REGION_PROTECTION (0)
+    /* @brief Has flash access control (registers XACCHn, SACCHn, where n is a number, FACSS and FACSN). */
+    #define FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL (0)
+    /* @brief Has flash cache control in FMC module. */
+    #define FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has flash cache control in MCM module. */
+    #define FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has flash cache control in MSCM module. */
+    #define FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has prefetch speculation control in flash, such as kv5x. */
+    #define FSL_FEATURE_FLASH_PREFETCH_SPECULATION_CONTROL_IN_FLASH (0)
+    /* @brief P-Flash flash size coding rule version, value 0 for K1 and K2, value 1 for K3. */
+    #define FSL_FEATURE_FLASH_SIZE_ENCODING_RULE_VERSION (0)
+    /* @brief P-Flash start address. */
+    #define FSL_FEATURE_FLASH_PFLASH_START_ADDRESS (0x00000000)
+    /* @brief P-Flash block count. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT (1)
+    /* @brief P-Flash block size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_SIZE (32768)
+    /* @brief P-Flash sector size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_SECTOR_SIZE (1024)
+    /* @brief P-Flash write unit size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE (4)
+    /* @brief P-Flash data path width. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_DATA_PATH_WIDTH (4)
+    /* @brief P-Flash block swap feature. */
+    #define FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP (0)
+    /* @brief P-Flash protection region count. */
+    #define FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT (32)
+    /* @brief Has FlexNVM memory. */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_NVM (0)
+    /* @brief FlexNVM start address. (Valid only if FlexNVM is available.) */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_START_ADDRESS (0x00000000)
+    /* @brief FlexNVM block count. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT (0)
+    /* @brief FlexNVM block size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SIZE (0)
+    /* @brief FlexNVM sector size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE (0)
+    /* @brief FlexNVM write unit size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_WRITE_UNIT_SIZE (0)
+    /* @brief FlexNVM data path width. */
+    #define FSL_FEATURE_FLASH_FLEX_BLOCK_DATA_PATH_WIDTH (0)
+    /* @brief Has FlexRAM memory. */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_RAM (0)
+    /* @brief FlexRAM start address. (Valid only if FlexRAM is available.) */
+    #define FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS (0x00000000)
+    /* @brief FlexRAM size. */
+    #define FSL_FEATURE_FLASH_FLEX_RAM_SIZE (0)
+    /* @brief Has 0x00 Read 1s Block command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_BLOCK_CMD (0)
+    /* @brief Has 0x01 Read 1s Section command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_SECTION_CMD (1)
+    /* @brief Has 0x02 Program Check command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_CHECK_CMD (1)
+    /* @brief Has 0x03 Read Resource command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD (1)
+    /* @brief Has 0x06 Program Longword command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_LONGWORD_CMD (1)
+    /* @brief Has 0x07 Program Phrase command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_PHRASE_CMD (0)
+    /* @brief Has 0x08 Erase Flash Block command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_FLASH_BLOCK_CMD (0)
+    /* @brief Has 0x09 Erase Flash Sector command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_FLASH_SECTOR_CMD (1)
+    /* @brief Has 0x0B Program Section command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD (0)
+    /* @brief Has 0x40 Read 1s All Blocks command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_ALL_BLOCKS_CMD (1)
+    /* @brief Has 0x41 Read Once command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_ONCE_CMD (1)
+    /* @brief Has 0x43 Program Once command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_ONCE_CMD (1)
+    /* @brief Has 0x44 Erase All Blocks command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_CMD (1)
+    /* @brief Has 0x45 Verify Backdoor Access Key command. */
+    #define FSL_FEATURE_FLASH_HAS_VERIFY_BACKDOOR_ACCESS_KEY_CMD (1)
+    /* @brief Has 0x46 Swap Control command. */
+    #define FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD (0)
+    /* @brief Has 0x49 Erase All Blocks Unsecure command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD (1)
+    /* @brief Has 0x4A Read 1s All Execute-only Segments command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_ALL_EXECUTE_ONLY_SEGMENTS_CMD (0)
+    /* @brief Has 0x4B Erase All Execute-only Segments command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_EXECUTE_ONLY_SEGMENTS_CMD (0)
+    /* @brief Has 0x80 Program Partition command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD (0)
+    /* @brief Has 0x81 Set FlexRAM Function command. */
+    #define FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD (0)
+    /* @brief P-Flash Erase/Read 1st all block command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Erase sector command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Rrogram/Verify section command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Read resource command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_RESOURCE_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_CHECK_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Erase/Read 1st all block command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Erase sector command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_SECTOR_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Rrogram/Verify section command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_SECTION_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Read resource command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_RESOURCE_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_CHECK_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM partition code 0000 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0001 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0010 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0011 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0100 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0101 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0110 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0111 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1000 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1001 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1010 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1011 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1100 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1101 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1110 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1111 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 (0xFFFFFFFF)
+    /* @brief Emulated eeprom size code 0000 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0000 (0xFFFF)
+    /* @brief Emulated eeprom size code 0001 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0001 (0xFFFF)
+    /* @brief Emulated eeprom size code 0010 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0010 (0xFFFF)
+    /* @brief Emulated eeprom size code 0011 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0011 (0xFFFF)
+    /* @brief Emulated eeprom size code 0100 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0100 (0xFFFF)
+    /* @brief Emulated eeprom size code 0101 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0101 (0xFFFF)
+    /* @brief Emulated eeprom size code 0110 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0110 (0xFFFF)
+    /* @brief Emulated eeprom size code 0111 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0111 (0xFFFF)
+    /* @brief Emulated eeprom size code 1000 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1000 (0xFFFF)
+    /* @brief Emulated eeprom size code 1001 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1001 (0xFFFF)
+    /* @brief Emulated eeprom size code 1010 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1010 (0xFFFF)
+    /* @brief Emulated eeprom size code 1011 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1011 (0xFFFF)
+    /* @brief Emulated eeprom size code 1100 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1100 (0xFFFF)
+    /* @brief Emulated eeprom size code 1101 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1101 (0xFFFF)
+    /* @brief Emulated eeprom size code 1110 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1110 (0xFFFF)
+    /* @brief Emulated eeprom size code 1111 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1111 (0xFFFF)
+#elif defined(CPU_MKL03Z8VFG4) || defined(CPU_MKL03Z8VFK4)
+    /* @brief Is of type FTFA. */
+    #define FSL_FEATURE_FLASH_IS_FTFA (1)
+    /* @brief Is of type FTFE. */
+    #define FSL_FEATURE_FLASH_IS_FTFE (0)
+    /* @brief Is of type FTFL. */
+    #define FSL_FEATURE_FLASH_IS_FTFL (0)
+    /* @brief Has flags indicating the status of the FlexRAM (register bits FCNFG[EEERDY], FCNFG[RAMRDY] and FCNFG[PFLSH]). */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_RAM_FLAGS (0)
+    /* @brief Has program flash swapping status flag (register bit FCNFG[SWAP]). */
+    #define FSL_FEATURE_FLASH_HAS_PFLASH_SWAPPING_STATUS_FLAG (0)
+    /* @brief Has EEPROM region protection (register FEPROT). */
+    #define FSL_FEATURE_FLASH_HAS_EEROM_REGION_PROTECTION (0)
+    /* @brief Has data flash region protection (register FDPROT). */
+    #define FSL_FEATURE_FLASH_HAS_DATA_FLASH_REGION_PROTECTION (0)
+    /* @brief Has flash access control (registers XACCHn, SACCHn, where n is a number, FACSS and FACSN). */
+    #define FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL (0)
+    /* @brief Has flash cache control in FMC module. */
+    #define FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has flash cache control in MCM module. */
+    #define FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has flash cache control in MSCM module. */
+    #define FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS (0)
+    /* @brief Has prefetch speculation control in flash, such as kv5x. */
+    #define FSL_FEATURE_FLASH_PREFETCH_SPECULATION_CONTROL_IN_FLASH (0)
+    /* @brief P-Flash flash size coding rule version, value 0 for K1 and K2, value 1 for K3. */
+    #define FSL_FEATURE_FLASH_SIZE_ENCODING_RULE_VERSION (0)
+    /* @brief P-Flash start address. */
+    #define FSL_FEATURE_FLASH_PFLASH_START_ADDRESS (0x00000000)
+    /* @brief P-Flash block count. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT (1)
+    /* @brief P-Flash block size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_SIZE (8192)
+    /* @brief P-Flash sector size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_SECTOR_SIZE (1024)
+    /* @brief P-Flash write unit size. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE (4)
+    /* @brief P-Flash data path width. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_DATA_PATH_WIDTH (4)
+    /* @brief P-Flash block swap feature. */
+    #define FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP (0)
+    /* @brief P-Flash protection region count. */
+    #define FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT (32)
+    /* @brief Has FlexNVM memory. */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_NVM (0)
+    /* @brief FlexNVM start address. (Valid only if FlexNVM is available.) */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_START_ADDRESS (0x00000000)
+    /* @brief FlexNVM block count. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT (0)
+    /* @brief FlexNVM block size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SIZE (0)
+    /* @brief FlexNVM sector size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE (0)
+    /* @brief FlexNVM write unit size. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_WRITE_UNIT_SIZE (0)
+    /* @brief FlexNVM data path width. */
+    #define FSL_FEATURE_FLASH_FLEX_BLOCK_DATA_PATH_WIDTH (0)
+    /* @brief Has FlexRAM memory. */
+    #define FSL_FEATURE_FLASH_HAS_FLEX_RAM (0)
+    /* @brief FlexRAM start address. (Valid only if FlexRAM is available.) */
+    #define FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS (0x00000000)
+    /* @brief FlexRAM size. */
+    #define FSL_FEATURE_FLASH_FLEX_RAM_SIZE (0)
+    /* @brief Has 0x00 Read 1s Block command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_BLOCK_CMD (0)
+    /* @brief Has 0x01 Read 1s Section command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_SECTION_CMD (1)
+    /* @brief Has 0x02 Program Check command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_CHECK_CMD (1)
+    /* @brief Has 0x03 Read Resource command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD (1)
+    /* @brief Has 0x06 Program Longword command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_LONGWORD_CMD (1)
+    /* @brief Has 0x07 Program Phrase command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_PHRASE_CMD (0)
+    /* @brief Has 0x08 Erase Flash Block command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_FLASH_BLOCK_CMD (0)
+    /* @brief Has 0x09 Erase Flash Sector command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_FLASH_SECTOR_CMD (1)
+    /* @brief Has 0x0B Program Section command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD (0)
+    /* @brief Has 0x40 Read 1s All Blocks command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_ALL_BLOCKS_CMD (1)
+    /* @brief Has 0x41 Read Once command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_ONCE_CMD (1)
+    /* @brief Has 0x43 Program Once command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_ONCE_CMD (1)
+    /* @brief Has 0x44 Erase All Blocks command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_CMD (1)
+    /* @brief Has 0x45 Verify Backdoor Access Key command. */
+    #define FSL_FEATURE_FLASH_HAS_VERIFY_BACKDOOR_ACCESS_KEY_CMD (1)
+    /* @brief Has 0x46 Swap Control command. */
+    #define FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD (0)
+    /* @brief Has 0x49 Erase All Blocks Unsecure command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD (1)
+    /* @brief Has 0x4A Read 1s All Execute-only Segments command. */
+    #define FSL_FEATURE_FLASH_HAS_READ_1S_ALL_EXECUTE_ONLY_SEGMENTS_CMD (0)
+    /* @brief Has 0x4B Erase All Execute-only Segments command. */
+    #define FSL_FEATURE_FLASH_HAS_ERASE_ALL_EXECUTE_ONLY_SEGMENTS_CMD (0)
+    /* @brief Has 0x80 Program Partition command. */
+    #define FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD (0)
+    /* @brief Has 0x81 Set FlexRAM Function command. */
+    #define FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD (0)
+    /* @brief P-Flash Erase/Read 1st all block command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_BLOCK_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Erase sector command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Rrogram/Verify section command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Read resource command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_RESOURCE_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_CHECK_CMD_ADDRESS_ALIGMENT (4)
+    /* @brief P-Flash Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Erase/Read 1st all block command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Erase sector command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_SECTOR_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Rrogram/Verify section command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_SECTION_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Read resource command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_RESOURCE_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM Program check command address alignment. */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_CHECK_CMD_ADDRESS_ALIGMENT (0)
+    /* @brief FlexNVM partition code 0000 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0001 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0010 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0011 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0100 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0101 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0110 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 0111 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1000 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1001 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1010 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1011 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1100 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1101 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1110 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 (0xFFFFFFFF)
+    /* @brief FlexNVM partition code 1111 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 (0xFFFFFFFF)
+    /* @brief Emulated eeprom size code 0000 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0000 (0xFFFF)
+    /* @brief Emulated eeprom size code 0001 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0001 (0xFFFF)
+    /* @brief Emulated eeprom size code 0010 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0010 (0xFFFF)
+    /* @brief Emulated eeprom size code 0011 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0011 (0xFFFF)
+    /* @brief Emulated eeprom size code 0100 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0100 (0xFFFF)
+    /* @brief Emulated eeprom size code 0101 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0101 (0xFFFF)
+    /* @brief Emulated eeprom size code 0110 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0110 (0xFFFF)
+    /* @brief Emulated eeprom size code 0111 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0111 (0xFFFF)
+    /* @brief Emulated eeprom size code 1000 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1000 (0xFFFF)
+    /* @brief Emulated eeprom size code 1001 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1001 (0xFFFF)
+    /* @brief Emulated eeprom size code 1010 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1010 (0xFFFF)
+    /* @brief Emulated eeprom size code 1011 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1011 (0xFFFF)
+    /* @brief Emulated eeprom size code 1100 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1100 (0xFFFF)
+    /* @brief Emulated eeprom size code 1101 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1101 (0xFFFF)
+    /* @brief Emulated eeprom size code 1110 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1110 (0xFFFF)
+    /* @brief Emulated eeprom size code 1111 mapping to emulated eeprom size in bytes (0xFFFF = reserved). */
+    #define FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1111 (0xFFFF)
+#endif /* defined(CPU_MKL03Z16VFG4) || defined(CPU_MKL03Z16VFK4) */
+
+/* GPIO module features */
+
+/* @brief Has fast (single cycle) access capability via a dedicated memory region. */
+#define FSL_FEATURE_GPIO_HAS_FAST_GPIO (1)
+/* @brief Has port input disable register (PIDR). */
+#define FSL_FEATURE_GPIO_HAS_INPUT_DISABLE (0)
+/* @brief Has dedicated interrupt vector. */
+#define FSL_FEATURE_GPIO_HAS_PORT_INTERRUPT_VECTOR (1)
+
+/* I2C module features */
+
+/* @brief Has System Management Bus support (registers SMB, A2, SLTL and SLTH). */
+#define FSL_FEATURE_I2C_HAS_SMBUS (1)
+/* @brief Maximum supported baud rate in kilobit per second. */
+#define FSL_FEATURE_I2C_MAX_BAUD_KBPS (400)
+/* @brief Is affected by errata with ID 6070 (repeat start cannot be generated if the F[MULT] bit field is set to a non-zero value). */
+#define FSL_FEATURE_I2C_HAS_ERRATA_6070 (0)
+/* @brief Has DMA support (register bit C1[DMAEN]). */
+#define FSL_FEATURE_I2C_HAS_DMA_SUPPORT (0)
+/* @brief Has I2C bus start and stop detection (register bits FLT[SSIE], FLT[STARTF] and FLT[STOPF]). */
+#define FSL_FEATURE_I2C_HAS_START_STOP_DETECT (1)
+/* @brief Has I2C bus stop detection (register bits FLT[STOPIE] and FLT[STOPF]). */
+#define FSL_FEATURE_I2C_HAS_STOP_DETECT (0)
+/* @brief Has I2C bus stop hold off (register bit FLT[SHEN]). */
+#define FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF (1)
+/* @brief Maximum width of the glitch filter in number of bus clocks. */
+#define FSL_FEATURE_I2C_MAX_GLITCH_FILTER_WIDTH (15)
+/* @brief Has control of the drive capability of the I2C pins. */
+#define FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION (0)
+/* @brief Has double buffering support (register S2). */
+#define FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING (1)
+/* @brief Has double buffer enable. */
+#define FSL_FEATURE_I2C_HAS_DOUBLE_BUFFER_ENABLE (0)
+
+/* LLWU module features */
+
+/* @brief Maximum number of pins (maximal index plus one) connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN (8)
+/* @brief Has pins 8-15 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_EXTERNAL_PIN_GROUP2 (0)
+/* @brief Maximum number of internal modules connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE (0)
+/* @brief Number of digital filters. */
+#define FSL_FEATURE_LLWU_HAS_PIN_FILTER (1)
+/* @brief Has MF register. */
+#define FSL_FEATURE_LLWU_HAS_MF (0)
+/* @brief Has PF register. */
+#define FSL_FEATURE_LLWU_HAS_PF (0)
+/* @brief Has possibility to enable reset in low leakage power mode and enable digital filter for RESET pin (register LLWU_RST). */
+#define FSL_FEATURE_LLWU_HAS_RESET_ENABLE (0)
+/* @brief Has no internal module wakeup flag register. */
+#define FSL_FEATURE_LLWU_HAS_NO_INTERNAL_MODULE_WAKEUP_FLAG_REG (0)
+/* @brief Has external pin 0 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN0 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN0_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN0_GPIO_PIN (0)
+/* @brief Has external pin 1 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN1 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN1_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN1_GPIO_PIN (0)
+/* @brief Has external pin 2 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN2 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN2_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN2_GPIO_PIN (0)
+/* @brief Has external pin 3 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN3 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN3_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN3_GPIO_PIN (0)
+/* @brief Has external pin 4 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN4 (1)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN4_GPIO_IDX (GPIOB_IDX)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN4_GPIO_PIN (0)
+/* @brief Has external pin 5 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN5 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN5_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN5_GPIO_PIN (0)
+/* @brief Has external pin 6 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN6 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN6_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN6_GPIO_PIN (0)
+/* @brief Has external pin 7 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN7 (1)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN7_GPIO_IDX (GPIOA_IDX)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN7_GPIO_PIN (0)
+/* @brief Has external pin 8 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN8 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN8_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN8_GPIO_PIN (0)
+/* @brief Has external pin 9 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN9 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN9_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN9_GPIO_PIN (0)
+/* @brief Has external pin 10 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN10 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN10_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN10_GPIO_PIN (0)
+/* @brief Has external pin 11 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN11 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN11_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN11_GPIO_PIN (0)
+/* @brief Has external pin 12 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN12 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN12_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN12_GPIO_PIN (0)
+/* @brief Has external pin 13 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN13 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN13_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN13_GPIO_PIN (0)
+/* @brief Has external pin 14 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN14 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN14_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN14_GPIO_PIN (0)
+/* @brief Has external pin 15 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN15 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN15_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN15_GPIO_PIN (0)
+/* @brief Has external pin 16 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN16 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN16_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN16_GPIO_PIN (0)
+/* @brief Has external pin 17 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN17 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN17_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN17_GPIO_PIN (0)
+/* @brief Has external pin 18 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN18 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN18_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN18_GPIO_PIN (0)
+/* @brief Has external pin 19 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN19 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN19_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN19_GPIO_PIN (0)
+/* @brief Has external pin 20 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN20 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN20_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN20_GPIO_PIN (0)
+/* @brief Has external pin 21 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN21 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN21_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN21_GPIO_PIN (0)
+/* @brief Has external pin 22 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN22 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN22_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN22_GPIO_PIN (0)
+/* @brief Has external pin 23 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN23 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN23_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN23_GPIO_PIN (0)
+/* @brief Has external pin 24 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN24 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN24_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN24_GPIO_PIN (0)
+/* @brief Has external pin 25 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN25 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN25_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN25_GPIO_PIN (0)
+/* @brief Has external pin 26 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN26 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN26_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN26_GPIO_PIN (0)
+/* @brief Has external pin 27 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN27 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN27_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN27_GPIO_PIN (0)
+/* @brief Has external pin 28 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN28 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN28_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN28_GPIO_PIN (0)
+/* @brief Has external pin 29 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN29 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN29_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN29_GPIO_PIN (0)
+/* @brief Has external pin 30 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN30 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN30_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN30_GPIO_PIN (0)
+/* @brief Has external pin 31 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_EXTERNAL_PIN31 (0)
+/* @brief Index of port of external pin. */
+#define FSL_FEATURE_LLWU_PIN31_GPIO_IDX (0)
+/* @brief Number of external pin port on specified port. */
+#define FSL_FEATURE_LLWU_PIN31_GPIO_PIN (0)
+/* @brief Has internal module 0 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE0 (0)
+/* @brief Has internal module 1 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE1 (0)
+/* @brief Has internal module 2 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE2 (0)
+/* @brief Has internal module 3 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE3 (0)
+/* @brief Has internal module 4 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE4 (0)
+/* @brief Has internal module 5 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE5 (0)
+/* @brief Has internal module 6 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE6 (0)
+/* @brief Has internal module 7 connected to LLWU device. */
+#define FSL_FEATURE_LLWU_HAS_INTERNAL_MODULE7 (0)
+/* @brief Has Version ID Register (LLWU_VERID). */
+#define FSL_FEATURE_LLWU_HAS_VERID (0)
+/* @brief Has Parameter Register (LLWU_PARAM). */
+#define FSL_FEATURE_LLWU_HAS_PARAM (0)
+/* @brief Width of registers of the LLWU. */
+#define FSL_FEATURE_LLWU_REG_BITWIDTH (8)
+/* @brief Has DMA Enable register (LLWU_DE). */
+#define FSL_FEATURE_LLWU_HAS_DMA_ENABLE_REG (0)
+
+/* LPTMR module features */
+
+/* @brief Has shared interrupt handler with another LPTMR module. */
+#define FSL_FEATURE_LPTMR_HAS_SHARED_IRQ_HANDLER (0)
+/* @brief Whether LPTMR counter is 32 bits width. */
+#define FSL_FEATURE_LPTMR_CNR_WIDTH_IS_32B (0)
+/* @brief Has timer DMA request enable (register bit CSR[TDRE]). */
+#define FSL_FEATURE_LPTMR_HAS_CSR_TDRE (0)
+
+/* LPUART module features */
+
+/* @brief LPUART0 and LPUART1 has shared interrupt vector. */
+#define FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1 (0)
+/* @brief Has receive FIFO overflow detection (bit field CFIFO[RXOFE]). */
+#define FSL_FEATURE_LPUART_HAS_IRQ_EXTENDED_FUNCTIONS (0)
+/* @brief Has low power features (can be enabled in wait mode via register bit C1[DOZEEN] or CTRL[DOZEEN] if the registers are 32-bit wide). */
+#define FSL_FEATURE_LPUART_HAS_LOW_POWER_UART_SUPPORT (1)
+/* @brief Has extended data register ED (or extra flags in the DATA register if the registers are 32-bit wide). */
+#define FSL_FEATURE_LPUART_HAS_EXTENDED_DATA_REGISTER_FLAGS (1)
+/* @brief Capacity (number of entries) of the transmit/receive FIFO (or zero if no FIFO is available). */
+#define FSL_FEATURE_LPUART_HAS_FIFO (0)
+/* @brief Has 32-bit register MODIR */
+#define FSL_FEATURE_LPUART_HAS_MODIR (0)
+/* @brief Hardware flow control (RTS, CTS) is supported. */
+#define FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT (0)
+/* @brief Infrared (modulation) is supported. */
+#define FSL_FEATURE_LPUART_HAS_IR_SUPPORT (0)
+/* @brief 2 bits long stop bit is available. */
+#define FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT (1)
+/* @brief If 10-bit mode is supported. */
+#define FSL_FEATURE_LPUART_HAS_10BIT_DATA_SUPPORT (1)
+/* @brief If 7-bit mode is supported. */
+#define FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT (0)
+/* @brief Baud rate fine adjustment is available. */
+#define FSL_FEATURE_LPUART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT (0)
+/* @brief Baud rate oversampling is available (has bit fields C4[OSR], C5[BOTHEDGE], C5[RESYNCDIS] or BAUD[OSR], BAUD[BOTHEDGE], BAUD[RESYNCDIS] if the registers are 32-bit wide). */
+#define FSL_FEATURE_LPUART_HAS_BAUD_RATE_OVER_SAMPLING_SUPPORT (1)
+/* @brief Baud rate oversampling is available. */
+#define FSL_FEATURE_LPUART_HAS_RX_RESYNC_SUPPORT (1)
+/* @brief Baud rate oversampling is available. */
+#define FSL_FEATURE_LPUART_HAS_BOTH_EDGE_SAMPLING_SUPPORT (1)
+/* @brief Peripheral type. */
+#define FSL_FEATURE_LPUART_IS_SCI (1)
+/* @brief Capacity (number of entries) of the transmit/receive FIFO (or zero if no FIFO is available). */
+#define FSL_FEATURE_LPUART_FIFO_SIZEn(x) (0)
+/* @brief Maximal data width without parity bit. */
+#define FSL_FEATURE_LPUART_MAX_DATA_WIDTH_WITH_NO_PARITY (10)
+/* @brief Maximal data width with parity bit. */
+#define FSL_FEATURE_LPUART_MAX_DATA_WIDTH_WITH_PARITY (9)
+/* @brief Supports two match addresses to filter incoming frames. */
+#define FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING (1)
+/* @brief Has transmitter/receiver DMA enable bits C5[TDMAE]/C5[RDMAE] (or BAUD[TDMAE]/BAUD[RDMAE] if the registers are 32-bit wide). */
+#define FSL_FEATURE_LPUART_HAS_DMA_ENABLE (0)
+/* @brief Has transmitter/receiver DMA select bits C4[TDMAS]/C4[RDMAS], resp. C5[TDMAS]/C5[RDMAS] if IS_SCI = 0. */
+#define FSL_FEATURE_LPUART_HAS_DMA_SELECT (0)
+/* @brief Data character bit order selection is supported (bit field S2[MSBF] or STAT[MSBF] if the registers are 32-bit wide). */
+#define FSL_FEATURE_LPUART_HAS_BIT_ORDER_SELECT (1)
+/* @brief Has smart card (ISO7816 protocol) support and no improved smart card support. */
+#define FSL_FEATURE_LPUART_HAS_SMART_CARD_SUPPORT (0)
+/* @brief Has improved smart card (ISO7816 protocol) support. */
+#define FSL_FEATURE_LPUART_HAS_IMPROVED_SMART_CARD_SUPPORT (0)
+/* @brief Has local operation network (CEA709.1-B protocol) support. */
+#define FSL_FEATURE_LPUART_HAS_LOCAL_OPERATION_NETWORK_SUPPORT (0)
+/* @brief Has 32-bit registers (BAUD, STAT, CTRL, DATA, MATCH, MODIR) instead of 8-bit (BDH, BDL, C1, S1, D, etc.). */
+#define FSL_FEATURE_LPUART_HAS_32BIT_REGISTERS (1)
+/* @brief Lin break detect available (has bit BAUD[LBKDIE]). */
+#define FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT (1)
+/* @brief UART stops in Wait mode available (has bit C1[UARTSWAI]). */
+#define FSL_FEATURE_LPUART_HAS_WAIT_MODE_OPERATION (0)
+/* @brief Has separate DMA RX and TX requests. */
+#define FSL_FEATURE_LPUART_HAS_SEPARATE_DMA_RX_TX_REQn(x) (0)
+/* @brief Has separate RX and TX interrupts. */
+#define FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ (0)
+/* @brief Has LPAURT_PARAM. */
+#define FSL_FEATURE_LPUART_HAS_PARAM (0)
+/* @brief Has LPUART_VERID. */
+#define FSL_FEATURE_LPUART_HAS_VERID (0)
+/* @brief Has LPUART_GLOBAL. */
+#define FSL_FEATURE_LPUART_HAS_GLOBAL (0)
+/* @brief Has LPUART_PINCFG. */
+#define FSL_FEATURE_LPUART_HAS_PINCFG (0)
+
+/* MCGLITE module features */
+
+/* @brief Defines that clock generator is MCG Lite. */
+#define FSL_FEATURE_MCGLITE_MCGLITE (1)
+/* @brief Has Crystal Oscillator Operation Mode Selection. */
+#define FSL_FEATURE_MCGLITE_HAS_HGO0 (0)
+/* @brief Has HCTRIM register available. */
+#define FSL_FEATURE_MCGLITE_HAS_HCTRIM (0)
+/* @brief Has HTTRIM register available. */
+#define FSL_FEATURE_MCGLITE_HAS_HTTRIM (0)
+/* @brief Has HFTRIM register available. */
+#define FSL_FEATURE_MCGLITE_HAS_HFTRIM (0)
+/* @brief Has LTRIMRNG register available. */
+#define FSL_FEATURE_MCGLITE_HAS_LTRIMRNG (0)
+/* @brief Has LFTRIM register available. */
+#define FSL_FEATURE_MCGLITE_HAS_LFTRIM (0)
+/* @brief Has LSTRIM register available. */
+#define FSL_FEATURE_MCGLITE_HAS_LSTRIM (0)
+/* @brief Has External Clock Source Frequency Range Selection. */
+#define FSL_FEATURE_MCGLITE_HAS_RANGE0 (0)
+
+/* interrupt module features */
+
+/* @brief Lowest interrupt request number. */
+#define FSL_FEATURE_INTERRUPT_IRQ_MIN (-14)
+/* @brief Highest interrupt request number. */
+#define FSL_FEATURE_INTERRUPT_IRQ_MAX (31)
+
+/* OSC module features */
+
+/* @brief Has OSC1 external oscillator. */
+#define FSL_FEATURE_OSC_HAS_OSC1 (0)
+/* @brief Has OSC0 external oscillator. */
+#define FSL_FEATURE_OSC_HAS_OSC0 (0)
+/* @brief Has OSC external oscillator (without index). */
+#define FSL_FEATURE_OSC_HAS_OSC (0)
+/* @brief Number of OSC external oscillators. */
+#define FSL_FEATURE_OSC_OSC_COUNT (0)
+/* @brief Has external reference clock divider (register bit field DIV[ERPS]). */
+#define FSL_FEATURE_OSC_HAS_EXT_REF_CLOCK_DIVIDER (0)
+
+/* PMC module features */
+
+/* @brief Has Bandgap Enable In VLPx Operation support. */
+#define FSL_FEATURE_PMC_HAS_BGEN (1)
+/* @brief Has Bandgap Buffer Enable. */
+#define FSL_FEATURE_PMC_HAS_BGBE (1)
+/* @brief Has Bandgap Buffer Drive Select. */
+#define FSL_FEATURE_PMC_HAS_BGBDS (0)
+/* @brief Has Low-Voltage Detect Voltage Select support. */
+#define FSL_FEATURE_PMC_HAS_LVDV (1)
+/* @brief Has Low-Voltage Warning Voltage Select support. */
+#define FSL_FEATURE_PMC_HAS_LVWV (1)
+/* @brief Has LPO. */
+#define FSL_FEATURE_PMC_HAS_LPO (0)
+/* @brief Has VLPx option PMC_REGSC[VLPO]. */
+#define FSL_FEATURE_PMC_HAS_VLPO (0)
+/* @brief Has acknowledge isolation support. */
+#define FSL_FEATURE_PMC_HAS_ACKISO (1)
+/* @brief Has Regulator In Full Performance Mode Status Bit PMC_REGSC[REGFPM]. */
+#define FSL_FEATURE_PMC_HAS_REGFPM (0)
+/* @brief Has Regulator In Run Regulation Status Bit PMC_REGSC[REGONS]. */
+#define FSL_FEATURE_PMC_HAS_REGONS (1)
+/* @brief Has PMC_HVDSC1. */
+#define FSL_FEATURE_PMC_HAS_HVDSC1 (0)
+/* @brief Has PMC_PARAM. */
+#define FSL_FEATURE_PMC_HAS_PARAM (0)
+/* @brief Has PMC_VERID. */
+#define FSL_FEATURE_PMC_HAS_VERID (0)
+
+/* PORT module features */
+
+/* @brief Has control lock (register bit PCR[LK]). */
+#define FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK (0)
+/* @brief Has open drain control (register bit PCR[ODE]). */
+#define FSL_FEATURE_PORT_HAS_OPEN_DRAIN (0)
+/* @brief Has digital filter (registers DFER, DFCR and DFWR). */
+#define FSL_FEATURE_PORT_HAS_DIGITAL_FILTER (0)
+/* @brief Has DMA request (register bit field PCR[IRQC] values). */
+#define FSL_FEATURE_PORT_HAS_DMA_REQUEST (0)
+/* @brief Has pull resistor selection available. */
+#define FSL_FEATURE_PORT_HAS_PULL_SELECTION (1)
+/* @brief Has pull resistor enable (register bit PCR[PE]). */
+#define FSL_FEATURE_PORT_HAS_PULL_ENABLE (1)
+/* @brief Has slew rate control (register bit PCR[SRE]). */
+#define FSL_FEATURE_PORT_HAS_SLEW_RATE (1)
+/* @brief Has passive filter (register bit field PCR[PFE]). */
+#define FSL_FEATURE_PORT_HAS_PASSIVE_FILTER (1)
+/* @brief Has drive strength control (register bit PCR[DSE]). */
+#define FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH (1)
+/* @brief Has separate drive strength register (HDRVE). */
+#define FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH_REGISTER (0)
+/* @brief Has glitch filter (register IOFLT). */
+#define FSL_FEATURE_PORT_HAS_GLITCH_FILTER (0)
+/* @brief Defines width of PCR[MUX] field. */
+#define FSL_FEATURE_PORT_PCR_MUX_WIDTH (3)
+/* @brief Has dedicated interrupt vector. */
+#define FSL_FEATURE_PORT_HAS_INTERRUPT_VECTOR (1)
+/* @brief Has multiple pin IRQ configuration (register GICLR and GICHR). */
+#define FSL_FEATURE_PORT_HAS_MULTIPLE_IRQ_CONFIG (0)
+/* @brief Defines whether PCR[IRQC] bit-field has flag states. */
+#define FSL_FEATURE_PORT_HAS_IRQC_FLAG (0)
+/* @brief Defines whether PCR[IRQC] bit-field has trigger states. */
+#define FSL_FEATURE_PORT_HAS_IRQC_TRIGGER (0)
+
+/* RCM module features */
+
+/* @brief Has Loss-of-Lock Reset support. */
+#define FSL_FEATURE_RCM_HAS_LOL (0)
+/* @brief Has Loss-of-Clock Reset support. */
+#define FSL_FEATURE_RCM_HAS_LOC (0)
+/* @brief Has JTAG generated Reset support. */
+#define FSL_FEATURE_RCM_HAS_JTAG (0)
+/* @brief Has EzPort generated Reset support. */
+#define FSL_FEATURE_RCM_HAS_EZPORT (0)
+/* @brief Has bit-field indicating EZP_MS_B pin state during last reset. */
+#define FSL_FEATURE_RCM_HAS_EZPMS (0)
+/* @brief Has boot ROM configuration, MR[BOOTROM], FM[FORCEROM] */
+#define FSL_FEATURE_RCM_HAS_BOOTROM (1)
+/* @brief Has sticky system reset status register RCM_SSRS0 and RCM_SSRS1. */
+#define FSL_FEATURE_RCM_HAS_SSRS (1)
+/* @brief Has Version ID Register (RCM_VERID). */
+#define FSL_FEATURE_RCM_HAS_VERID (0)
+/* @brief Has Parameter Register (RCM_PARAM). */
+#define FSL_FEATURE_RCM_HAS_PARAM (0)
+/* @brief Has Reset Interrupt Enable Register RCM_SRIE. */
+#define FSL_FEATURE_RCM_HAS_SRIE (0)
+/* @brief Width of registers of the RCM. */
+#define FSL_FEATURE_RCM_REG_WIDTH (8)
+/* @brief Has Core 1 generated Reset support RCM_SRS[CORE1] */
+#define FSL_FEATURE_RCM_HAS_CORE1 (0)
+/* @brief Has MDM-AP system reset support RCM_SRS1[MDM_AP] */
+#define FSL_FEATURE_RCM_HAS_MDM_AP (1)
+/* @brief Has wakeup reset feature. Register bit SRS[WAKEUP]. */
+#define FSL_FEATURE_RCM_HAS_WAKEUP (1)
+
+/* RTC module features */
+
+/* @brief Has wakeup pin. */
+#define FSL_FEATURE_RTC_HAS_WAKEUP_PIN (1)
+/* @brief Has wakeup pin selection (bit field CR[WPS]). */
+#define FSL_FEATURE_RTC_HAS_WAKEUP_PIN_SELECTION (1)
+/* @brief Has low power features (registers MER, MCLR and MCHR). */
+#define FSL_FEATURE_RTC_HAS_MONOTONIC (0)
+/* @brief Has read/write access control (registers WAR and RAR). */
+#define FSL_FEATURE_RTC_HAS_ACCESS_CONTROL (0)
+/* @brief Has security features (registers TTSR, MER, MCLR and MCHR). */
+#define FSL_FEATURE_RTC_HAS_SECURITY (0)
+/* @brief Has RTC_CLKIN available. */
+#define FSL_FEATURE_RTC_HAS_RTC_CLKIN (1)
+/* @brief Has prescaler adjust for LPO. */
+#define FSL_FEATURE_RTC_HAS_LPO_ADJUST (0)
+/* @brief Has Clock Pin Enable field. */
+#define FSL_FEATURE_RTC_HAS_CPE (0)
+/* @brief Has Timer Seconds Interrupt Configuration field. */
+#define FSL_FEATURE_RTC_HAS_TSIC (0)
+/* @brief Has OSC capacitor setting RTC_CR[SC2P ~ SC16P] */
+#define FSL_FEATURE_RTC_HAS_OSC_SCXP (1)
+/* @brief Has Tamper Interrupt Register (register TIR). */
+#define FSL_FEATURE_RTC_HAS_TIR (0)
+/* @brief Has Tamper Pin Interrupt Enable (bitfield TIR[TPIE]). */
+#define FSL_FEATURE_RTC_HAS_TIR_TPIE (0)
+/* @brief Has Security Interrupt Enable (bitfield TIR[SIE]). */
+#define FSL_FEATURE_RTC_HAS_TIR_SIE (0)
+/* @brief Has Loss of Clock Interrupt Enable (bitfield TIR[LCIE]). */
+#define FSL_FEATURE_RTC_HAS_TIR_LCIE (0)
+/* @brief Has Tamper Interrupt Detect Flag (bitfield SR[TIDF]). */
+#define FSL_FEATURE_RTC_HAS_SR_TIDF (0)
+/* @brief Has Tamper Detect Register (register TDR). */
+#define FSL_FEATURE_RTC_HAS_TDR (0)
+/* @brief Has Tamper Pin Flag (bitfield TDR[TPF]). */
+#define FSL_FEATURE_RTC_HAS_TDR_TPF (0)
+/* @brief Has Security Tamper Flag (bitfield TDR[STF]). */
+#define FSL_FEATURE_RTC_HAS_TDR_STF (0)
+/* @brief Has Loss of Clock Tamper Flag (bitfield TDR[LCTF]). */
+#define FSL_FEATURE_RTC_HAS_TDR_LCTF (0)
+/* @brief Has Tamper Time Seconds Register (register TTSR). */
+#define FSL_FEATURE_RTC_HAS_TTSR (0)
+/* @brief Has Pin Configuration Register (register PCR). */
+#define FSL_FEATURE_RTC_HAS_PCR (0)
+
+/* SIM module features */
+
+/* @brief Has USB FS divider. */
+#define FSL_FEATURE_SIM_USBFS_USE_SPECIAL_DIVIDER (0)
+/* @brief Is PLL clock divided by 2 before MCG PLL/FLL clock selection. */
+#define FSL_FEATURE_SIM_PLLCLK_USE_SPECIAL_DIVIDER (0)
+/* @brief Has RAM size specification (register bit field SOPT1[RAMSIZE]). */
+#define FSL_FEATURE_SIM_OPT_HAS_RAMSIZE (0)
+/* @brief Has 32k oscillator clock output (register bit SOPT1[OSC32KOUT]). */
+#define FSL_FEATURE_SIM_OPT_HAS_OSC32K_OUT (1)
+/* @brief Has 32k oscillator clock selection (register bit field SOPT1[OSC32KSEL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_OSC32K_SELECTION (1)
+/* @brief 32k oscillator clock selection width (width of register bit field SOPT1[OSC32KSEL]). */
+#define FSL_FEATURE_SIM_OPT_OSC32K_SELECTION_WIDTH (2)
+/* @brief Has RTC clock output selection (register bit SOPT2[RTCCLKOUTSEL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_RTC_CLOCK_OUT_SELECTION (1)
+/* @brief Has USB voltage regulator (register bits SOPT1[USBVSTBY], SOPT1[USBSSTBY], SOPT1[USBREGEN], SOPT1CFG[URWE], SOPT1CFG[UVSWE], SOPT1CFG[USSWE]). */
+#define FSL_FEATURE_SIM_OPT_HAS_USB_VOLTAGE_REGULATOR (0)
+/* @brief USB has integrated PHY (register bits USBPHYCTL[USBVREGSEL], USBPHYCTL[USBVREGPD], USBPHYCTL[USB3VOUTTRG], USBPHYCTL[USBDISILIM], SOPT2[USBSLSRC], SOPT2[USBREGEN]). */
+#define FSL_FEATURE_SIM_OPT_HAS_USB_PHY (0)
+/* @brief Has PTD7 pad drive strength control (register bit SOPT2[PTD7PAD]). */
+#define FSL_FEATURE_SIM_OPT_HAS_PTD7PAD (0)
+/* @brief Has FlexBus security level selection (register bit SOPT2[FBSL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_FBSL (0)
+/* @brief Has number of FlexBus hold cycle before FlexBus can release bus (register bit SOPT6[PCR]). */
+#define FSL_FEATURE_SIM_OPT_HAS_PCR (0)
+/* @brief Has number of NFC hold cycle in case of FlexBus request (register bit SOPT6[MCC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_MCC (0)
+/* @brief Has UART open drain enable (register bits UARTnODE, where n is a number, in register SOPT5). */
+#define FSL_FEATURE_SIM_OPT_HAS_ODE (0)
+/* @brief Number of LPUART modules (number of register bits LPUARTn, where n is a number, in register SCGC5). */
+#define FSL_FEATURE_SIM_OPT_LPUART_COUNT (1)
+/* @brief Number of UART modules (number of register bits UARTn, where n is a number, in register SCGC4). */
+#define FSL_FEATURE_SIM_OPT_UART_COUNT (0)
+/* @brief Has UART0 open drain enable (register bit SOPT5[UART0ODE]). */
+#define FSL_FEATURE_SIM_OPT_HAS_UART0_ODE (0)
+/* @brief Has UART1 open drain enable (register bit SOPT5[UART1ODE]). */
+#define FSL_FEATURE_SIM_OPT_HAS_UART1_ODE (0)
+/* @brief Has UART2 open drain enable (register bit SOPT5[UART2ODE]). */
+#define FSL_FEATURE_SIM_OPT_HAS_UART2_ODE (0)
+/* @brief Has LPUART0 open drain enable (register bit SOPT5[LPUART0ODE]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUART0_ODE (1)
+/* @brief Has LPUART1 open drain enable (register bit SOPT5[LPUART1ODE]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUART1_ODE (0)
+/* @brief Has CMT/UART pad drive strength control (register bit SOPT2[CMTUARTPAD]). */
+#define FSL_FEATURE_SIM_OPT_HAS_CMTUARTPAD (0)
+/* @brief Has LPUART0 transmit data source selection (register bit SOPT5[LPUART0TXSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUART0_TX_SRC (1)
+/* @brief Has LPUART0 receive data source selection (register bit SOPT5[LPUART0RXSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUART0_RX_SRC (1)
+/* @brief Has LPUART1 transmit data source selection (register bit SOPT5[LPUART1TXSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUART1_TX_SRC (0)
+/* @brief Has LPUART1 receive data source selection (register bit SOPT5[LPUART1RXSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUART1_RX_SRC (0)
+/* @brief Has UART0 transmit data source selection (register bit SOPT5[UART0TXSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_UART0_TX_SRC (0)
+/* @brief UART0 transmit data source selection width (width of register bit SOPT5[UART0TXSRC]). */
+#define FSL_FEATURE_SIM_OPT_UART0_TX_SRC_WIDTH (0)
+/* @brief Has UART0 receive data source selection (register bit SOPT5[UART0RXSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_UART0_RX_SRC (0)
+/* @brief UART0 receive data source selection width (width of register bit SOPT5[UART0RXSRC]). */
+#define FSL_FEATURE_SIM_OPT_UART0_RX_SRC_WIDTH (0)
+/* @brief Has UART1 transmit data source selection (register bit SOPT5[UART1TXSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_UART1_TX_SRC (0)
+/* @brief Has UART1 receive data source selection (register bit SOPT5[UART1RXSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_UART1_RX_SRC (0)
+/* @brief UART1 receive data source selection width (width of register bit SOPT5[UART1RXSRC]). */
+#define FSL_FEATURE_SIM_OPT_UART1_RX_SRC_WIDTH (0)
+/* @brief Has FTM module(s) configuration. */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM (0)
+/* @brief Number of FTM modules. */
+#define FSL_FEATURE_SIM_OPT_FTM_COUNT (0)
+/* @brief Number of FTM triggers with selectable source. */
+#define FSL_FEATURE_SIM_OPT_FTM_TRIGGER_COUNT (0)
+/* @brief Has FTM0 triggers source selection (register bits SOPT4[FTM0TRGnSRC], where n is a number). */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM0_TRIGGER (0)
+/* @brief Has FTM3 triggers source selection (register bits SOPT4[FTM3TRGnSRC], where n is a number). */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM3_TRIGGER (0)
+/* @brief Has FTM1 channel 0 input capture source selection (register bit SOPT4[FTM1CH0SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM1_CHANNELS (0)
+/* @brief Has FTM2 channel 0 input capture source selection (register bit SOPT4[FTM2CH0SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM2_CHANNELS (0)
+/* @brief Has FTM3 channel 0 input capture source selection (register bit SOPT4[FTM3CH0SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM3_CHANNELS (0)
+/* @brief Has FTM2 channel 1 input capture source selection (register bit SOPT4[FTM2CH1SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM2_CHANNEL1 (0)
+/* @brief Number of configurable FTM0 fault detection input (number of register bits SOPT4[FTM0FLTn], where n is a number starting from zero). */
+#define FSL_FEATURE_SIM_OPT_FTM0_FAULT_COUNT (0)
+/* @brief Number of configurable FTM1 fault detection input (number of register bits SOPT4[FTM1FLTn], where n is a number starting from zero). */
+#define FSL_FEATURE_SIM_OPT_FTM1_FAULT_COUNT (0)
+/* @brief Number of configurable FTM2 fault detection input (number of register bits SOPT4[FTM2FLTn], where n is a number starting from zero). */
+#define FSL_FEATURE_SIM_OPT_FTM2_FAULT_COUNT (0)
+/* @brief Number of configurable FTM3 fault detection input (number of register bits SOPT4[FTM3FLTn], where n is a number starting from zero). */
+#define FSL_FEATURE_SIM_OPT_FTM3_FAULT_COUNT (0)
+/* @brief Has FTM hardware trigger 0 software synchronization (register bit SOPT8[FTMnSYNCBIT], where n is a module instance index). */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM_TRIGGER_SYNC (0)
+/* @brief Has FTM channels output source selection (register bit SOPT8[FTMxOCHnSRC], where x is a module instance index and n is a channel index). */
+#define FSL_FEATURE_SIM_OPT_HAS_FTM_CHANNELS_OUTPUT_SRC (0)
+/* @brief Has TPM module(s) configuration. */
+#define FSL_FEATURE_SIM_OPT_HAS_TPM (1)
+/* @brief The highest TPM module index. */
+#define FSL_FEATURE_SIM_OPT_MAX_TPM_INDEX (1)
+/* @brief Has TPM module with index 0. */
+#define FSL_FEATURE_SIM_OPT_HAS_TPM0 (1)
+/* @brief Has TPM0 clock selection (register bit field SOPT4[TPM0CLKSEL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_TPM0_CLK_SEL (1)
+/* @brief Is TPM channels configuration in the SOPT4 (not SOPT9) register (register bits TPMnCH0SRC, TPMnCLKSEL, where n is a module instance index). */
+#define FSL_FEATURE_SIM_OPT_HAS_TPM_CHANNELS_CONFIG_IN_SOPT4_REG (1)
+/* @brief Has TPM1 channel 0 input capture source selection (register bit field SOPT4[TPM1CH0SRC] or SOPT9[TPM1CH0SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_TPM1_CH0_SRC_SELECTION (1)
+/* @brief Has TPM1 clock selection (register bit field SOPT4[TPM1CLKSEL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_TPM1_CLK_SEL (1)
+/* @brief TPM1 channel 0 input capture source selection width (width of register bit field SOPT4[TPM1CH0SRC] or SOPT9[TPM1CH0SRC]). */
+#define FSL_FEATURE_SIM_OPT_TPM1_CH0_SRC_SELECTION_WIDTH (1)
+/* @brief Has TPM2 channel 0 input capture source selection (register bit field SOPT4[TPM2CH0SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_TPM2_CH0_SRC_SELECTION (0)
+/* @brief Has TPM2 clock selection (register bit field SOPT4[TPM2CLKSEL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_TPM2_CLK_SEL (0)
+/* @brief Has PLL/FLL clock selection (register bit field SOPT2[PLLFLLSEL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_PLL_FLL_SELECTION (0)
+/* @brief PLL/FLL clock selection width (width of register bit field SOPT2[PLLFLLSEL]). */
+#define FSL_FEATURE_SIM_OPT_PLL_FLL_SELECTION_WIDTH (0)
+/* @brief Has NFC clock source selection (register bit SOPT2[NFCSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_NFCSRC (0)
+/* @brief Has eSDHC clock source selection (register bit SOPT2[ESDHCSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_ESDHCSRC (0)
+/* @brief Has SDHC clock source selection (register bit SOPT2[SDHCSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_SDHCSRC (0)
+/* @brief Has LCDC clock source selection (register bits SOPT2[LCDCSRC], SOPT2[LCDC_CLKSEL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LCDCSRC (0)
+/* @brief Has ENET timestamp clock source selection (register bit SOPT2[TIMESRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_TIMESRC (0)
+/* @brief Has ENET RMII clock source selection (register bit SOPT2[RMIISRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_RMIISRC (0)
+/* @brief Has USB clock source selection (register bit SOPT2[USBSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_USBSRC (0)
+/* @brief Has USB FS clock source selection (register bit SOPT2[USBFSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_USBFSRC (0)
+/* @brief Has USB HS clock source selection (register bit SOPT2[USBHSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_USBHSRC (0)
+/* @brief Has LPUART clock source selection (register bit SOPT2[LPUARTSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUARTSRC (0)
+/* @brief Has LPUART0 clock source selection (register bit SOPT2[LPUART0SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUART0SRC (1)
+/* @brief Has LPUART1 clock source selection (register bit SOPT2[LPUART1SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_LPUART1SRC (0)
+/* @brief Has FLEXIOSRC clock source selection (register bit SOPT2[FLEXIOSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_FLEXIOSRC (0)
+/* @brief Has UART0 clock source selection (register bit SOPT2[UART0SRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_UART0SRC (0)
+/* @brief Has TPM clock source selection (register bit SOPT2[TPMSRC]). */
+#define FSL_FEATURE_SIM_OPT_HAS_TPMSRC (1)
+/* @brief Has debug trace clock selection (register bit SOPT2[TRACECLKSEL]). */
+#define FSL_FEATURE_SIM_OPT_HAS_TRACE_CLKSEL (0)
+/* @brief Number of ADC modules (register bits SOPT7[ADCnTRGSEL], SOPT7[ADCnPRETRGSEL], SOPT7[ADCnALTTRGSEL], where n is a module instance index). */
+#define FSL_FEATURE_SIM_OPT_ADC_COUNT (1)
+/* @brief Has clock 2 output divider (register bit field CLKDIV1[OUTDIV2]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_OUTDIV2 (0)
+/* @brief Has clock 3 output divider (register bit field CLKDIV1[OUTDIV3]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_OUTDIV3 (0)
+/* @brief Has clock 4 output divider (register bit field CLKDIV1[OUTDIV4]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_OUTDIV4 (1)
+/* @brief Clock 4 output divider width (width of register bit field CLKDIV1[OUTDIV4]). */
+#define FSL_FEATURE_SIM_DIVIDER_OUTDIV4_WIDTH (3)
+/* @brief Has clock 5 output divider (register bit field CLKDIV1[OUTDIV5]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_OUTDIV5 (0)
+/* @brief Has USB clock divider (register bit field CLKDIV2[USBDIV] and CLKDIV2[USBFRAC]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_USBDIV (0)
+/* @brief Has USB FS clock divider (register bit field CLKDIV2[USBFSDIV] and CLKDIV2[USBFSFRAC]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_USBFSDIV (0)
+/* @brief Has USB HS clock divider (register bit field CLKDIV2[USBHSDIV] and CLKDIV2[USBHSFRAC]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_USBHSDIV (0)
+/* @brief Has PLL/FLL clock divider (register bit field CLKDIV3[PLLFLLDIV] and CLKDIV3[PLLFLLFRAC]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_PLLFLLDIV (0)
+/* @brief Has LCDC clock divider (register bit field CLKDIV3[LCDCDIV] and CLKDIV3[LCDCFRAC]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_LCDCDIV (0)
+/* @brief Has trace clock divider (register bit field CLKDIV4[TRACEDIV] and CLKDIV4[TRACEFRAC]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_TRACEDIV (0)
+/* @brief Has NFC clock divider (register bit field CLKDIV4[NFCDIV] and CLKDIV4[NFCFRAC]). */
+#define FSL_FEATURE_SIM_DIVIDER_HAS_NFCDIV (0)
+/* @brief Has Kinetis family ID (register bit field SDID[FAMILYID]). */
+#define FSL_FEATURE_SIM_SDID_HAS_FAMILYID (0)
+/* @brief Has Kinetis family ID (register bit field SDID[FAMID]). */
+#define FSL_FEATURE_SIM_SDID_HAS_FAMID (1)
+/* @brief Has Kinetis sub-family ID (register bit field SDID[SUBFAMID]). */
+#define FSL_FEATURE_SIM_SDID_HAS_SUBFAMID (1)
+/* @brief Has Kinetis series ID (register bit field SDID[SERIESID]). */
+#define FSL_FEATURE_SIM_SDID_HAS_SERIESID (1)
+/* @brief Has device die ID (register bit field SDID[DIEID]). */
+#define FSL_FEATURE_SIM_SDID_HAS_DIEID (1)
+/* @brief Has system SRAM size specifier (register bit field SDID[SRAMSIZE]). */
+#define FSL_FEATURE_SIM_SDID_HAS_SRAMSIZE (1)
+/* @brief Has flash mode (register bit FCFG1[FLASHDOZE]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_FLASHDOZE (1)
+/* @brief Has flash disable (register bit FCFG1[FLASHDIS]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_FLASHDIS (1)
+/* @brief Has FTFE disable (register bit FCFG1[FTFDIS]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_FTFDIS (0)
+/* @brief Has FlexNVM size specifier (register bit field FCFG1[NVMSIZE]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_NVMSIZE (0)
+/* @brief Has EEPROM size specifier (register bit field FCFG1[EESIZE]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_EESIZE (0)
+/* @brief Has FlexNVM partition (register bit field FCFG1[DEPART]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_DEPART (0)
+/* @brief Maximum flash address block 0 address specifier (register bit field FCFG2[MAXADDR0]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_MAXADDR0 (1)
+/* @brief Maximum flash address block 1 address specifier (register bit field FCFG2[MAXADDR1]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_MAXADDR1 (0)
+/* @brief Maximum flash address block 0 or 1 address specifier (register bit field FCFG2[MAXADDR01]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_MAXADDR01 (0)
+/* @brief Maximum flash address block 2 or 3 address specifier (register bit field FCFG2[MAXADDR23]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_MAXADDR23 (0)
+/* @brief Has program flash availability specifier (register bit FCFG2[PFLSH]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_PFLSH (0)
+/* @brief Has program flash swapping (register bit FCFG2[SWAPPFLSH]). */
+#define FSL_FEATURE_SIM_FCFG_HAS_PFLSH_SWAP (0)
+/* @brief Has miscellanious control register (register MCR). */
+#define FSL_FEATURE_SIM_HAS_MISC_CONTROLS (0)
+/* @brief Has COP watchdog (registers COPC and SRVCOP). */
+#define FSL_FEATURE_SIM_HAS_COP_WATCHDOG (1)
+/* @brief Has COP watchdog stop (register bits COPC[COPSTPEN], COPC[COPDBGEN] and COPC[COPCLKSEL]). */
+#define FSL_FEATURE_SIM_HAS_COP_STOP (1)
+/* @brief Has LLWU clock gate bit (e.g SIM_SCGC4). */
+#define FSL_FEATURE_SIM_HAS_SCGC_LLWU (0)
+
+/* SMC module features */
+
+/* @brief Has partial stop option (register bit STOPCTRL[PSTOPO]). */
+#define FSL_FEATURE_SMC_HAS_PSTOPO (1)
+/* @brief Has LPO power option (register bit STOPCTRL[LPOPO]). */
+#define FSL_FEATURE_SMC_HAS_LPOPO (1)
+/* @brief Has POR power option (register bit STOPCTRL[PORPO] or VLLSCTRL[PORPO]). */
+#define FSL_FEATURE_SMC_HAS_PORPO (1)
+/* @brief Has low power wakeup on interrupt (register bit PMCTRL[LPWUI]). */
+#define FSL_FEATURE_SMC_HAS_LPWUI (0)
+/* @brief Has LLS or VLLS mode control (register bit STOPCTRL[LLSM]). */
+#define FSL_FEATURE_SMC_HAS_LLS_SUBMODE (0)
+/* @brief Has VLLS mode control (register bit VLLSCTRL[VLLSM]). */
+#define FSL_FEATURE_SMC_USE_VLLSCTRL_REG (0)
+/* @brief Has VLLS mode control (register bit STOPCTRL[VLLSM]). */
+#define FSL_FEATURE_SMC_USE_STOPCTRL_VLLSM (1)
+/* @brief Has RAM partition 2 power option (register bit STOPCTRL[RAM2PO]). */
+#define FSL_FEATURE_SMC_HAS_RAM2_POWER_OPTION (0)
+/* @brief Has high speed run mode (register bit PMPROT[AHSRUN]). */
+#define FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE (0)
+/* @brief Has low leakage stop mode (register bit PMPROT[ALLS]). */
+#define FSL_FEATURE_SMC_HAS_LOW_LEAKAGE_STOP_MODE (0)
+/* @brief Has very low leakage stop mode (register bit PMPROT[AVLLS]). */
+#define FSL_FEATURE_SMC_HAS_VERY_LOW_LEAKAGE_STOP_MODE (1)
+/* @brief Has stop submode. */
+#define FSL_FEATURE_SMC_HAS_SUB_STOP_MODE (1)
+/* @brief Has stop submode 0(VLLS0). */
+#define FSL_FEATURE_SMC_HAS_STOP_SUBMODE0 (1)
+/* @brief Has stop submode 1(VLLS1). */
+#define FSL_FEATURE_SMC_HAS_STOP_SUBMODE1 (1)
+/* @brief Has stop submode 2(VLLS2). */
+#define FSL_FEATURE_SMC_HAS_STOP_SUBMODE2 (0)
+/* @brief Has SMC_PARAM. */
+#define FSL_FEATURE_SMC_HAS_PARAM (0)
+/* @brief Has SMC_VERID. */
+#define FSL_FEATURE_SMC_HAS_VERID (0)
+/* @brief Has stop abort flag (register bit PMCTRL[STOPA]). */
+#define FSL_FEATURE_SMC_HAS_PMCTRL_STOPA (1)
+/* @brief Has tamper reset (register bit SRS[TAMPER]). */
+#define FSL_FEATURE_SMC_HAS_SRS_TAMPER (0)
+/* @brief Has security violation reset (register bit SRS[SECVIO]). */
+#define FSL_FEATURE_SMC_HAS_SRS_SECVIO (0)
+
+/* SPI module features */
+
+/* @brief Capacity (number of entries) of the transmit/receive FIFO (or zero if no FIFO is available). */
+#define FSL_FEATURE_SPI_HAS_FIFO (0)
+/* @brief Has DMA support (register bit fields C2[RXDMAE] and C2[TXDMAE]). */
+#define FSL_FEATURE_SPI_HAS_DMA_SUPPORT (0)
+/* @brief Has separate DMA RX and TX requests. */
+#define FSL_FEATURE_SPI_HAS_SEPARATE_DMA_RX_TX_REQn(x) (0)
+/* @brief Receive/transmit FIFO size in number of 16-bit communication items. */
+#define FSL_FEATURE_SPI_FIFO_SIZEn(x) (0)
+/* @brief Maximum transfer data width in bits. */
+#define FSL_FEATURE_SPI_MAX_DATA_WIDTH (8)
+/* @brief The data register name has postfix (L as low and H as high). */
+#define FSL_FEATURE_SPI_DATA_REGISTER_HAS_POSTFIX (0)
+/* @brief Has separated TXDATA and CMD FIFOs (register SREX). */
+#define FSL_FEATURE_SPI_HAS_SEPARATE_TXDATA_CMD_FIFO (0)
+/* @brief Has 16-bit data transfer support. */
+#define FSL_FEATURE_SPI_16BIT_TRANSFERS (0)
+
+/* SysTick module features */
+
+/* @brief Systick has external reference clock. */
+#define FSL_FEATURE_SYSTICK_HAS_EXT_REF (1)
+/* @brief Systick external reference clock is core clock divided by this value. */
+#define FSL_FEATURE_SYSTICK_EXT_REF_CORE_DIV (16)
+
+/* TPM module features */
+
+/* @brief Bus clock is the source clock for the module. */
+#define FSL_FEATURE_TPM_BUS_CLOCK (0)
+/* @brief Number of channels. */
+#define FSL_FEATURE_TPM_CHANNEL_COUNTn(x) (2)
+/* @brief Has counter reset by the selected input capture event (register bits C0SC[ICRST], C1SC[ICRST], ...). */
+#define FSL_FEATURE_TPM_HAS_COUNTER_RESET_BY_CAPTURE_EVENT (0)
+/* @brief Has TPM_PARAM. */
+#define FSL_FEATURE_TPM_HAS_PARAM (0)
+/* @brief Has TPM_VERID. */
+#define FSL_FEATURE_TPM_HAS_VERID (0)
+/* @brief Has TPM_GLOBAL. */
+#define FSL_FEATURE_TPM_HAS_GLOBAL (0)
+/* @brief Has TPM_TRIG. */
+#define FSL_FEATURE_TPM_HAS_TRIG (0)
+/* @brief Has counter pause on trigger. */
+#define FSL_FEATURE_TPM_HAS_PAUSE_COUNTER_ON_TRIGGER (0)
+/* @brief Has external trigger selection. */
+#define FSL_FEATURE_TPM_HAS_EXTERNAL_TRIGGER_SELECTION (0)
+/* @brief Has TPM_COMBINE register. */
+#define FSL_FEATURE_TPM_HAS_COMBINE (0)
+/* @brief Whether COMBINE register has effect. */
+#define FSL_FEATURE_TPM_COMBINE_HAS_EFFECTn(x) (0)
+/* @brief Has TPM_POL. */
+#define FSL_FEATURE_TPM_HAS_POL (0)
+/* @brief Has TPM_FILTER register. */
+#define FSL_FEATURE_TPM_HAS_FILTER (0)
+/* @brief Whether FILTER register has effect. */
+#define FSL_FEATURE_TPM_FILTER_HAS_EFFECTn(x) (0)
+/* @brief Has TPM_QDCTRL register. */
+#define FSL_FEATURE_TPM_HAS_QDCTRL (0)
+/* @brief Whether QDCTRL register has effect. */
+#define FSL_FEATURE_TPM_QDCTRL_HAS_EFFECTn(x) (0)
+/* @brief Whether 32 bits counter has effect. */
+#define FSL_FEATURE_TPM_HAS_32BIT_COUNTERn(x) (0)
+
+/* VREF module features */
+
+/* @brief Has chop oscillator (bit TRM[CHOPEN]) */
+#define FSL_FEATURE_VREF_HAS_CHOP_OSC (1)
+/* @brief Has second order curvature compensation (bit SC[ICOMPEN]) */
+#define FSL_FEATURE_VREF_HAS_COMPENSATION (1)
+/* @brief If high/low buffer mode supported */
+#define FSL_FEATURE_VREF_MODE_LV_TYPE (1)
+/* @brief Module has also low reference (registers VREFL/VREFH) */
+#define FSL_FEATURE_VREF_HAS_LOW_REFERENCE (0)
+/* @brief Has VREF_TRM4. */
+#define FSL_FEATURE_VREF_HAS_TRM4 (0)
+
+#endif /* _MKL03Z4_FEATURES_H_ */
+
diff --git a/KL0/MKL03Z4/drivers/CMakeLists.txt b/KL0/MKL03Z4/drivers/CMakeLists.txt
new file mode 100644
index 0000000..9d296c1
--- /dev/null
+++ b/KL0/MKL03Z4/drivers/CMakeLists.txt
@@ -0,0 +1,16 @@
+# Copyright 2024 NXP
+# All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+if (CONFIG_MCUX_COMPONENT_driver.clock)
+    mcux_component_version(2.1.1)
+    mcux_add_source( SOURCES fsl_clock.c fsl_clock.h )
+    mcux_add_include( INCLUDES . )
+endif()
+
+if (CONFIG_MCUX_COMPONENT_driver.port_kl0)
+    mcux_component_version(2.0.2)
+    mcux_add_source( SOURCES fsl_port.h )
+    mcux_add_include( INCLUDES . )
+endif()
diff --git a/KL0/MKL03Z4/drivers/Kconfig b/KL0/MKL03Z4/drivers/Kconfig
new file mode 100644
index 0000000..712692a
--- /dev/null
+++ b/KL0/MKL03Z4/drivers/Kconfig
@@ -0,0 +1,16 @@
+# Copyright 2024 NXP
+# All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+menu "Device specific drivers configuration"
+
+    config MCUX_COMPONENT_driver.clock
+         bool "clock"
+         default y
+
+    config MCUX_COMPONENT_driver.port_kl0
+         bool "Use KL0 driver port"
+         default y
+
+endmenu
diff --git a/KL0/MKL03Z4/drivers/fsl_clock.c b/KL0/MKL03Z4/drivers/fsl_clock.c
new file mode 100644
index 0000000..6a12bf1
--- /dev/null
+++ b/KL0/MKL03Z4/drivers/fsl_clock.c
@@ -0,0 +1,352 @@
+/*
+ * The Clear BSD License
+ * Copyright (c) 2015, Freescale Semiconductor, Inc.
+ * Copyright (c) 2016 - 2017 , NXP
+ * All rights reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted (subject to the limitations in the disclaimer below) provided
+ * that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of copyright holder nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fsl_clock.h"
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+
+#if (defined(OSC) && !(defined(OSC0)))
+#define OSC0 OSC
+#endif
+
+#define MCG_HIRC_FREQ (48000000U)
+#define MCG_LIRC_FREQ1 (2000000U)
+#define MCG_LIRC_FREQ2 (8000000U)
+
+#define MCG_S_CLKST_VAL ((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
+#define MCG_SC_FCRDIV_VAL ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
+#define MCG_MC_LIRC_DIV2_VAL ((MCG->MC & MCG_MC_LIRC_DIV2_MASK) >> MCG_MC_LIRC_DIV2_SHIFT)
+#define MCG_C2_IRCS_VAL ((MCG->C2 & MCG_C2_IRCS_MASK) >> MCG_C2_IRCS_SHIFT)
+
+#define SIM_CLKDIV1_OUTDIV1_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)
+#define SIM_CLKDIV1_OUTDIV4_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)
+#define SIM_SOPT1_OSC32KSEL_VAL ((SIM->SOPT1 & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
+
+/*******************************************************************************
+ * Variables
+ ******************************************************************************/
+
+/* External XTAL0 (OSC0) clock frequency. */
+uint32_t g_xtal0Freq;
+/* External XTAL32K clock frequency. */
+uint32_t g_xtal32Freq;
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+/*!
+ * @brief Get the current MCG_Lite LIRC_CLK frequency in Hz.
+ *
+ * This function will return the LIRC_CLK value in frequency(Hz) based
+ * on current MCG_Lite configurations and settings. It is an internal function.
+ *
+ * @return MCG_Lite LIRC_CLK frequency.
+ */
+static uint32_t CLOCK_GetLircClkFreq(void);
+
+/*******************************************************************************
+ * Code
+ ******************************************************************************/
+
+static uint32_t CLOCK_GetLircClkFreq(void)
+{
+    static const uint32_t lircFreqs[] = {MCG_LIRC_FREQ1, MCG_LIRC_FREQ2};
+
+    /* Check whether the LIRC is enabled. */
+    if ((MCG->C1 & MCG_C1_IRCLKEN_MASK) || (kMCGLITE_ClkSrcLirc == MCG_S_CLKST_VAL))
+    {
+        return lircFreqs[MCG_C2_IRCS_VAL];
+    }
+    else
+    {
+        return 0U;
+    }
+}
+
+uint32_t CLOCK_GetOsc0ErClkFreq(void)
+{
+    if (OSC->CR & OSC_CR_ERCLKEN_MASK)
+    {
+        /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
+        assert(g_xtal0Freq);
+        return g_xtal0Freq;
+    }
+    else
+    {
+        return 0U;
+    }
+}
+
+uint32_t CLOCK_GetEr32kClkFreq(void)
+{
+    uint32_t freq;
+
+    switch (SIM_SOPT1_OSC32KSEL_VAL)
+    {
+        case 0U: /* OSC 32k clock  */
+            freq = (CLOCK_GetOsc0ErClkFreq() == 32768U) ? 32768U : 0U;
+            break;
+        case 2U: /* RTC 32k clock  */
+            /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
+            assert(g_xtal32Freq);
+            freq = g_xtal32Freq;
+            break;
+        case 3U: /* LPO clock      */
+            freq = LPO_CLK_FREQ;
+            break;
+        default:
+            freq = 0U;
+            break;
+    }
+    return freq;
+}
+
+uint32_t CLOCK_GetPlatClkFreq(void)
+{
+    return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
+}
+
+uint32_t CLOCK_GetFlashClkFreq(void)
+{
+    uint32_t freq;
+
+    freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
+    freq /= (SIM_CLKDIV1_OUTDIV4_VAL + 1);
+
+    return freq;
+}
+
+uint32_t CLOCK_GetBusClkFreq(void)
+{
+    uint32_t freq;
+
+    freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
+    freq /= (SIM_CLKDIV1_OUTDIV4_VAL + 1);
+
+    return freq;
+}
+
+uint32_t CLOCK_GetCoreSysClkFreq(void)
+{
+    return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
+}
+
+uint32_t CLOCK_GetFreq(clock_name_t clockName)
+{
+    uint32_t freq;
+
+    switch (clockName)
+    {
+        case kCLOCK_CoreSysClk:
+        case kCLOCK_PlatClk:
+            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
+            break;
+        case kCLOCK_BusClk:
+        case kCLOCK_FlashClk:
+            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
+            freq /= (SIM_CLKDIV1_OUTDIV4_VAL + 1);
+            break;
+        case kCLOCK_Er32kClk:
+            freq = CLOCK_GetEr32kClkFreq();
+            break;
+        case kCLOCK_Osc0ErClk:
+            freq = CLOCK_GetOsc0ErClkFreq();
+            break;
+        case kCLOCK_McgInternalRefClk:
+            freq = CLOCK_GetInternalRefClkFreq();
+            break;
+        case kCLOCK_McgPeriphClk:
+        case kCLOCK_McgIrc48MClk:
+            freq = CLOCK_GetPeriphClkFreq();
+            break;
+        case kCLOCK_LpoClk:
+            freq = LPO_CLK_FREQ;
+            break;
+        default:
+            freq = 0U;
+            break;
+    }
+
+    return freq;
+}
+
+void CLOCK_SetSimConfig(sim_clock_config_t const *config)
+{
+    SIM->CLKDIV1 = config->clkdiv1;
+    CLOCK_SetEr32kClock(config->er32kSrc);
+}
+
+uint32_t CLOCK_GetInternalRefClkFreq(void)
+{
+    uint8_t divider1 = MCG_SC_FCRDIV_VAL;
+    uint8_t divider2 = MCG_MC_LIRC_DIV2_VAL;
+    /* LIRC internal reference clock is selected*/
+    return CLOCK_GetLircClkFreq() >> (divider1 + divider2);
+}
+
+uint32_t CLOCK_GetPeriphClkFreq(void)
+{
+    /* Check whether the HIRC is enabled. */
+    if ((MCG->MC & MCG_MC_HIRCEN_MASK) || (kMCGLITE_ClkSrcHirc == MCG_S_CLKST_VAL))
+    {
+        return MCG_HIRC_FREQ;
+    }
+    else
+    {
+        return 0U;
+    }
+}
+
+uint32_t CLOCK_GetOutClkFreq(void)
+{
+    uint32_t freq;
+
+    switch (MCG_S_CLKST_VAL)
+    {
+        case kMCGLITE_ClkSrcHirc:
+            freq = MCG_HIRC_FREQ;
+            break;
+        case kMCGLITE_ClkSrcLirc:
+            freq = CLOCK_GetLircClkFreq() >> MCG_SC_FCRDIV_VAL;
+            break;
+        case kMCGLITE_ClkSrcExt:
+            /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
+            assert(g_xtal0Freq);
+            freq = g_xtal0Freq;
+            break;
+        default:
+            freq = 0U;
+            break;
+    }
+
+    return freq;
+}
+
+mcglite_mode_t CLOCK_GetMode(void)
+{
+    mcglite_mode_t mode;
+
+    switch (MCG_S_CLKST_VAL)
+    {
+        case kMCGLITE_ClkSrcHirc: /* HIRC */
+            mode = kMCGLITE_ModeHirc48M;
+            break;
+        case kMCGLITE_ClkSrcLirc: /* LIRC */
+            if (kMCGLITE_Lirc2M == MCG_C2_IRCS_VAL)
+            {
+                mode = kMCGLITE_ModeLirc2M;
+            }
+            else
+            {
+                mode = kMCGLITE_ModeLirc8M;
+            }
+            break;
+        case kMCGLITE_ClkSrcExt: /* EXT  */
+            mode = kMCGLITE_ModeExt;
+            break;
+        default:
+            mode = kMCGLITE_ModeError;
+            break;
+    }
+
+    return mode;
+}
+
+status_t CLOCK_SetMcgliteConfig(mcglite_config_t const *targetConfig)
+{
+    assert(targetConfig);
+
+    /*
+     * If switch between LIRC8M and LIRC2M, need to switch to HIRC mode first,
+     * because could not switch directly.
+     */
+    if ((kMCGLITE_ClkSrcLirc == MCG_S_CLKST_VAL) && (kMCGLITE_ClkSrcLirc == targetConfig->outSrc) &&
+        (MCG_C2_IRCS_VAL != targetConfig->ircs))
+    {
+        MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCGLITE_ClkSrcHirc);
+        while (kMCGLITE_ClkSrcHirc != MCG_S_CLKST_VAL)
+        {
+        }
+    }
+
+    /* Set configuration now. */
+    MCG->SC = MCG_SC_FCRDIV(targetConfig->fcrdiv);
+    MCG->MC = MCG_MC_HIRCEN(targetConfig->hircEnableInNotHircMode) | MCG_MC_LIRC_DIV2(targetConfig->lircDiv2);
+    MCG->C2 = (MCG->C2 & ~MCG_C2_IRCS_MASK) | MCG_C2_IRCS(targetConfig->ircs);
+    MCG->C1 = MCG_C1_CLKS(targetConfig->outSrc) | targetConfig->irclkEnableMode;
+
+    /*
+     * If external oscillator used and MCG_Lite is set to EXT mode, need to
+     * wait for the OSC stable.
+     */
+    if ((MCG->C2 & MCG_C2_EREFS0_MASK) && (kMCGLITE_ClkSrcExt == targetConfig->outSrc))
+    {
+        while (!(MCG->S & MCG_S_OSCINIT0_MASK))
+        {
+        }
+    }
+
+    /* Wait for clock source change completed. */
+    while (targetConfig->outSrc != MCG_S_CLKST_VAL)
+    {
+    }
+
+    return kStatus_Success;
+}
+
+void CLOCK_InitOsc0(osc_config_t const *config)
+{
+    OSC_SetCapLoad(OSC0, config->capLoad);
+    OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
+
+    MCG->C2 = ((MCG->C2 & MCG_C2_IRCS_MASK) | (uint8_t)config->workMode);
+
+    if ((kOSC_ModeExt != config->workMode) && (OSC0->CR & OSC_CR_ERCLKEN_MASK))
+    {
+        /* Wait for stable. */
+        while (!(MCG->S & MCG_S_OSCINIT0_MASK))
+        {
+        }
+    }
+}
+
+void CLOCK_DeinitOsc0(void)
+{
+    OSC0->CR = 0U;
+    MCG->C2 &= MCG_C2_IRCS_MASK;
+}
diff --git a/KL0/MKL03Z4/drivers/fsl_clock.h b/KL0/MKL03Z4/drivers/fsl_clock.h
new file mode 100644
index 0000000..748f37e
--- /dev/null
+++ b/KL0/MKL03Z4/drivers/fsl_clock.h
@@ -0,0 +1,714 @@
+/*
+ * The Clear BSD License
+ * Copyright (c) 2015, Freescale Semiconductor, Inc.
+ * Copyright (c) 2016 - 2017 , NXP
+ * All rights reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted (subject to the limitations in the disclaimer below) provided
+ * that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of copyright holder nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _FSL_CLOCK_H_
+#define _FSL_CLOCK_H_
+
+#include "fsl_common.h"
+
+/*! @addtogroup clock */
+/*! @{ */
+
+/*! @file */
+
+/*******************************************************************************
+ * Configurations
+ ******************************************************************************/
+
+/*! @brief Configure whether driver controls clock
+ *
+ * When set to 0, peripheral drivers will enable clock in initialize function
+ * and disable clock in de-initialize function. When set to 1, peripheral
+ * driver will not control the clock, application could contol the clock out of
+ * the driver.
+ *
+ * @note All drivers share this feature switcher. If it is set to 1, application
+ * should handle clock enable and disable for all drivers.
+ */
+#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
+#define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
+#endif
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+
+/*! @name Driver version */
+/*@{*/
+/*! @brief CLOCK driver version 2.1.1. */
+#define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 1, 1))
+/*@}*/
+
+/*! @brief External XTAL0 (OSC0) clock frequency.
+ *
+ * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
+ * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
+ * if XTAL0 is 8 MHz:
+ * @code
+ * CLOCK_InitOsc0(...); // Set up the OSC0
+ * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to clock driver.
+ * @endcode
+ *
+ * This is important for the multicore platforms where one core needs to set up the
+ * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
+ * to get a valid clock frequency.
+ */
+extern uint32_t g_xtal0Freq;
+
+/*! @brief The external XTAL32/EXTAL32/RTC_CLKIN clock frequency.
+ *
+ * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
+ * function CLOCK_SetXtal32Freq to set the value in the clock driver.
+ *
+ * This is important for the multicore platforms where one core needs to set up
+ * the clock. All other cores need to call the CLOCK_SetXtal32Freq
+ * to get a valid clock frequency.
+ */
+extern uint32_t g_xtal32Freq;
+
+/*! @brief Clock ip name array for RTC. */
+#define RTC_CLOCKS  \
+    {               \
+        kCLOCK_Rtc0 \
+    }
+
+/*! @brief Clock ip name array for LPUART. */
+#define LPUART_CLOCKS  \
+    {                  \
+        kCLOCK_Lpuart0 \
+    }
+
+/*! @brief Clock ip name array for SPI. */
+#define SPI_CLOCKS  \
+    {               \
+        kCLOCK_Spi0 \
+    }
+
+/*! @brief Clock ip name array for LPTMR. */
+#define LPTMR_CLOCKS  \
+    {                 \
+        kCLOCK_Lptmr0 \
+    }
+
+/*! @brief Clock ip name array for ADC16. */
+#define ADC16_CLOCKS \
+    {                \
+        kCLOCK_Adc0  \
+    }
+
+/*! @brief Clock ip name array for TPM. */
+#define TPM_CLOCKS               \
+    {                            \
+        kCLOCK_Tpm0, kCLOCK_Tpm1 \
+    }
+
+/*! @brief Clock ip name array for VREF. */
+#define VREF_CLOCKS  \
+    {                \
+        kCLOCK_Vref0 \
+    }
+
+/*! @brief Clock ip name array for I2C. */
+#define I2C_CLOCKS  \
+    {               \
+        kCLOCK_I2c0 \
+    }
+
+/*! @brief Clock ip name array for PORT. */
+#define PORT_CLOCKS                \
+    {                              \
+        kCLOCK_PortA, kCLOCK_PortB \
+    }
+
+/*! @brief Clock ip name array for FTF. */
+#define FTF_CLOCKS  \
+    {               \
+        kCLOCK_Ftf0 \
+    }
+
+/*! @brief Clock ip name array for CMP. */
+#define CMP_CLOCKS  \
+    {               \
+        kCLOCK_Cmp0 \
+    }
+
+/*!
+ * @brief LPO clock frequency.
+ */
+#define LPO_CLK_FREQ 1000U
+
+/*! @brief Peripherals clock source definition. */
+#define SYS_CLK kCLOCK_CoreSysClk
+#define BUS_CLK kCLOCK_BusClk
+
+#define I2C0_CLK_SRC SYS_CLK
+#define SPI0_CLK_SRC BUS_CLK
+
+/*! @brief Clock name used to get clock frequency. */
+typedef enum _clock_name
+{
+
+    /* ----------------------------- System layer clock -------------------------------*/
+    kCLOCK_CoreSysClk, /*!< Core/system clock                                         */
+    kCLOCK_PlatClk,    /*!< Platform clock                                            */
+    kCLOCK_BusClk,     /*!< Bus clock                                                 */
+    kCLOCK_FlashClk,   /*!< Flash clock                                               */
+
+    /* ---------------------------------- OSC clock -----------------------------------*/
+    kCLOCK_Er32kClk,  /*!< External reference 32K clock (ERCLK32K)                   */
+    kCLOCK_Osc0ErClk, /*!< OSC0 external reference clock (OSC0ERCLK)                 */
+
+    /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
+    kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
+    kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
+    kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
+    kCLOCK_McgPeriphClk,      /*!< MCG peripheral clock (MCGPCLK)                            */
+    kCLOCK_McgIrc48MClk,      /*!< MCG IRC48M clock                                          */
+
+    /* --------------------------------- Other clock ----------------------------------*/
+    kCLOCK_LpoClk, /*!< LPO clock                                                 */
+
+} clock_name_t;
+
+/*------------------------------------------------------------------------------
+
+ clock_gate_t definition:
+
+ 31                              16                              0
+ -----------------------------------------------------------------
+ | SIM_SCGC register offset       |   control bit offset in SCGC |
+ -----------------------------------------------------------------
+
+ For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
+ SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
+
+              kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
+
+------------------------------------------------------------------------------*/
+
+#define CLK_GATE_REG_OFFSET_SHIFT 16U
+#define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
+#define CLK_GATE_BIT_SHIFT_SHIFT 0U
+#define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
+
+#define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
+    ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
+     (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
+
+#define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIFT)
+#define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
+
+/*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
+typedef enum _clock_ip_name
+{
+    kCLOCK_IpInvalid = 0U,
+    kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
+    kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
+    kCLOCK_Vref0 = CLK_GATE_DEFINE(0x1034U, 20U),
+    kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
+
+    kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
+    kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
+    kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
+    kCLOCK_Lpuart0 = CLK_GATE_DEFINE(0x1038U, 20U),
+
+    kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
+    kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
+    kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
+    kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
+    kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
+} clock_ip_name_t;
+
+/*!@brief SIM configuration structure for clock setting. */
+typedef struct _sim_clock_config
+{
+    uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
+    uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
+} sim_clock_config_t;
+
+/*! @brief Oscillator capacitor load setting.*/
+enum _osc_cap_load
+{
+    kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
+    kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
+    kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
+    kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
+};
+
+/*! @brief OSCERCLK enable mode. */
+enum _oscer_enable_mode
+{
+    kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
+    kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
+};
+
+/*! @brief The OSC configuration for OSCERCLK. */
+typedef struct _oscer_config
+{
+    uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of \ref _oscer_enable_mode. */
+
+} oscer_config_t;
+
+/*! @brief The OSC work mode. */
+typedef enum _osc_mode
+{
+    kOSC_ModeExt = 0U,                         /*!< Use external clock.   */
+    kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
+} osc_mode_t;
+
+/*!
+ * @brief OSC Initialization Configuration Structure
+ *
+ * Defines the configuration data structure to initialize the OSC.
+ * When porting to a new board, set the following members
+ * according to the board settings:
+ * 1. freq: The external frequency.
+ * 2. workMode: The OSC module mode.
+ */
+typedef struct _osc_config
+{
+    uint32_t freq;              /*!< External clock frequency.    */
+    uint8_t capLoad;            /*!< Capacitor load setting.      */
+    osc_mode_t workMode;        /*!< OSC work mode setting.       */
+    oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
+} osc_config_t;
+
+/*! @brief MCG_Lite clock source selection. */
+typedef enum _mcglite_clkout_src
+{
+    kMCGLITE_ClkSrcHirc, /*!< MCGOUTCLK source is HIRC */
+    kMCGLITE_ClkSrcLirc, /*!< MCGOUTCLK source is LIRC */
+    kMCGLITE_ClkSrcExt,  /*!< MCGOUTCLK source is external clock source */
+    kMCGLITE_ClkSrcReserved
+} mcglite_clkout_src_t;
+
+/*! @brief MCG_Lite LIRC select. */
+typedef enum _mcglite_lirc_mode
+{
+    kMCGLITE_Lirc2M, /*!< Slow internal reference(LIRC) 2 MHz clock selected */
+    kMCGLITE_Lirc8M, /*!< Slow internal reference(LIRC) 8 MHz clock selected */
+} mcglite_lirc_mode_t;
+
+/*! @brief MCG_Lite divider factor selection for clock source*/
+typedef enum _mcglite_lirc_div
+{
+    kMCGLITE_LircDivBy1 = 0U, /*!< Divider is 1    */
+    kMCGLITE_LircDivBy2,      /*!< Divider is 2    */
+    kMCGLITE_LircDivBy4,      /*!< Divider is 4    */
+    kMCGLITE_LircDivBy8,      /*!< Divider is 8    */
+    kMCGLITE_LircDivBy16,     /*!< Divider is 16   */
+    kMCGLITE_LircDivBy32,     /*!< Divider is 32   */
+    kMCGLITE_LircDivBy64,     /*!< Divider is 64   */
+    kMCGLITE_LircDivBy128     /*!< Divider is 128  */
+} mcglite_lirc_div_t;
+
+/*! @brief MCG_Lite clock mode definitions */
+typedef enum _mcglite_mode
+{
+    kMCGLITE_ModeHirc48M, /*!< Clock mode is HIRC 48 M  */
+    kMCGLITE_ModeLirc8M,  /*!< Clock mode is LIRC 8 M   */
+    kMCGLITE_ModeLirc2M,  /*!< Clock mode is LIRC 2 M   */
+    kMCGLITE_ModeExt,     /*!< Clock mode is EXT       */
+    kMCGLITE_ModeError    /*!< Unknown mode            */
+} mcglite_mode_t;
+
+/*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
+enum _mcglite_irclk_enable_mode
+{
+    kMCGLITE_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
+    kMCGLITE_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
+};
+
+/*! @brief MCG_Lite configure structure for mode change. */
+typedef struct _mcglite_config
+{
+    mcglite_clkout_src_t outSrc;  /*!< MCGOUT clock select.                */
+    uint8_t irclkEnableMode;      /*!< MCGIRCLK enable mode, OR'ed value of _mcglite_irclk_enable_mode. */
+    mcglite_lirc_mode_t ircs;     /*!< MCG_C2[IRCS].                       */
+    mcglite_lirc_div_t fcrdiv;    /*!< MCG_SC[FCRDIV].                     */
+    mcglite_lirc_div_t lircDiv2;  /*!< MCG_MC[LIRC_DIV2].                  */
+    bool hircEnableInNotHircMode; /*!< HIRC enable when not in HIRC mode.  */
+} mcglite_config_t;
+
+/*******************************************************************************
+ * API
+ ******************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+/*!
+ * @brief Enable the clock for specific IP.
+ *
+ * @param name  Which clock to enable, see \ref clock_ip_name_t.
+ */
+static inline void CLOCK_EnableClock(clock_ip_name_t name)
+{
+    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
+    (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
+}
+
+/*!
+ * @brief Disable the clock for specific IP.
+ *
+ * @param name  Which clock to disable, see \ref clock_ip_name_t.
+ */
+static inline void CLOCK_DisableClock(clock_ip_name_t name)
+{
+    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
+    (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
+}
+
+/*!
+ * @brief Set ERCLK32K source.
+ *
+ * @param src The value to set ERCLK32K clock source.
+ */
+static inline void CLOCK_SetEr32kClock(uint32_t src)
+{
+    SIM->SOPT1 = ((SIM->SOPT1 & ~SIM_SOPT1_OSC32KSEL_MASK) | SIM_SOPT1_OSC32KSEL(src));
+}
+
+/*!
+ * @brief Set LPUART clock source.
+ *
+ * @param src The value to set LPUART clock source.
+ */
+static inline void CLOCK_SetLpuart0Clock(uint32_t src)
+{
+    SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_LPUART0SRC_MASK) | SIM_SOPT2_LPUART0SRC(src));
+}
+
+/*!
+ * @brief Set TPM clock source.
+ *
+ * @param src The value to set TPM clock source.
+ */
+static inline void CLOCK_SetTpmClock(uint32_t src)
+{
+    SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_TPMSRC_MASK) | SIM_SOPT2_TPMSRC(src));
+}
+
+/*!
+ * @brief Set CLKOUT source.
+ *
+ * @param src The value to set CLKOUT source.
+ */
+static inline void CLOCK_SetClkOutClock(uint32_t src)
+{
+    SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_CLKOUTSEL_MASK) | SIM_SOPT2_CLKOUTSEL(src));
+}
+
+/*!
+ * @brief Set RTC_CLKOUT source.
+ *
+ * @param src The value to set RTC_CLKOUT source.
+ */
+static inline void CLOCK_SetRtcClkOutClock(uint32_t src)
+{
+    SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_RTCCLKOUTSEL_MASK) | SIM_SOPT2_RTCCLKOUTSEL(src));
+}
+
+/*!
+ * @brief System clock divider
+ *
+ * Set the SIM_CLKDIV1[OUTDIV1], SIM_CLKDIV1[OUTDIV4].
+ *
+ * @param outdiv1 Clock 1 output divider value.
+ *
+ * @param outdiv4 Clock 4 output divider value.
+ */
+static inline void CLOCK_SetOutDiv(uint32_t outdiv1, uint32_t outdiv4)
+{
+    SIM->CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV4(outdiv4);
+}
+
+/*!
+ * @brief Gets the clock frequency for a specific clock name.
+ *
+ * This function checks the current clock configurations and then calculates
+ * the clock frequency for a specific clock name defined in clock_name_t.
+ * The MCG must be properly configured before using this function.
+ *
+ * @param clockName Clock names defined in clock_name_t
+ * @return Clock frequency value in Hertz
+ */
+uint32_t CLOCK_GetFreq(clock_name_t clockName);
+
+/*!
+ * @brief Get the core clock or system clock frequency.
+ *
+ * @return Clock frequency in Hz.
+ */
+uint32_t CLOCK_GetCoreSysClkFreq(void);
+
+/*!
+ * @brief Get the platform clock frequency.
+ *
+ * @return Clock frequency in Hz.
+ */
+uint32_t CLOCK_GetPlatClkFreq(void);
+
+/*!
+ * @brief Get the bus clock frequency.
+ *
+ * @return Clock frequency in Hz.
+ */
+uint32_t CLOCK_GetBusClkFreq(void);
+
+/*!
+ * @brief Get the flash clock frequency.
+ *
+ * @return Clock frequency in Hz.
+ */
+uint32_t CLOCK_GetFlashClkFreq(void);
+
+/*!
+ * @brief Get the external reference 32K clock frequency (ERCLK32K).
+ *
+ * @return Clock frequency in Hz.
+ */
+uint32_t CLOCK_GetEr32kClkFreq(void);
+
+/*!
+ * @brief Get the OSC0 external reference clock frequency (OSC0ERCLK).
+ *
+ * @return Clock frequency in Hz.
+ */
+uint32_t CLOCK_GetOsc0ErClkFreq(void);
+
+/*!
+ * @brief Set the clock configure in SIM module.
+ *
+ * This function sets system layer clock settings in SIM module.
+ *
+ * @param config Pointer to the configure structure.
+ */
+void CLOCK_SetSimConfig(sim_clock_config_t const *config);
+
+/*!
+ * @brief Set the system clock dividers in SIM to safe value.
+ *
+ * The system level clocks (core clock, bus clock, flexbus clock and flash clock)
+ * must be in allowed ranges. During MCG clock mode switch, the MCG output clock
+ * changes then the system level clocks may be out of range. This function could
+ * be used before MCG mode change, to make sure system level clocks are in allowed
+ * range.
+ *
+ * @param config Pointer to the configure structure.
+ */
+static inline void CLOCK_SetSimSafeDivs(void)
+{
+    SIM->CLKDIV1 = 0x00010000U;
+}
+
+/*!
+ * @name MCG_Lite clock frequency
+ * @{
+ */
+
+/*!
+ * @brief Gets the MCG_Lite output clock (MCGOUTCLK) frequency.
+ *
+ * This function gets the MCG_Lite output clock frequency in Hz based on the current
+ * MCG_Lite register value.
+ *
+ * @return The frequency of MCGOUTCLK.
+ */
+uint32_t CLOCK_GetOutClkFreq(void);
+
+/*!
+ * @brief Gets the MCG internal reference clock (MCGIRCLK) frequency.
+ *
+ * This function gets the MCG_Lite internal reference clock frequency in Hz based
+ * on the current MCG register value.
+ *
+ * @return The frequency of MCGIRCLK.
+ */
+uint32_t CLOCK_GetInternalRefClkFreq(void);
+
+/*!
+* @brief Gets the current MCGPCLK frequency.
+*
+* This function gets the MCGPCLK frequency in Hz based on the current MCG_Lite
+* register settings.
+*
+* @return The frequency of MCGPCLK.
+*/
+uint32_t CLOCK_GetPeriphClkFreq(void);
+
+/*! @}*/
+
+/*!
+ * @name MCG_Lite mode.
+ * @{
+ */
+
+/*!
+ * @brief Gets the current MCG_Lite mode.
+ *
+ * This function checks the MCG_Lite registers and determines the current MCG_Lite mode.
+ *
+ * @return The current MCG_Lite mode or error code.
+ */
+mcglite_mode_t CLOCK_GetMode(void);
+
+/*!
+ * @brief Sets the MCG_Lite configuration.
+ *
+ * This function configures the MCG_Lite, includes the output clock source, MCGIRCLK
+ * settings, HIRC settings, and so on. See @ref mcglite_config_t for details.
+ *
+ * @param  targetConfig Pointer to the target MCG_Lite mode configuration structure.
+ * @return Error code.
+ */
+status_t CLOCK_SetMcgliteConfig(mcglite_config_t const *targetConfig);
+
+/*! @}*/
+
+/*!
+ * @name OSC configuration
+ * @{
+ */
+
+/*!
+ * @brief Configures the OSC external reference clock (OSCERCLK).
+ *
+ * This function configures the OSC external reference clock (OSCERCLK).
+ * This is an example to enable the OSCERCLK in normal mode and stop mode, and set
+ * the output divider to 1.
+ *
+   @code
+   oscer_config_t config =
+   {
+       .enableMode = kOSC_ErClkEnable | kOSC_ErClkEnableInStop,
+       .erclkDiv   = 1U,
+   };
+
+   OSC_SetExtRefClkConfig(OSC, &config);
+   @endcode
+ *
+ * @param base   OSC peripheral address.
+ * @param config Pointer to the configuration structure.
+ */
+static inline void OSC_SetExtRefClkConfig(OSC_Type *base, oscer_config_t const *config)
+{
+    uint8_t reg = base->CR;
+
+    reg &= ~(OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK);
+    reg |= config->enableMode;
+
+    base->CR = reg;
+}
+
+/*!
+ * @brief Sets the capacitor load configuration for the oscillator.
+ *
+ * This function sets the specified capacitor configuration for the oscillator.
+ * This should be done in the early system level initialization function call
+ * based on the system configuration.
+ *
+ * @param base   OSC peripheral address.
+ * @param capLoad OR'ed value for the capacitor load option.See \ref _osc_cap_load.
+ *
+ * Example:
+   @code
+   // To enable only 2 pF and 8 pF capacitor load, please use like this.
+   OSC_SetCapLoad(OSC, kOSC_Cap2P | kOSC_Cap8P);
+   @endcode
+ */
+
+static inline void OSC_SetCapLoad(OSC_Type *base, uint8_t capLoad)
+{
+    uint8_t reg = base->CR;
+
+    reg &= ~(OSC_CR_SC2P_MASK | OSC_CR_SC4P_MASK | OSC_CR_SC8P_MASK | OSC_CR_SC16P_MASK);
+    reg |= capLoad;
+
+    base->CR = reg;
+}
+
+/*!
+ * @brief Initializes the OSC0.
+ *
+ * This function initializes the OSC0 according to the board configuration.
+ *
+ * @param  config Pointer to the OSC0 configuration structure.
+ */
+void CLOCK_InitOsc0(osc_config_t const *config);
+
+/*!
+ * @brief Deinitializes the OSC0.
+ *
+ * This function deinitializes the OSC0.
+ */
+void CLOCK_DeinitOsc0(void);
+
+/*! @}*/
+
+/*!
+ * @name External clock frequency
+ * @{
+ */
+
+/*!
+ * @brief Sets the XTAL0 frequency based on board settings.
+ *
+ * @param freq The XTAL0/EXTAL0 input clock frequency in Hz.
+ */
+static inline void CLOCK_SetXtal0Freq(uint32_t freq)
+{
+    g_xtal0Freq = freq;
+}
+
+/*!
+ * @brief Sets the XTAL32/RTC_CLKIN frequency based on board settings.
+ *
+ * @param freq The XTAL32/EXTAL32/RTC_CLKIN input clock frequency in Hz.
+ */
+static inline void CLOCK_SetXtal32Freq(uint32_t freq)
+{
+    g_xtal32Freq = freq;
+}
+/* @} */
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+/*! @} */
+
+#endif /* _FSL_CLOCK_H_ */
diff --git a/KL0/MKL03Z4/drivers/fsl_port.h b/KL0/MKL03Z4/drivers/fsl_port.h
new file mode 100644
index 0000000..b0e533c
--- /dev/null
+++ b/KL0/MKL03Z4/drivers/fsl_port.h
@@ -0,0 +1,490 @@
+/*
+ * The Clear BSD License
+ * Copyright (c) 2015, Freescale Semiconductor, Inc.
+ * Copyright 2016-2017 NXP
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted (subject to the limitations in the disclaimer below) provided
+ * that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of the copyright holder nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _FSL_PORT_H_
+#define _FSL_PORT_H_
+
+#include "fsl_common.h"
+
+/*!
+ * @addtogroup port
+ * @{
+ */
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+
+/*! @name Driver version */
+/*@{*/
+/*! Version 2.0.2. */
+#define FSL_PORT_DRIVER_VERSION (MAKE_VERSION(2, 0, 2))
+/*@}*/
+
+#if defined(FSL_FEATURE_PORT_HAS_PULL_ENABLE) && FSL_FEATURE_PORT_HAS_PULL_ENABLE
+/*! @brief Internal resistor pull feature selection */
+enum _port_pull
+{
+    kPORT_PullDisable = 0U, /*!< Internal pull-up/down resistor is disabled. */
+    kPORT_PullDown = 2U,    /*!< Internal pull-down resistor is enabled. */
+    kPORT_PullUp = 3U,      /*!< Internal pull-up resistor is enabled. */
+};
+#endif /* FSL_FEATURE_PORT_HAS_PULL_ENABLE */
+
+#if defined(FSL_FEATURE_PORT_HAS_SLEW_RATE) && FSL_FEATURE_PORT_HAS_SLEW_RATE
+/*! @brief Slew rate selection */
+enum _port_slew_rate
+{
+    kPORT_FastSlewRate = 0U, /*!< Fast slew rate is configured. */
+    kPORT_SlowSlewRate = 1U, /*!< Slow slew rate is configured. */
+};
+#endif /* FSL_FEATURE_PORT_HAS_SLEW_RATE */
+
+#if defined(FSL_FEATURE_PORT_HAS_OPEN_DRAIN) && FSL_FEATURE_PORT_HAS_OPEN_DRAIN
+/*! @brief Open Drain feature enable/disable */
+enum _port_open_drain_enable
+{
+    kPORT_OpenDrainDisable = 0U, /*!< Open drain output is disabled. */
+    kPORT_OpenDrainEnable = 1U,  /*!< Open drain output is enabled. */
+};
+#endif /* FSL_FEATURE_PORT_HAS_OPEN_DRAIN */
+
+#if defined(FSL_FEATURE_PORT_HAS_PASSIVE_FILTER) && FSL_FEATURE_PORT_HAS_PASSIVE_FILTER
+/*! @brief Passive filter feature enable/disable */
+enum _port_passive_filter_enable
+{
+    kPORT_PassiveFilterDisable = 0U, /*!< Passive input filter is disabled. */
+    kPORT_PassiveFilterEnable = 1U,  /*!< Passive input filter is enabled. */
+};
+#endif
+
+#if defined(FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH) && FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH
+/*! @brief Configures the drive strength. */
+enum _port_drive_strength
+{
+    kPORT_LowDriveStrength = 0U,  /*!< Low-drive strength is configured. */
+    kPORT_HighDriveStrength = 1U, /*!< High-drive strength is configured. */
+};
+#endif /* FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH */
+
+#if defined(FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK) && FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK
+/*! @brief Unlock/lock the pin control register field[15:0] */
+enum _port_lock_register
+{
+    kPORT_UnlockRegister = 0U, /*!< Pin Control Register fields [15:0] are not locked. */
+    kPORT_LockRegister = 1U,   /*!< Pin Control Register fields [15:0] are locked. */
+};
+#endif /* FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK */
+
+#if defined(FSL_FEATURE_PORT_PCR_MUX_WIDTH) && FSL_FEATURE_PORT_PCR_MUX_WIDTH
+/*! @brief Pin mux selection */
+typedef enum _port_mux
+{
+    kPORT_PinDisabledOrAnalog = 0U, /*!< Corresponding pin is disabled, but is used as an analog pin. */
+    kPORT_MuxAsGpio = 1U,           /*!< Corresponding pin is configured as GPIO. */
+    kPORT_MuxAlt2 = 2U,             /*!< Chip-specific */
+    kPORT_MuxAlt3 = 3U,             /*!< Chip-specific */
+    kPORT_MuxAlt4 = 4U,             /*!< Chip-specific */
+    kPORT_MuxAlt5 = 5U,             /*!< Chip-specific */
+    kPORT_MuxAlt6 = 6U,             /*!< Chip-specific */
+    kPORT_MuxAlt7 = 7U,             /*!< Chip-specific */
+    kPORT_MuxAlt8 = 8U,             /*!< Chip-specific */
+    kPORT_MuxAlt9 = 9U,             /*!< Chip-specific */
+    kPORT_MuxAlt10 = 10U,           /*!< Chip-specific */
+    kPORT_MuxAlt11 = 11U,           /*!< Chip-specific */
+    kPORT_MuxAlt12 = 12U,           /*!< Chip-specific */
+    kPORT_MuxAlt13 = 13U,           /*!< Chip-specific */
+    kPORT_MuxAlt14 = 14U,           /*!< Chip-specific */
+    kPORT_MuxAlt15 = 15U,           /*!< Chip-specific */
+} port_mux_t;
+#endif /* FSL_FEATURE_PORT_PCR_MUX_WIDTH */
+
+/*! @brief Configures the interrupt generation condition. */
+typedef enum _port_interrupt
+{
+    kPORT_InterruptOrDMADisabled = 0x0U, /*!< Interrupt/DMA request is disabled. */
+#if defined(FSL_FEATURE_PORT_HAS_DMA_REQUEST) && FSL_FEATURE_PORT_HAS_DMA_REQUEST
+    kPORT_DMARisingEdge = 0x1U,  /*!< DMA request on rising edge. */
+    kPORT_DMAFallingEdge = 0x2U, /*!< DMA request on falling edge. */
+    kPORT_DMAEitherEdge = 0x3U,  /*!< DMA request on either edge. */
+#endif
+#if defined(FSL_FEATURE_PORT_HAS_IRQC_FLAG) && FSL_FEATURE_PORT_HAS_IRQC_FLAG
+    kPORT_FlagRisingEdge = 0x05U,  /*!< Flag sets on rising edge. */
+    kPORT_FlagFallingEdge = 0x06U, /*!< Flag sets on falling edge. */
+    kPORT_FlagEitherEdge = 0x07U,  /*!< Flag sets on either edge. */
+#endif
+    kPORT_InterruptLogicZero = 0x8U,   /*!< Interrupt when logic zero. */
+    kPORT_InterruptRisingEdge = 0x9U,  /*!< Interrupt on rising edge. */
+    kPORT_InterruptFallingEdge = 0xAU, /*!< Interrupt on falling edge. */
+    kPORT_InterruptEitherEdge = 0xBU,  /*!< Interrupt on either edge. */
+    kPORT_InterruptLogicOne = 0xCU,    /*!< Interrupt when logic one. */
+#if defined(FSL_FEATURE_PORT_HAS_IRQC_TRIGGER) && FSL_FEATURE_PORT_HAS_IRQC_TRIGGER
+    kPORT_ActiveHighTriggerOutputEnable = 0xDU, /*!< Enable active high-trigger output. */
+    kPORT_ActiveLowTriggerOutputEnable = 0xEU,  /*!< Enable active low-trigger output. */
+#endif
+} port_interrupt_t;
+
+#if defined(FSL_FEATURE_PORT_HAS_DIGITAL_FILTER) && FSL_FEATURE_PORT_HAS_DIGITAL_FILTER
+/*! @brief Digital filter clock source selection */
+typedef enum _port_digital_filter_clock_source
+{
+    kPORT_BusClock = 0U, /*!< Digital filters are clocked by the bus clock. */
+    kPORT_LpoClock = 1U, /*!< Digital filters are clocked by the 1 kHz LPO clock. */
+} port_digital_filter_clock_source_t;
+
+/*! @brief PORT digital filter feature configuration definition */
+typedef struct _port_digital_filter_config
+{
+    uint32_t digitalFilterWidth;                    /*!< Set digital filter width */
+    port_digital_filter_clock_source_t clockSource; /*!< Set digital filter clockSource */
+} port_digital_filter_config_t;
+#endif /* FSL_FEATURE_PORT_HAS_DIGITAL_FILTER */
+
+#if defined(FSL_FEATURE_PORT_PCR_MUX_WIDTH) && FSL_FEATURE_PORT_PCR_MUX_WIDTH
+/*! @brief PORT pin configuration structure */
+typedef struct _port_pin_config
+{
+#if defined(FSL_FEATURE_PORT_HAS_PULL_ENABLE) && FSL_FEATURE_PORT_HAS_PULL_ENABLE
+    uint16_t pullSelect : 2; /*!< No-pull/pull-down/pull-up select */
+#else
+    uint16_t : 2;
+#endif /* FSL_FEATURE_PORT_HAS_PULL_ENABLE */
+
+#if defined(FSL_FEATURE_PORT_HAS_SLEW_RATE) && FSL_FEATURE_PORT_HAS_SLEW_RATE
+    uint16_t slewRate : 1; /*!< Fast/slow slew rate Configure */
+#else
+    uint16_t : 1;
+#endif /* FSL_FEATURE_PORT_HAS_SLEW_RATE */
+
+    uint16_t : 1;
+
+#if defined(FSL_FEATURE_PORT_HAS_PASSIVE_FILTER) && FSL_FEATURE_PORT_HAS_PASSIVE_FILTER
+    uint16_t passiveFilterEnable : 1; /*!< Passive filter enable/disable */
+#else
+    uint16_t : 1;
+#endif /* FSL_FEATURE_PORT_HAS_PASSIVE_FILTER */
+
+#if defined(FSL_FEATURE_PORT_HAS_OPEN_DRAIN) && FSL_FEATURE_PORT_HAS_OPEN_DRAIN
+    uint16_t openDrainEnable : 1; /*!< Open drain enable/disable */
+#else
+    uint16_t : 1;
+#endif /* FSL_FEATURE_PORT_HAS_OPEN_DRAIN */
+
+#if defined(FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH) && FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH
+    uint16_t driveStrength : 1; /*!< Fast/slow drive strength configure */
+#else
+    uint16_t : 1;
+#endif
+
+    uint16_t : 1;
+
+#if defined(FSL_FEATURE_PORT_PCR_MUX_WIDTH) && (FSL_FEATURE_PORT_PCR_MUX_WIDTH == 3)
+    uint16_t mux : 3; /*!< Pin mux Configure */
+    uint16_t : 4;
+#elif defined(FSL_FEATURE_PORT_PCR_MUX_WIDTH) && (FSL_FEATURE_PORT_PCR_MUX_WIDTH == 4)
+    uint16_t mux : 4; /*!< Pin mux Configure */
+    uint16_t : 3;
+#else
+    uint16_t : 7,
+#endif
+
+#if defined(FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK) && FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK
+    uint16_t lockRegister : 1; /*!< Lock/unlock the PCR field[15:0] */
+#else
+    uint16_t : 1;
+#endif /* FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK */
+} port_pin_config_t;
+#endif /* FSL_FEATURE_PORT_PCR_MUX_WIDTH */
+
+/*******************************************************************************
+* API
+******************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#if defined(FSL_FEATURE_PORT_PCR_MUX_WIDTH) && FSL_FEATURE_PORT_PCR_MUX_WIDTH
+/*! @name Configuration */
+/*@{*/
+
+/*!
+ * @brief Sets the port PCR register.
+ *
+ * This is an example to define an input pin or output pin PCR configuration.
+ * @code
+ * // Define a digital input pin PCR configuration
+ * port_pin_config_t config = {
+ *      kPORT_PullUp,
+ *      kPORT_FastSlewRate,
+ *      kPORT_PassiveFilterDisable,
+ *      kPORT_OpenDrainDisable,
+ *      kPORT_LowDriveStrength,
+ *      kPORT_MuxAsGpio,
+ *      kPORT_UnLockRegister,
+ * };
+ * @endcode
+ *
+ * @param base   PORT peripheral base pointer.
+ * @param pin    PORT pin number.
+ * @param config PORT PCR register configuration structure.
+ */
+static inline void PORT_SetPinConfig(PORT_Type *base, uint32_t pin, const port_pin_config_t *config)
+{
+    assert(config);
+    uint32_t addr = (uint32_t)&base->PCR[pin];
+    *(volatile uint16_t *)(addr) = *((const uint16_t *)config);
+}
+
+/*!
+ * @brief Sets the port PCR register for multiple pins.
+ *
+ * This is an example to define input pins or output pins PCR configuration.
+ * @code
+ * // Define a digital input pin PCR configuration
+ * port_pin_config_t config = {
+ *      kPORT_PullUp ,
+ *      kPORT_PullEnable,
+ *      kPORT_FastSlewRate,
+ *      kPORT_PassiveFilterDisable,
+ *      kPORT_OpenDrainDisable,
+ *      kPORT_LowDriveStrength,
+ *      kPORT_MuxAsGpio,
+ *      kPORT_UnlockRegister,
+ * };
+ * @endcode
+ *
+ * @param base   PORT peripheral base pointer.
+ * @param mask   PORT pin number macro.
+ * @param config PORT PCR register configuration structure.
+ */
+static inline void PORT_SetMultiplePinsConfig(PORT_Type *base, uint32_t mask, const port_pin_config_t *config)
+{
+    assert(config);
+
+    uint16_t pcrl = *((const uint16_t *)config);
+
+    if (mask & 0xffffU)
+    {
+        base->GPCLR = ((mask & 0xffffU) << 16) | pcrl;
+    }
+    if (mask >> 16)
+    {
+        base->GPCHR = (mask & 0xffff0000U) | pcrl;
+    }
+}
+
+#if defined(FSL_FEATURE_PORT_HAS_MULTIPLE_IRQ_CONFIG) && FSL_FEATURE_PORT_HAS_MULTIPLE_IRQ_CONFIG
+/*!
+ * @brief Sets the port interrupt configuration in PCR register for multiple pins.
+ *
+ * @param base   PORT peripheral base pointer.
+ * @param mask   PORT pin number macro.
+ * @param config  PORT pin interrupt configuration.
+ *        - #kPORT_InterruptOrDMADisabled: Interrupt/DMA request disabled.
+ *        - #kPORT_DMARisingEdge : DMA request on rising edge(if the DMA requests exit).
+ *        - #kPORT_DMAFallingEdge: DMA request on falling edge(if the DMA requests exit).
+ *        - #kPORT_DMAEitherEdge : DMA request on either edge(if the DMA requests exit).
+ *        - #kPORT_FlagRisingEdge : Flag sets on rising edge(if the Flag states exit).
+ *        - #kPORT_FlagFallingEdge : Flag sets on falling edge(if the Flag states exit).
+ *        - #kPORT_FlagEitherEdge : Flag sets on either edge(if the Flag states exit).
+ *        - #kPORT_InterruptLogicZero  : Interrupt when logic zero.
+ *        - #kPORT_InterruptRisingEdge : Interrupt on rising edge.
+ *        - #kPORT_InterruptFallingEdge: Interrupt on falling edge.
+ *        - #kPORT_InterruptEitherEdge : Interrupt on either edge.
+ *        - #kPORT_InterruptLogicOne   : Interrupt when logic one.
+ *        - #kPORT_ActiveHighTriggerOutputEnable : Enable active high-trigger output (if the trigger states exit).
+ *        - #kPORT_ActiveLowTriggerOutputEnable  : Enable active low-trigger output (if the trigger states exit)..
+ */
+static inline void PORT_SetMultipleInterruptPinsConfig(PORT_Type *base, uint32_t mask, port_interrupt_t config)
+{
+    assert(config);
+
+    if (mask & 0xffffU)
+    {
+        base->GICLR = (config << 16) | (mask & 0xffffU);
+    }
+    if (mask >> 16)
+    {
+        base->GICHR = (config << 16) | (mask & 0xffff0000U);
+    }
+}
+#endif
+
+/*!
+ * @brief Configures the pin muxing.
+ *
+ * @param base  PORT peripheral base pointer.
+ * @param pin   PORT pin number.
+ * @param mux   pin muxing slot selection.
+ *        - #kPORT_PinDisabledOrAnalog: Pin disabled or work in analog function.
+ *        - #kPORT_MuxAsGpio          : Set as GPIO.
+ *        - #kPORT_MuxAlt2            : chip-specific.
+ *        - #kPORT_MuxAlt3            : chip-specific.
+ *        - #kPORT_MuxAlt4            : chip-specific.
+ *        - #kPORT_MuxAlt5            : chip-specific.
+ *        - #kPORT_MuxAlt6            : chip-specific.
+ *        - #kPORT_MuxAlt7            : chip-specific.
+ * @Note : This function is NOT recommended to use together with the PORT_SetPinsConfig, because
+ *         the PORT_SetPinsConfig need to configure the pin mux anyway (Otherwise the pin mux is
+ *         reset to zero : kPORT_PinDisabledOrAnalog).
+ *        This function is recommended to use to reset the pin mux
+ *
+ */
+static inline void PORT_SetPinMux(PORT_Type *base, uint32_t pin, port_mux_t mux)
+{
+    base->PCR[pin] = (base->PCR[pin] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(mux);
+}
+#endif /* FSL_FEATURE_PORT_PCR_MUX_WIDTH */
+
+#if defined(FSL_FEATURE_PORT_HAS_DIGITAL_FILTER) && FSL_FEATURE_PORT_HAS_DIGITAL_FILTER
+
+/*!
+ * @brief Enables the digital filter in one port, each bit of the 32-bit register represents one pin.
+ *
+ * @param base  PORT peripheral base pointer.
+ * @param mask  PORT pin number macro.
+ */
+static inline void PORT_EnablePinsDigitalFilter(PORT_Type *base, uint32_t mask, bool enable)
+{
+    if (enable == true)
+    {
+        base->DFER |= mask;
+    }
+    else
+    {
+        base->DFER &= ~mask;
+    }
+}
+
+/*!
+ * @brief Sets the digital filter in one port, each bit of the 32-bit register represents one pin.
+ *
+ * @param base   PORT peripheral base pointer.
+ * @param config PORT digital filter configuration structure.
+ */
+static inline void PORT_SetDigitalFilterConfig(PORT_Type *base, const port_digital_filter_config_t *config)
+{
+    assert(config);
+
+    base->DFCR = PORT_DFCR_CS(config->clockSource);
+    base->DFWR = PORT_DFWR_FILT(config->digitalFilterWidth);
+}
+
+#endif /* FSL_FEATURE_PORT_HAS_DIGITAL_FILTER */
+
+/*@}*/
+
+/*! @name Interrupt */
+/*@{*/
+
+/*!
+ * @brief Configures the port pin interrupt/DMA request.
+ *
+ * @param base    PORT peripheral base pointer.
+ * @param pin     PORT pin number.
+ * @param config  PORT pin interrupt configuration.
+ *        - #kPORT_InterruptOrDMADisabled: Interrupt/DMA request disabled.
+ *        - #kPORT_DMARisingEdge : DMA request on rising edge(if the DMA requests exit).
+ *        - #kPORT_DMAFallingEdge: DMA request on falling edge(if the DMA requests exit).
+ *        - #kPORT_DMAEitherEdge : DMA request on either edge(if the DMA requests exit).
+ *        - #kPORT_FlagRisingEdge : Flag sets on rising edge(if the Flag states exit).
+ *        - #kPORT_FlagFallingEdge : Flag sets on falling edge(if the Flag states exit).
+ *        - #kPORT_FlagEitherEdge : Flag sets on either edge(if the Flag states exit).
+ *        - #kPORT_InterruptLogicZero  : Interrupt when logic zero.
+ *        - #kPORT_InterruptRisingEdge : Interrupt on rising edge.
+ *        - #kPORT_InterruptFallingEdge: Interrupt on falling edge.
+ *        - #kPORT_InterruptEitherEdge : Interrupt on either edge.
+ *        - #kPORT_InterruptLogicOne   : Interrupt when logic one.
+ *        - #kPORT_ActiveHighTriggerOutputEnable : Enable active high-trigger output (if the trigger states exit).
+ *        - #kPORT_ActiveLowTriggerOutputEnable  : Enable active low-trigger output (if the trigger states exit).
+ */
+static inline void PORT_SetPinInterruptConfig(PORT_Type *base, uint32_t pin, port_interrupt_t config)
+{
+    base->PCR[pin] = (base->PCR[pin] & ~PORT_PCR_IRQC_MASK) | PORT_PCR_IRQC(config);
+}
+
+#if defined(FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH) && FSL_FEATURE_PORT_HAS_DRIVE_STRENGTH
+/*!
+ * @brief Configures the port pin drive strength.
+ *
+ * @param base    PORT peripheral base pointer.
+ * @param pin     PORT pin number.
+ * @param config  PORT pin drive strength
+ *        - #kPORT_LowDriveStrength = 0U - Low-drive strength is configured.
+ *        - #kPORT_HighDriveStrength = 1U - High-drive strength is configured.
+ */
+static inline void PORT_SetPinDriveStrength(PORT_Type* base, uint32_t pin, uint8_t strength)
+{
+    base->PCR[pin] = (base->PCR[pin] & ~PORT_PCR_DSE_MASK) |  PORT_PCR_DSE(strength);
+}
+#endif
+
+/*!
+ * @brief Reads the whole port status flag.
+ *
+ * If a pin is configured to generate the DMA request,  the corresponding flag
+ * is cleared automatically at the completion of the requested DMA transfer.
+ * Otherwise, the flag remains set until a logic one is written to that flag.
+ * If configured for a level sensitive interrupt that remains asserted, the flag
+ * is set again immediately.
+ *
+ * @param base PORT peripheral base pointer.
+ * @return Current port interrupt status flags, for example, 0x00010001 means the
+ *         pin 0 and 16 have the interrupt.
+ */
+static inline uint32_t PORT_GetPinsInterruptFlags(PORT_Type *base)
+{
+    return base->ISFR;
+}
+
+/*!
+ * @brief Clears the multiple pin interrupt status flag.
+ *
+ * @param base PORT peripheral base pointer.
+ * @param mask PORT pin number macro.
+ */
+static inline void PORT_ClearPinsInterruptFlags(PORT_Type *base, uint32_t mask)
+{
+    base->ISFR = mask;
+}
+
+/*@}*/
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*! @}*/
+
+#endif /* _FSL_PORT_H_ */
diff --git a/KL0/MKL03Z4/fsl_device_registers.h b/KL0/MKL03Z4/fsl_device_registers.h
new file mode 100644
index 0000000..fa61238
--- /dev/null
+++ b/KL0/MKL03Z4/fsl_device_registers.h
@@ -0,0 +1,63 @@
+/*
+ * The Clear BSD License
+ * Copyright 2014-2016 Freescale Semiconductor, Inc.
+ * Copyright 2016-2017 NXP
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted (subject to the limitations in the disclaimer below) provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __FSL_DEVICE_REGISTERS_H__
+#define __FSL_DEVICE_REGISTERS_H__
+
+/*
+ * Include the cpu specific register header files.
+ *
+ * The CPU macro should be declared in the project or makefile.
+ */
+#if (defined(CPU_MKL03Z16VFG4) || defined(CPU_MKL03Z16VFK4) || defined(CPU_MKL03Z32CAF4) || \
+    defined(CPU_MKL03Z32VFG4) || defined(CPU_MKL03Z32VFK4) || defined(CPU_MKL03Z8VFG4) || \
+    defined(CPU_MKL03Z8VFK4))
+
+#define KL03Z4_SERIES
+
+/* CMSIS-style register definitions */
+#include "MKL03Z4.h"
+/* CPU specific feature definitions */
+#include "MKL03Z4_features.h"
+
+#else
+    #error "No valid CPU defined!"
+#endif
+
+#endif /* __FSL_DEVICE_REGISTERS_H__ */
+
+/*******************************************************************************
+ * EOF
+ ******************************************************************************/
diff --git a/KL0/MKL03Z4/gcc/MKL03Z32xxx4_flash.ld b/KL0/MKL03Z4/gcc/MKL03Z32xxx4_flash.ld
new file mode 100644
index 0000000..7018e19
--- /dev/null
+++ b/KL0/MKL03Z4/gcc/MKL03Z32xxx4_flash.ld
@@ -0,0 +1,242 @@
+/*
+** ###################################################################
+**     Processors:          MKL03Z32CAF4
+**                          MKL03Z32VFG4
+**                          MKL03Z32VFK4
+**
+**     Compiler:            GNU C Compiler
+**     Reference manual:    KL03P24M48SF0RM, Rev 2, Apr 2014
+**     Version:             rev. 1.4, 2014-08-28
+**     Build:               b170817
+**
+**     Abstract:
+**         Linker file for the GNU C Compiler
+**
+**     The Clear BSD License
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2017 NXP
+**     All rights reserved.
+**     
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted (subject to the limitations in the disclaimer below) provided
+**      that the following conditions are met:
+**
+**     1. Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     2. Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     3. Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+** ###################################################################
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+HEAP_SIZE  = DEFINED(__heap_size__)  ? __heap_size__  : 0x0200;
+STACK_SIZE = DEFINED(__stack_size__) ? __stack_size__ : 0x0050;
+
+/* Specify the memory areas */
+MEMORY
+{
+  m_interrupts          (RX)  : ORIGIN = 0x00000000, LENGTH = 0x00000100
+  m_flash_config        (RX)  : ORIGIN = 0x00000400, LENGTH = 0x00000010
+  m_text                (RX)  : ORIGIN = 0x00000410, LENGTH = 0x00007BF0
+  m_data                (RW)  : ORIGIN = 0x1FFFFE00, LENGTH = 0x00000800
+}
+
+/* Define output sections */
+SECTIONS
+{
+  /* The startup code goes first into internal flash */
+  .interrupts :
+  {
+    . = ALIGN(4);
+    KEEP(*(.isr_vector))     /* Startup code */
+    . = ALIGN(4);
+  } > m_interrupts
+
+  .flash_config :
+  {
+    . = ALIGN(4);
+    KEEP(*(.FlashConfig))    /* Flash Configuration Field (FCF) */
+    . = ALIGN(4);
+  } > m_flash_config
+
+  /* The program code and other data goes into internal flash */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)                 /* .text sections (code) */
+    *(.text*)                /* .text* sections (code) */
+    *(.rodata)               /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)               /* glue arm to thumb code */
+    *(.glue_7t)              /* glue thumb to arm code */
+    *(.eh_frame)
+    KEEP (*(.init))
+    KEEP (*(.fini))
+    . = ALIGN(4);
+  } > m_text
+
+  .ARM.extab :
+  {
+    *(.ARM.extab* .gnu.linkonce.armextab.*)
+  } > m_text
+
+  .ARM :
+  {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } > m_text
+
+ .ctors :
+  {
+    __CTOR_LIST__ = .;
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    __CTOR_END__ = .;
+  } > m_text
+
+  .dtors :
+  {
+    __DTOR_LIST__ = .;
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    __DTOR_END__ = .;
+  } > m_text
+
+  .preinit_array :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } > m_text
+
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } > m_text
+
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } > m_text
+
+  __etext = .;    /* define a global symbol at end of code */
+  __DATA_ROM = .; /* Symbol is used by startup for data initialization */
+
+  /* reserve MTB memory at the beginning of m_data */
+  .mtb : /* MTB buffer address as defined by the hardware */
+  {
+    . = ALIGN(8);
+    _mtb_start = .;
+    KEEP(*(.mtb_buf)) /* need to KEEP Micro Trace Buffer as not referenced by application */
+    . = ALIGN(8);
+    _mtb_end = .;
+  } > m_data
+
+  .data : AT(__DATA_ROM)
+  {
+    . = ALIGN(4);
+    __DATA_RAM = .;
+    __data_start__ = .;      /* create a global symbol at data start */
+    *(.data)                 /* .data sections */
+    *(.data*)                /* .data* sections */
+    KEEP(*(.jcr*))
+    . = ALIGN(4);
+    __data_end__ = .;        /* define a global symbol at data end */
+  } > m_data
+
+  __DATA_END = __DATA_ROM + (__data_end__ - __data_start__);
+  text_end = ORIGIN(m_text) + LENGTH(m_text);
+  ASSERT(__DATA_END <= text_end, "region m_text overflowed with text and data")
+
+  /* Uninitialized data section */
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss section */
+    . = ALIGN(4);
+    __START_BSS = .;
+    __bss_start__ = .;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    . = ALIGN(4);
+    __bss_end__ = .;
+    __END_BSS = .;
+  } > m_data
+
+  .heap :
+  {
+    . = ALIGN(8);
+    __end__ = .;
+    PROVIDE(end = .);
+    __HeapBase = .;
+    . += HEAP_SIZE;
+    __HeapLimit = .;
+    __heap_limit = .; /* Add for _sbrk */
+  } > m_data
+
+  .stack :
+  {
+    . = ALIGN(8);
+    . += STACK_SIZE;
+  } > m_data
+
+  /* Initializes stack on the end of block */
+  __StackTop   = ORIGIN(m_data) + LENGTH(m_data);
+  __StackLimit = __StackTop - STACK_SIZE;
+  PROVIDE(__stack = __StackTop);
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+
+  ASSERT(__StackLimit >= __HeapLimit, "region m_data overflowed with stack and heap")
+}
+
diff --git a/KL0/MKL03Z4/gcc/MKL03Z32xxx4_ram.ld b/KL0/MKL03Z4/gcc/MKL03Z32xxx4_ram.ld
new file mode 100644
index 0000000..e66e920
--- /dev/null
+++ b/KL0/MKL03Z4/gcc/MKL03Z32xxx4_ram.ld
@@ -0,0 +1,234 @@
+/*
+** ###################################################################
+**     Processors:          MKL03Z32CAF4
+**                          MKL03Z32VFG4
+**                          MKL03Z32VFK4
+**
+**     Compiler:            GNU C Compiler
+**     Reference manual:    KL03P24M48SF0RM, Rev 2, Apr 2014
+**     Version:             rev. 1.4, 2014-08-28
+**     Build:               b170817
+**
+**     Abstract:
+**         Linker file for the GNU C Compiler
+**
+**     The Clear BSD License
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2017 NXP
+**     All rights reserved.
+**     
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted (subject to the limitations in the disclaimer below) provided
+**      that the following conditions are met:
+**
+**     1. Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     2. Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     3. Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+** ###################################################################
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+HEAP_SIZE  = DEFINED(__heap_size__)  ? __heap_size__  : 0x0200;
+STACK_SIZE = DEFINED(__stack_size__) ? __stack_size__ : 0x0050;
+
+/* Specify the memory areas */
+MEMORY
+{
+  m_interrupts          (RX)  : ORIGIN = 0x1FFFFE00, LENGTH = 0x00000100
+  m_data                (RW)  : ORIGIN = 0x1FFFFF00, LENGTH = 0x00000100
+  m_text                (RX)  : ORIGIN = 0x20000000, LENGTH = 0x00000600
+}
+
+/* Define output sections */
+SECTIONS
+{
+  /* The startup code goes first into internal RAM */
+  .interrupts :
+  {
+    . = ALIGN(4);
+    KEEP(*(.isr_vector))     /* Startup code */
+    . = ALIGN(4);
+  } > m_interrupts
+
+  /* The program code and other data goes into internal RAM */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)                 /* .text sections (code) */
+    *(.text*)                /* .text* sections (code) */
+    *(.rodata)               /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)               /* glue arm to thumb code */
+    *(.glue_7t)              /* glue thumb to arm code */
+    *(.eh_frame)
+    KEEP (*(.init))
+    KEEP (*(.fini))
+    . = ALIGN(4);
+  } > m_text
+
+  .ARM.extab :
+  {
+    *(.ARM.extab* .gnu.linkonce.armextab.*)
+  } > m_text
+
+  .ARM :
+  {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } > m_text
+
+ .ctors :
+  {
+    __CTOR_LIST__ = .;
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    __CTOR_END__ = .;
+  } > m_text
+
+  .dtors :
+  {
+    __DTOR_LIST__ = .;
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    __DTOR_END__ = .;
+  } > m_text
+
+  .preinit_array :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } > m_text
+
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } > m_text
+
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } > m_text
+
+  __etext = .;    /* define a global symbol at end of code */
+  __DATA_ROM = .; /* Symbol is used by startup for data initialization */
+
+  /* reserve MTB memory at the beginning of m_data */
+  .mtb : /* MTB buffer address as defined by the hardware */
+  {
+    . = ALIGN(8);
+    _mtb_start = .;
+    KEEP(*(.mtb_buf)) /* need to KEEP Micro Trace Buffer as not referenced by application */
+    . = ALIGN(8);
+    _mtb_end = .;
+  } > m_data
+
+  .data : AT(__DATA_ROM)
+  {
+    . = ALIGN(4);
+    __DATA_RAM = .;
+    __data_start__ = .;      /* create a global symbol at data start */
+    *(.data)                 /* .data sections */
+    *(.data*)                /* .data* sections */
+    KEEP(*(.jcr*))
+    . = ALIGN(4);
+    __data_end__ = .;        /* define a global symbol at data end */
+  } > m_data
+
+  __DATA_END = __DATA_ROM + (__data_end__ - __data_start__);
+  text_end = ORIGIN(m_text) + LENGTH(m_text);
+  ASSERT(__DATA_END <= text_end, "region m_text overflowed with text and data")
+
+  /* Uninitialized data section */
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss section */
+    . = ALIGN(4);
+    __START_BSS = .;
+    __bss_start__ = .;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    . = ALIGN(4);
+    __bss_end__ = .;
+    __END_BSS = .;
+  } > m_data
+
+  .heap :
+  {
+    . = ALIGN(8);
+    __end__ = .;
+    PROVIDE(end = .);
+    __HeapBase = .;
+    . += HEAP_SIZE;
+    __HeapLimit = .;
+    __heap_limit = .; /* Add for _sbrk */
+  } > m_data
+
+  .stack :
+  {
+    . = ALIGN(8);
+    . += STACK_SIZE;
+  } > m_data
+
+  /* Initializes stack on the end of block */
+  __StackTop   = ORIGIN(m_data) + LENGTH(m_data);
+  __StackLimit = __StackTop - STACK_SIZE;
+  PROVIDE(__stack = __StackTop);
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+
+  ASSERT(__StackLimit >= __HeapLimit, "region m_data overflowed with stack and heap")
+}
+
diff --git a/KL0/MKL03Z4/gcc/startup_MKL03Z4.S b/KL0/MKL03Z4/gcc/startup_MKL03Z4.S
new file mode 100644
index 0000000..18483bb
--- /dev/null
+++ b/KL0/MKL03Z4/gcc/startup_MKL03Z4.S
@@ -0,0 +1,316 @@
+/* ---------------------------------------------------------------------------------------*/
+/*  @file:    startup_MKL03Z4.s                                                           */
+/*  @purpose: CMSIS Cortex-M0P Core Device Startup File                                   */
+/*            MKL03Z4                                                                     */
+/*  @version: 1.4                                                                         */
+/*  @date:    2014-8-28                                                                   */
+/*  @build:   b170730                                                                     */
+/* ---------------------------------------------------------------------------------------*/
+/*                                                                                        */
+/* The Clear BSD License                                                                  */
+/* Copyright 1997-2016 Freescale Semiconductor, Inc.                                      */
+/* Copyright 2016-2017 NXP                                                                */
+/* All rights reserved.                                                                   */
+/*                                                                                        */
+/* Redistribution and use in source and binary forms, with or without modification,       */
+/* are permitted (subject to the limitations in the disclaimer below) provided            */
+/*  that the following conditions are met:                          */
+/*                                                                                        */
+/* 1. Redistributions of source code must retain the above copyright notice, this list    */
+/*   of conditions and the following disclaimer.                                          */
+/*                                                                                        */
+/* 2. Redistributions in binary form must reproduce the above copyright notice, this      */
+/*   list of conditions and the following disclaimer in the documentation and/or          */
+/*   other materials provided with the distribution.                                      */
+/*                                                                                        */
+/* 3. Neither the name of the copyright holder nor the names of its                       */
+/*   contributors may be used to endorse or promote products derived from this            */
+/*   software without specific prior written permission.                                  */
+/*                                                                                        */
+/* NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S' PATENT RIGHTS ARE GRANTED BY THIS LICENSE.*/
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND        */
+/* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED          */
+/* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE                 */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR       */
+/* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES         */
+/* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;           */
+/* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON         */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT                */
+/* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS          */
+/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                           */
+/*****************************************************************************/
+/* Version: GCC for ARM Embedded Processors                                  */
+/*****************************************************************************/
+    .syntax unified
+    .arch armv6-m
+
+    .section .isr_vector, "a"
+    .align 2
+    .globl __isr_vector
+__isr_vector:
+    .long   __StackTop                                      /* Top of Stack */
+    .long   Reset_Handler                                   /* Reset Handler */
+    .long   NMI_Handler                                     /* NMI Handler*/
+    .long   HardFault_Handler                               /* Hard Fault Handler*/
+    .long   0                                               /* Reserved*/
+    .long   0                                               /* Reserved*/
+    .long   0                                               /* Reserved*/
+    .long   0                                               /* Reserved*/
+    .long   0                                               /* Reserved*/
+    .long   0                                               /* Reserved*/
+    .long   0                                               /* Reserved*/
+    .long   SVC_Handler                                     /* SVCall Handler*/
+    .long   0                                               /* Reserved*/
+    .long   0                                               /* Reserved*/
+    .long   PendSV_Handler                                  /* PendSV Handler*/
+    .long   SysTick_Handler                                 /* SysTick Handler*/
+
+                                                            /* External Interrupts*/
+    .long   Reserved16_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved17_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved18_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved19_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved20_IRQHandler                           /* Reserved interrupt*/
+    .long   FTFA_IRQHandler                                 /* Command complete and read collision*/
+    .long   PMC_IRQHandler                                  /* Low-voltage detect, low-voltage warning*/
+    .long   LLWU_IRQHandler                                 /* Low leakage wakeup*/
+    .long   I2C0_IRQHandler                                 /* I2C0 interrupt*/
+    .long   Reserved25_IRQHandler                           /* Reserved interrupt*/
+    .long   SPI0_IRQHandler                                 /* SPI0 single interrupt vector for all sources*/
+    .long   Reserved27_IRQHandler                           /* Reserved interrupt*/
+    .long   LPUART0_IRQHandler                              /* LPUART0 status and error*/
+    .long   Reserved29_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved30_IRQHandler                           /* Reserved interrupt*/
+    .long   ADC0_IRQHandler                                 /* ADC0 interrupt*/
+    .long   CMP0_IRQHandler                                 /* CMP0 interrupt*/
+    .long   TPM0_IRQHandler                                 /* TPM0 single interrupt vector for all sources*/
+    .long   TPM1_IRQHandler                                 /* TPM1 single interrupt vector for all sources*/
+    .long   Reserved35_IRQHandler                           /* Reserved interrupt*/
+    .long   RTC_IRQHandler                                  /* RTC alarm*/
+    .long   RTC_Seconds_IRQHandler                          /* RTC seconds*/
+    .long   Reserved38_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved39_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved40_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved41_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved42_IRQHandler                           /* Reserved interrupt*/
+    .long   Reserved43_IRQHandler                           /* Reserved interrupt*/
+    .long   LPTMR0_IRQHandler                               /* LPTMR0 interrupt*/
+    .long   Reserved45_IRQHandler                           /* Reserved interrupt*/
+    .long   PORTA_IRQHandler                                /* PORTA Pin detect*/
+    .long   PORTB_IRQHandler                                /* PORTB Pin detect*/
+
+    .size    __isr_vector, . - __isr_vector
+
+/* Flash Configuration */
+    .section .FlashConfig, "a"
+    .long 0xFFFFFFFF
+    .long 0xFFFFFFFF
+    .long 0xFFFFFFFF
+    .long 0xFFFF3DFE
+
+    .text
+    .thumb
+
+/* Reset Handler */
+
+    .thumb_func
+    .align 2
+    .globl   Reset_Handler
+    .weak    Reset_Handler
+    .type    Reset_Handler, %function
+Reset_Handler:
+    cpsid   i               /* Mask interrupts */
+    .equ    VTOR, 0xE000ED08
+    ldr     r0, =VTOR
+    ldr     r1, =__isr_vector
+    str     r1, [r0]
+    ldr     r2, [r1]
+    msr     msp, r2
+#ifndef __NO_SYSTEM_INIT
+    ldr   r0,=SystemInit
+    blx   r0
+#endif
+/*     Loop to copy data from read only memory to RAM. The ranges
+ *      of copy from/to are specified by following symbols evaluated in
+ *      linker script.
+ *      __etext: End of code section, i.e., begin of data sections to copy from.
+ *      __data_start__/__data_end__: RAM address range that data should be
+ *      copied to. Both must be aligned to 4 bytes boundary.  */
+
+    ldr    r1, =__etext
+    ldr    r2, =__data_start__
+    ldr    r3, =__data_end__
+
+    subs    r3, r2
+    ble     .LC0
+
+.LC1:
+    subs    r3, 4
+    ldr    r0, [r1,r3]
+    str    r0, [r2,r3]
+    bgt    .LC1
+.LC0:
+
+#ifdef __STARTUP_CLEAR_BSS
+/*     This part of work usually is done in C library startup code. Otherwise,
+ *     define this macro to enable it in this startup.
+ *
+ *     Loop to zero out BSS section, which uses following symbols
+ *     in linker script:
+ *      __bss_start__: start of BSS section. Must align to 4
+ *      __bss_end__: end of BSS section. Must align to 4
+ */
+    ldr r1, =__bss_start__
+    ldr r2, =__bss_end__
+
+    subs    r2, r1
+    ble .LC3
+
+    movs    r0, 0
+.LC2:
+    str r0, [r1, r2]
+    subs    r2, 4
+    bge .LC2
+.LC3:
+#endif
+    cpsie   i               /* Unmask interrupts */
+#ifndef __START
+#define __START _start
+#endif
+#ifndef __ATOLLIC__
+    ldr   r0,=__START
+    blx   r0
+#else
+    ldr   r0,=__libc_init_array
+    blx   r0
+    ldr   r0,=main
+    bx    r0
+#endif
+    .pool
+    .size Reset_Handler, . - Reset_Handler
+
+    .align  1
+    .thumb_func
+    .weak DefaultISR
+    .type DefaultISR, %function
+DefaultISR:
+    ldr r0, =DefaultISR
+    bx r0
+    .size DefaultISR, . - DefaultISR
+
+    .align 1
+    .thumb_func
+    .weak NMI_Handler
+    .type NMI_Handler, %function
+NMI_Handler:
+    ldr   r0,=NMI_Handler
+    bx    r0
+    .size NMI_Handler, . - NMI_Handler
+
+    .align 1
+    .thumb_func
+    .weak HardFault_Handler
+    .type HardFault_Handler, %function
+HardFault_Handler:
+    ldr   r0,=HardFault_Handler
+    bx    r0
+    .size HardFault_Handler, . - HardFault_Handler
+
+    .align 1
+    .thumb_func
+    .weak SVC_Handler
+    .type SVC_Handler, %function
+SVC_Handler:
+    ldr   r0,=SVC_Handler
+    bx    r0
+    .size SVC_Handler, . - SVC_Handler
+
+    .align 1
+    .thumb_func
+    .weak PendSV_Handler
+    .type PendSV_Handler, %function
+PendSV_Handler:
+    ldr   r0,=PendSV_Handler
+    bx    r0
+    .size PendSV_Handler, . - PendSV_Handler
+
+    .align 1
+    .thumb_func
+    .weak SysTick_Handler
+    .type SysTick_Handler, %function
+SysTick_Handler:
+    ldr   r0,=SysTick_Handler
+    bx    r0
+    .size SysTick_Handler, . - SysTick_Handler
+
+    .align 1
+    .thumb_func
+    .weak I2C0_IRQHandler
+    .type I2C0_IRQHandler, %function
+I2C0_IRQHandler:
+    ldr   r0,=I2C0_DriverIRQHandler
+    bx    r0
+    .size I2C0_IRQHandler, . - I2C0_IRQHandler
+
+    .align 1
+    .thumb_func
+    .weak SPI0_IRQHandler
+    .type SPI0_IRQHandler, %function
+SPI0_IRQHandler:
+    ldr   r0,=SPI0_DriverIRQHandler
+    bx    r0
+    .size SPI0_IRQHandler, . - SPI0_IRQHandler
+
+    .align 1
+    .thumb_func
+    .weak LPUART0_IRQHandler
+    .type LPUART0_IRQHandler, %function
+LPUART0_IRQHandler:
+    ldr   r0,=LPUART0_DriverIRQHandler
+    bx    r0
+    .size LPUART0_IRQHandler, . - LPUART0_IRQHandler
+
+
+/*    Macro to define default handlers. Default handler
+ *    will be weak symbol and just dead loops. They can be
+ *    overwritten by other handlers */
+    .macro def_irq_handler  handler_name
+    .weak \handler_name
+    .set  \handler_name, DefaultISR
+    .endm
+
+/* Exception Handlers */
+    def_irq_handler    Reserved16_IRQHandler
+    def_irq_handler    Reserved17_IRQHandler
+    def_irq_handler    Reserved18_IRQHandler
+    def_irq_handler    Reserved19_IRQHandler
+    def_irq_handler    Reserved20_IRQHandler
+    def_irq_handler    FTFA_IRQHandler
+    def_irq_handler    PMC_IRQHandler
+    def_irq_handler    LLWU_IRQHandler
+    def_irq_handler    I2C0_DriverIRQHandler
+    def_irq_handler    Reserved25_IRQHandler
+    def_irq_handler    SPI0_DriverIRQHandler
+    def_irq_handler    Reserved27_IRQHandler
+    def_irq_handler    LPUART0_DriverIRQHandler
+    def_irq_handler    Reserved29_IRQHandler
+    def_irq_handler    Reserved30_IRQHandler
+    def_irq_handler    ADC0_IRQHandler
+    def_irq_handler    CMP0_IRQHandler
+    def_irq_handler    TPM0_IRQHandler
+    def_irq_handler    TPM1_IRQHandler
+    def_irq_handler    Reserved35_IRQHandler
+    def_irq_handler    RTC_IRQHandler
+    def_irq_handler    RTC_Seconds_IRQHandler
+    def_irq_handler    Reserved38_IRQHandler
+    def_irq_handler    Reserved39_IRQHandler
+    def_irq_handler    Reserved40_IRQHandler
+    def_irq_handler    Reserved41_IRQHandler
+    def_irq_handler    Reserved42_IRQHandler
+    def_irq_handler    Reserved43_IRQHandler
+    def_irq_handler    LPTMR0_IRQHandler
+    def_irq_handler    Reserved45_IRQHandler
+    def_irq_handler    PORTA_IRQHandler
+    def_irq_handler    PORTB_IRQHandler
+
+    .end
diff --git a/KL0/MKL03Z4/prj.conf b/KL0/MKL03Z4/prj.conf
new file mode 100644
index 0000000..81f98ce
--- /dev/null
+++ b/KL0/MKL03Z4/prj.conf
@@ -0,0 +1,4 @@
+# Copyright 2024 NXP
+# All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
diff --git a/KL0/MKL03Z4/system_MKL03Z4.c b/KL0/MKL03Z4/system_MKL03Z4.c
new file mode 100644
index 0000000..0235d03
--- /dev/null
+++ b/KL0/MKL03Z4/system_MKL03Z4.c
@@ -0,0 +1,146 @@
+/*
+** ###################################################################
+**     Processors:          MKL03Z16VFG4
+**                          MKL03Z16VFK4
+**                          MKL03Z32CAF4
+**                          MKL03Z32VFG4
+**                          MKL03Z32VFK4
+**                          MKL03Z8VFG4
+**                          MKL03Z8VFK4
+**
+**     Compilers:           Keil ARM C/C++ Compiler
+**                          Freescale C/C++ for Embedded ARM
+**                          GNU C Compiler
+**                          IAR ANSI C/C++ Compiler for ARM
+**                          MCUXpresso Compiler
+**
+**     Reference manual:    KL03P24M48SF0RM, Rev 2, Apr 2014
+**     Version:             rev. 1.4, 2014-08-28
+**     Build:               b170713
+**
+**     Abstract:
+**         Provides a system configuration function and a global variable that
+**         contains the system frequency. It configures the device and initializes
+**         the oscillator (PLL) that is part of the microcontroller device.
+**
+**     The Clear BSD License
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2017 NXP
+**     All rights reserved.
+**     
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted (subject to the limitations in the disclaimer below) provided
+**      that the following conditions are met:
+**
+**     1. Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     2. Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     3. Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+**     Revisions:
+**     - rev. 1.0 (2013-12-11)
+**         Initial version.
+**     - rev. 1.1 (2014-04-16)
+**         Update of the I2C module (SMBUS feature).
+**         Update of the MCG_Light module.
+**         Added register file system (RFSYS).
+**     - rev. 1.2 (2014-04-30)
+**         PEx compatibility macros has been added.
+**     - rev. 1.3 (2014-06-27)
+**         I2C_S1 register was renamed.
+**         GPIO - Modules PTA,PTB renamed to GPIOA,GPIOB.
+**     - rev. 1.4 (2014-08-28)
+**         Update of system files - default clock configuration changed.
+**         Update of startup files - possibility to override DefaultISR added.
+**
+** ###################################################################
+*/
+
+/*!
+ * @file MKL03Z4
+ * @version 1.4
+ * @date 2014-08-28
+ * @brief Device specific configuration file for MKL03Z4 (implementation file)
+ *
+ * Provides a system configuration function and a global variable that contains
+ * the system frequency. It configures the device and initializes the oscillator
+ * (PLL) that is part of the microcontroller device.
+ */
+
+#include <stdint.h>
+#include "fsl_device_registers.h"
+
+
+
+/* ----------------------------------------------------------------------------
+   -- Core clock
+   ---------------------------------------------------------------------------- */
+
+uint32_t SystemCoreClock = DEFAULT_SYSTEM_CLOCK;
+
+/* ----------------------------------------------------------------------------
+   -- SystemInit()
+   ---------------------------------------------------------------------------- */
+
+void SystemInit (void) {
+
+#if (ACK_ISOLATION)
+  if(PMC->REGSC &  PMC_REGSC_ACKISO_MASK) {
+    PMC->REGSC |= PMC_REGSC_ACKISO_MASK; /* VLLSx recovery */
+  }
+#endif
+
+#if (DISABLE_WDOG)
+  /* SIM->COPC: ?=0,COPCLKSEL=0,COPDBGEN=0,COPSTPEN=0,COPT=0,COPCLKS=0,COPW=0 */
+  SIM->COPC = (uint32_t)0x00u;
+#endif /* (DISABLE_WDOG) */
+
+}
+
+/* ----------------------------------------------------------------------------
+   -- SystemCoreClockUpdate()
+   ---------------------------------------------------------------------------- */
+
+void SystemCoreClockUpdate (void) {
+
+  uint32_t MCGOUTClock;                                 /* Variable to store output clock frequency of the MCG module */
+  uint16_t Divider;
+
+  if ((MCG->S & MCG_S_CLKST_MASK) == 0x00U) {
+    /* High internal reference clock is selected */
+    MCGOUTClock = CPU_INT_FAST_CLK_HZ;                                  /* Fast internal reference clock selected */
+  } else if ((MCG->S & MCG_S_CLKST_MASK) == 0x04U) {
+    /* Internal reference clock is selected */
+    Divider = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
+    MCGOUTClock = (uint32_t) (CPU_INT_SLOW_CLK_HZ / Divider);           /* Slow internal reference clock 8MHz selected */
+  } else if ((MCG->S & MCG_S_CLKST_MASK) == 0x08U) {
+    /* External reference clock is selected */
+    MCGOUTClock = CPU_XTAL_CLK_HZ;
+  } else {
+    /* Reserved value */
+    return;
+  } /* (!((MCG->S & MCG_S_CLKST_MASK) == 0x08U)) */
+  SystemCoreClock = (MCGOUTClock / (0x01U + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
+
+}
diff --git a/KL0/MKL03Z4/system_MKL03Z4.h b/KL0/MKL03Z4/system_MKL03Z4.h
new file mode 100644
index 0000000..ff7178c
--- /dev/null
+++ b/KL0/MKL03Z4/system_MKL03Z4.h
@@ -0,0 +1,154 @@
+/*
+** ###################################################################
+**     Processors:          MKL03Z16VFG4
+**                          MKL03Z16VFK4
+**                          MKL03Z32CAF4
+**                          MKL03Z32VFG4
+**                          MKL03Z32VFK4
+**                          MKL03Z8VFG4
+**                          MKL03Z8VFK4
+**
+**     Compilers:           Keil ARM C/C++ Compiler
+**                          Freescale C/C++ for Embedded ARM
+**                          GNU C Compiler
+**                          IAR ANSI C/C++ Compiler for ARM
+**                          MCUXpresso Compiler
+**
+**     Reference manual:    KL03P24M48SF0RM, Rev 2, Apr 2014
+**     Version:             rev. 1.4, 2014-08-28
+**     Build:               b170713
+**
+**     Abstract:
+**         Provides a system configuration function and a global variable that
+**         contains the system frequency. It configures the device and initializes
+**         the oscillator (PLL) that is part of the microcontroller device.
+**
+**     The Clear BSD License
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2017 NXP
+**     All rights reserved.
+**     
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted (subject to the limitations in the disclaimer below) provided
+**      that the following conditions are met:
+**
+**     1. Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     2. Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     3. Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+**     Revisions:
+**     - rev. 1.0 (2013-12-11)
+**         Initial version.
+**     - rev. 1.1 (2014-04-16)
+**         Update of the I2C module (SMBUS feature).
+**         Update of the MCG_Light module.
+**         Added register file system (RFSYS).
+**     - rev. 1.2 (2014-04-30)
+**         PEx compatibility macros has been added.
+**     - rev. 1.3 (2014-06-27)
+**         I2C_S1 register was renamed.
+**         GPIO - Modules PTA,PTB renamed to GPIOA,GPIOB.
+**     - rev. 1.4 (2014-08-28)
+**         Update of system files - default clock configuration changed.
+**         Update of startup files - possibility to override DefaultISR added.
+**
+** ###################################################################
+*/
+
+/*!
+ * @file MKL03Z4
+ * @version 1.4
+ * @date 2014-08-28
+ * @brief Device specific configuration file for MKL03Z4 (header file)
+ *
+ * Provides a system configuration function and a global variable that contains
+ * the system frequency. It configures the device and initializes the oscillator
+ * (PLL) that is part of the microcontroller device.
+ */
+
+#ifndef _SYSTEM_MKL03Z4_H_
+#define _SYSTEM_MKL03Z4_H_                       /**< Symbol preventing repeated inclusion */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+
+#ifndef DISABLE_WDOG
+  #define DISABLE_WDOG  1
+#endif
+
+#define ACK_ISOLATION   1
+
+/* Define clock source values */
+
+#define CPU_XTAL_CLK_HZ                32768u              /* Value of the external crystal or oscillator clock frequency in Hz */
+#define CPU_INT_FAST_CLK_HZ            48000000u           /* Value of the fast internal oscillator clock frequency in Hz  */
+#define CPU_INT_IRC_CLK_HZ             48000000u           /* Value of the 48M internal oscillator clock frequency in Hz  */
+
+/* Low power mode enable */
+/* SMC_PMPROT: AVLP=1,AVLLS=1 */
+#define SYSTEM_SMC_PMPROT_VALUE        0x22u               /* SMC_PMPROT */
+
+#define DEFAULT_SYSTEM_CLOCK           8000000u            /* Default System clock value */
+#define CPU_INT_SLOW_CLK_HZ            8000000u            /* Value of the slow internal oscillator clock frequency in Hz  */
+
+
+/**
+ * @brief System clock frequency (core clock)
+ *
+ * The system clock frequency supplied to the SysTick timer and the processor
+ * core clock. This variable can be used by the user application to setup the
+ * SysTick timer or configure other parameters. It may also be used by debugger to
+ * query the frequency of the debug timer or configure the trace clock speed
+ * SystemCoreClock is initialized with a correct predefined value.
+ */
+extern uint32_t SystemCoreClock;
+
+/**
+ * @brief Setup the microcontroller system.
+ *
+ * Typically this function configures the oscillator (PLL) that is part of the
+ * microcontroller device. For systems with variable clock speed it also updates
+ * the variable SystemCoreClock. SystemInit is called from startup_device file.
+ */
+void SystemInit (void);
+
+/**
+ * @brief Updates the SystemCoreClock variable.
+ *
+ * It must be called whenever the core clock is changed during program
+ * execution. SystemCoreClockUpdate() evaluates the clock register settings and calculates
+ * the current core clock.
+ */
+void SystemCoreClockUpdate (void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _SYSTEM_MKL03Z4_H_ */
diff --git a/KL0/MKL03Z4/variable.cmake b/KL0/MKL03Z4/variable.cmake
new file mode 100644
index 0000000..e36c9a4
--- /dev/null
+++ b/KL0/MKL03Z4/variable.cmake
@@ -0,0 +1,14 @@
+# Copyright 2024 NXP
+# All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+#### chip related
+include(${SdkRootDirPath}/devices/Kinetis/variable.cmake)
+mcux_set_variable(device MKL03Z4)
+mcux_set_variable(device_root devices)
+mcux_set_variable(soc_series KL0)
+#mcux_set_variable(soc_periph periph)
+mcux_set_variable(core_id_suffix_name "")
+
+#### Source record
-- 
2.44.0

